//

Tue Jul 29, 2014
-----------------
objective:
[1] after building a vm from vmbuilder, I will use ARM kernel & initalRam disk on x86 system

source:
[1] http://bugcy013.blogspot.com/2011/07/how-to-cross-compile-arm-kernel-under.html

steps:
[1] run the vm, and access the vm from ssh to enable copy and paste -- note: I need to know how to do that from libvirto!!

	// add more storage for the vm such as 30G
	(host) $ qemu-img resize ubuntu_x86_14.04_v2.qcow2 +30G 
	// run the vm
	(host) $ kvm -m 15G -cpu host -hda ubuntu_x86_14.04_v2.qcow2 -serial stdio -net nic,model=pcnet -net user -redir tcp:2222::22
	// accessing the VM through ssh
	(host) $ ssh -p 2222 alshamlan@localhost
	

	// setting up the hard disk
	// check what is availabe
	(target) $ sudo fdisk -l 
	// create the third partion from the new space
	(target) $ sudo cfdisk /dev/sda
	// you need to reboot!!
	(target) $ sudo reboot
	// To format Linux partitions using ext3 on the new disk:
	(target) $ sudo mkfs.ext3 /dev/sda3
	//Note: Repeat the above step for each partition created (using it's new corresponding partition #, IE /dev/sdb1, /dev/sdb2)

	// Update /etc/fstab file (Automatic Mount on boot)
	// Open /etc/fstab file, enter:
	(target) $ sudo mkdir -p /export
	(target) $ sudo vi /etc/fstab
		//Append as follows:

		/dev/sda3 /export ext3 defaults 1 2

		//Save and close the file.

	// now, reboot and it is automounted 
	(target) $ sudo reboot
	//or do the following if you don't want to reboot
	(target) $ sudo mount /export 

	// raw result
	alshamlan@ubuntu:/export$ df -h
	Filesystem      Size  Used Avail Use% Mounted on
	/dev/sda1       3.7G  679M  2.9G  20% /
	none            4.0K     0  4.0K   0% /sys/fs/cgroup
	udev            7.4G  8.0K  7.4G   1% /dev
	tmpfs           1.5G  288K  1.5G   1% /run
	none            5.0M     0  5.0M   0% /run/lock
	none            7.4G     0  7.4G   0% /run/shm
	none            100M     0  100M   0% /run/user
	/dev/sda3        30G   45M   29G   1% /export
	alshamlan@ubuntu:/export$ 


[2] preprar ubuntu system
clone stable linux kernet git repo behind the firewall
	// needed packages
	$ sudo apt-get install build-essential u-boot-tools qemu qemu-kvm libsdl1.2-dev device-tree-compiler git libncurses5-dev bc
	// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi
	// stable linux git repo 
	$ git clone http://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git 
	// install grub2 
	$ grub2 

[3] building linux kernel -- cross-compile the linux kernel
	// check out v3.15.6
	$ git checkout -b v3.15.6
	// configure the kernel
	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- versatile_defconfig
   	// fix the configurations to run onto qemu
   	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
	   	// here you need to enable below feature.
		Kernel Features  --->  [*] Use the ARM EABI to compile the kernel. (enable this).
   	// building 
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- all 2>&1 | tee all_kernel_arm_versatile.log 
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage modules 2>&1 | tee uImage_kernel_arm_versatile.log
	// ones finished u have create Initial ramdisk 
	$ sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules_install
		// raw result
		alshamlan@alshamlan-OptiPlex-980:~/kernel_git_clone/linux-stable$ sudo time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules_install
		  INSTALL crypto/ansi_cprng.ko
		  INSTALL crypto/krng.ko
		  INSTALL crypto/rng.ko
		  INSTALL drivers/char/hw_random/rng-core.ko
		  INSTALL drivers/i2c/i2c-dev.ko
		  INSTALL drivers/misc/eeprom/eeprom.ko
		  INSTALL drivers/mmc/host/mmci.ko
		  INSTALL drivers/tty/serial/8250/8250.ko
		  INSTALL fs/fat/fat.ko
		  INSTALL fs/fat/vfat.ko
		  INSTALL fs/nls/nls_base.ko
		  INSTALL fs/nls/nls_cp850.ko
		  INSTALL fs/nls/nls_iso8859-1.ko
		  INSTALL sound/ac97_bus.ko
		  INSTALL sound/arm/snd-aaci.ko
		  INSTALL sound/core/oss/snd-mixer-oss.ko
		  INSTALL sound/core/oss/snd-pcm-oss.ko
		  INSTALL sound/core/snd-pcm.ko
		  INSTALL sound/core/snd-timer.ko
		  INSTALL sound/core/snd.ko
		  INSTALL sound/pci/ac97/snd-ac97-codec.ko
		  DEPMOD  3.16.0-rc7
		0.43user 0.34system 0:00.76elapsed 100%CPU (0avgtext+0avgdata 10068maxresident)k
		32inputs+1752outputs (1major+130836minor)pagefaults 0swaps
		alshamlan@alshamlan-OptiPlex-980:~/kernel_git_clone/linux-stable$ 
	

	// when finished host machine
	/lib/modules --> directory compiled version kernel installed. the directory

	name like this 3.16.0-rc7 

[3]  Create the initial file system
// Even though the file sytems will be compiled alone the kernel, an initial file sytem has to be created which will be present in the RAM to run the kernel. To make this inital ram filesystem, mkinitrd is used. In ubuntu mkinitramfs is used instead of that

	$ cd /boot
	$ sudo mkinitramfs 3.16.0-rc7 -o initrd.img ARCH=arm

	Other way (not supported by Ubuntu developers) is to build kernel from source outside of Ubuntu. Once you got sources unpacked and configured you need just one command: “ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- make uImage modules” to build kernel (replace uImage with zImage if your device does not use U-Boot).


[4] Run the kernel in QEMU

	// kernel panic!!
	$ qemu-system-arm -M versatilepb -kernel zImage -initrd initrd.img -m 512M  -append "console=ttyS0,115200 root=/dev/sda3" -nographic
	
	// 
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel arch/arm/boot/uImage

qemu-system-arm -M versatilepb -kernel zImage -initrd initramfs -serial stdio -append "console=ttyAMA0"


Mon Jul 28, 2014
-----------------
objective:
[1] cross-compile linux kernel and run it onto qemu
[2] we will choose arm as proof-of-concept

source:
[1] http://bugcy013.blogspot.com/2011/07/how-to-cross-compile-arm-kernel-under.html

steps:
[1] preprar ubuntu system
clone stable linux kernet git repo behind the firewall
	// needed packages
	$ sudo apt-get install u-boot-tools qemu qemu-kvm libsdl1.2-dev device-tree-compiler
	// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi
	// stable linux git repo 
	$ git clone http://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git 
	// or upgrade it
	$ git reset --hard && git clean -dfx
	$ git pull

[2] cross-compile the linux kernel
	// reset and clean the git repo
	$ git reset --hard && git clean -dfx
	// check out v3.15.6
	$ git checkout -b v3.15.6
	// find the config makefile target for the selected board
	// check the supported platforms
	$ find  arch/arm/configs -name versatil*
		// raw result
		alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ find  arch/arm/configs -name versatil*
		arch/arm/configs/versatile_defconfig
		alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ 
	// clean the sandbox
	// building the kernel
	// clean just in case
	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- distclean
	// configure the kernel
	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- versatile_defconfig
   	// fix the configurations to run onto qemu
   	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
	   	// here you need to enable below feature.
		Kernel Features  --->  [*] Use the ARM EABI to compile the kernel. (enable this).
   	// building 
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- all 2>&1 | tee all_kernel_arm_versatile.log 
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- zImage 2>&1 | tee zImage_kernel_arm_versatile.log
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage modules 2>&1 | tee uImage_kernel_arm_versatile.log
	// ones finished u have create Initial ramdisk 
	$ sudo time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules_install
		// raw result
		alshamlan@alshamlan-OptiPlex-980:~/kernel_git_clone/linux-stable$ sudo time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules_install
		  INSTALL crypto/ansi_cprng.ko
		  INSTALL crypto/krng.ko
		  INSTALL crypto/rng.ko
		  INSTALL drivers/char/hw_random/rng-core.ko
		  INSTALL drivers/i2c/i2c-dev.ko
		  INSTALL drivers/misc/eeprom/eeprom.ko
		  INSTALL drivers/mmc/host/mmci.ko
		  INSTALL drivers/tty/serial/8250/8250.ko
		  INSTALL fs/fat/fat.ko
		  INSTALL fs/fat/vfat.ko
		  INSTALL fs/nls/nls_base.ko
		  INSTALL fs/nls/nls_cp850.ko
		  INSTALL fs/nls/nls_iso8859-1.ko
		  INSTALL sound/ac97_bus.ko
		  INSTALL sound/arm/snd-aaci.ko
		  INSTALL sound/core/oss/snd-mixer-oss.ko
		  INSTALL sound/core/oss/snd-pcm-oss.ko
		  INSTALL sound/core/snd-pcm.ko
		  INSTALL sound/core/snd-timer.ko
		  INSTALL sound/core/snd.ko
		  INSTALL sound/pci/ac97/snd-ac97-codec.ko
		  DEPMOD  3.16.0-rc7
		0.43user 0.34system 0:00.76elapsed 100%CPU (0avgtext+0avgdata 10068maxresident)k
		32inputs+1752outputs (1major+130836minor)pagefaults 0swaps
		alshamlan@alshamlan-OptiPlex-980:~/kernel_git_clone/linux-stable$ 
	

	// when finished host machine
	/lib/modules --> directory compiled version kernel installed. the directory

	name like this 3.16.0-rc7 

[3] Create the initial file system

alshamlan@alshamlan-OptiPlex-980:~/kernel_git_clone/linux-stable/arch/arm/boot$ cat init.c
#include <stdio.h>
 
void main() {
  printf("Hello World!\n");
  while(1);
}
alshamlan@alshamlan-OptiPlex-980:~/kernel_git_clone/linux-stable/arch/arm/boot$  

$ arm-linux-gnueabi-gcc -static init.c -o init

$ echo init|cpio -o --format=newc > initramfs

$ cpio -t < initramfs

qemu-system-arm -M versatilepb -kernel zImage -initrd initramfs -append "console=tty1"

qemu-system-arm -M versatilepb -kernel zImage -initrd initramfs -serial stdio -append "console=ttyAMA0"

// didn't work
[3]  Create the initial file system
// Even though the file sytems will be compiled alone the kernel, an initial file sytem has to be created which will be present in the RAM to run the kernel. To make this inital ram filesystem, mkinitrd is used. In ubuntu mkinitramfs is used instead of that

	$ cd arch/arm/boot/
	$ mkinitramfs 3.16.0-rc7 -o initrd.img ARCH=arm

	Other way (not supported by Ubuntu developers) is to build kernel from source outside of Ubuntu. Once you got sources unpacked and configured you need just one command: “ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- make uImage modules” to build kernel (replace uImage with zImage if your device does not use U-Boot).


[4] Run the kernel in QEMU

	// kernel panic!!
	$ qemu-system-arm -M versatilepb -kernel zImage -initrd initrd.img -m 512M  -append "console=ttyS0,115200 root=/dev/sda3" -nographic
	
	// 
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel arch/arm/boot/uImage

Mon Jul 28, 2014
-----------------
objective:
[1] compile a linux kernel and run it onto qemu regradless to the ISA

sources:
[1] http://nostillsearching.wordpress.com/2012/09/22/compiling-linux-kernel-and-running-it-using-qemu/

steps:
[1] clone stable linux kernet git repo behind the firewall
	$ git clone http://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git 
	// or upgrade it
	$ git reset --hard && git clean -dfx
	$ git pull

[2] configure the kernel
// The next step is to configure the kernel. To configure the kernel , the .config file is needed to be generated. A simple method to generate the .config file is to copy the configure file of the working Linux operating system.. For Ubuntu, it will be in the /boot/ directory. Copy this file to ~/linux/linux-2.6.32.59. An another method is to use make to generate a default config file using the command
	$ make defconfig

//  After generating the .config file, it has to be configured according to the setting we need on the compiled kernel. To make kernel with no windows, without any GUI, we can use menuconfig. Run the following command and a blue screen will appear. Select the settings you need on the kernel and unmark the things which are not required.Then save the config file
	$ make menuconfig

[3] compile the kernel
// The next is to make the kernel, it will take several minutes to complete. Use the following commands
	$ time make all 2>&1 | tee x86_kernel_make_all.log
	$ time make modules 2>&1 | tee x86_kernel_make_modules.log
// when it is finised , a file bzImage will be created in linux-2.6.32.59/arch/i386/boot/ if you are using the i386 architecure. This file is the binary image of the compiled kernel and it is used to run the kernel.

[4] Create the initial file system
// Even though the file sytems will be compiled alone the kernel, an initial file sytem has to be created which will be present in the RAM to run the kernel. To make this inital ram filesystem, mkinitrd is used. In ubuntu mkinitramfs is used instead of that

	$ cd arch/x86/boot/
	$ mkinitramfs -o initrd.img

[5] Run the kernel in QEMU
// QEMU which stands for ‘Quick EMUlater’ is an excellent emulator. It can emulate different processer architecture with high speed on the PC itself. To run the kerenl use the following command,-kernel denotes the kernel image which is going to execute, -initrd reprresents the initial ram filesystem and -m shows how much memory in RAM is allocated for running qemu.

	// works, but you can't copy and paste 
	$ qemu-system-x86_64 -kernel bzImage -initrd initrd.img -m 512M 

	// doesn't work!!
	$ qemu-system-x86_64 -nographic -kernel bzImage -initrd initrd.img -m 512M 
	 
	// better because you simply able to copy and paste
	$ qemu-system-x86_64 -curses  -kernel bzImage -initrd initrd.img -m 512M
	
	// didn't work
	qemu-system-x86_64 -kernel bzImage -initrd initrd.img -m 512M -display none

	// didn't work
	qemu-system-x86_64 -kernel bzImage -initrd initrd.img -m 512M -display  gtk
	
	// didn't work
	qemu-system-x86_64 -kernel bzImage -initrd initrd.img -m 512M -display  -vnc 0.0.0.0:1 -k en-us

	// works, but you can't copy and paste 
	qemu-system-x86_64 -kernel bzImage -initrd initrd.img -m 512M -sdl
	
	// Worked!!
	$ qemu-system-x86_64 -kernel bzImage -initrd initrd.img -m 512M  -append "console=ttyS0" -nographic

system analysis:
[1] kernel version
	(initramfs) uname -a
	Linux (none) 3.16.0-rc7 #1 SMP Mon Jul 28 10:31:09 EDT 2014 x86_64 GNU/Linux
	(initramfs) 

[2] the env

	(initramfs) env
	ROOTFSTYPE=
	HOME=/
	DPKG_ARCH=amd64
	init=
	PS1=(initramfs) 
	ROOTFLAGS=
	recovery=
	debug=
	REASON=No init found. Try passing init= bootarg.
	ROOTDELAY=
	panic=
	TERM=linux
	break=
	UBIMTD=
	quiet=n
	PATH=/sbin:/usr/sbin:/bin:/usr/bin
	resume=UUID=adc2435d-cd73-4826-855a-f37e853bca2f
	BOOTIF=
	blacklist=
	resume_offset=
	MODPROBE_OPTIONS=-qb
	PWD=/
	IP=
	readonly=y
	ROOT=
	rootmnt=/root
	BOOT=local
	(initramfs) 

[3] all availabe commands

	(initramfs) ls -ls `echo  ${PATH} | tr ':' '\n' `
	ls: /usr/sbin: No such file or directory
	ls: /usr/bin: No such file or directory
	/bin:
	     4 -rwxr-xr-x    1      2784 resume
	   244 -rwxr-xr-x    1    248040 udevadm
	     4 -rwxr-xr-x    1      1088 reboot
	   296 -rwxr-xr-x    1    303080 busybox
	    12 -rwxr-xr-x    1     10480 kbd_mode
	     8 -rwxr-xr-x    1      5168 cpio
	     0 lrwxrwxrwx    1         7 mount -> busybox
	    40 -rwxr-xr-x    1     39896 setfont
	    36 -rwxr-xr-x    1     35448 plymouth
	     8 -rwxr-xr-x    1      4872 run-init
	   112 -rwxr-xr-x    1    111432 loadkeys
	     4 -rwxr-xr-x    1       976 dmesg
	     4 -rwxr-xr-x    1      1088 halt
	   152 -rwxr-xr-x    1    154616 kmod
	     4 -rwxr-xr-x    1      1088 poweroff
	     8 -rwxr-xr-x    1      4864 losetup
	     4 -rwxr-xr-x    1      1600 insmod
	     8 -rwxr-xr-x    1      4304 fstype
	    16 -rwxr-xr-x    1     13528 ipconfig
	    64 -rwxr-xr-x    1     64256 date
	     4 -rwxr-xr-x    1      3904 dd
	     4 -rwxr-xr-x    1       800 pivot_root
	    60 -rwxr-xr-x    1     59848 ntfs-3g
	     8 -rwxr-xr-x    1      7128 nfsmount
	     0 lrwxrwxrwx    1         7 sleep -> busybox
	     0 lrwxrwxrwx    1         7 sh -> busybox

	/sbin:
	     0 lrwxrwxrwx    1         9 modprobe -> /bin/kmod
	     0 lrwxrwxrwx    1        12 udevadm -> /bin/udevadm
	    72 -rwxr-xr-x    1     71592 dmsetup
	     0 lrwxrwxrwx    1        12 mount.ntfs -> /bin/ntfs-3g
	   152 -rwxr-xr-x    1    154752 btrfs-zero-log
	    80 -rwxr-xr-x    1     81632 plymouthd
	    32 -rwxr-xr-x    1     31544 blkid
	    24 -rwxr-xr-x    1     23072 dumpe2fs
	    12 -rwxr-xr-x    1     10240 mount.fuse
	     4 -rwxr-xr-x    1       450 fsck.btrfs
	    36 -rwxr-xr-x    1     35384 hwclock
	     0 lrwxrwxrwx    1        12 mount.ntfs-3g -> /bin/ntfs-3g
	     4 -rwxr-xr-x    1      1416 brltty-setup
	   348 -rwxr-xr-x    1    353424 btrfs
	     0 lrwxrwxrwx    1         9 rmmod -> /bin/kmod
	    12 -rwxr-xr-x    1     10576 wait-for-root
	(initramfs) 
	
[4] checking busybox becuase busybox misses its soft links
	(initramfs) busybox 
	BusyBox v1.21.1 (Ubuntu 1:1.21.0-1ubuntu1) multi-call binary.
	BusyBox is copyrighted by many authors between 1998-2012.
	Licensed under GPLv2. See source distribution for detailed
	copyright notices.

	Usage: busybox [function [arguments]...]
	   or: busybox --list
	   or: function [arguments]...

		BusyBox is a multi-call binary that combines many common Unix
		utilities into a single executable.  Most people will create a
		link to busybox for each function they wish to use and BusyBox
		will act like whatever it was invoked as.

	Currently defined functions:
		[, [[, ash, awk, basename, blockdev, cat, chmod, chroot, chvt, clear,
		cmp, cp, cut, deallocvt, df, dnsdomainname, du, dumpkmap, echo, egrep,
		env, expr, false, fbset, fdflush, fgrep, find, grep, gunzip, gzip,
		hostname, ifconfig, ip, kill, ln, loadfont, loadkmap, ls, mkdir,
		mkfifo, mknod, mkswap, mktemp, modinfo, more, mount, mv, openvt, pidof,
		printf, ps, pwd, readlink, reset, rm, rmdir, sed, seq, setkeycodes, sh,
		sleep, sort, stat, static-sh, stty, switch_root, sync, tail, tee, test,
		touch, tr, true, tty, umount, uname, uniq, wc, wget, which, yes, zcat

	(initramfs) 



Sat Jul 26, 2014
---------------------
[1] build an u-boot image that qemu supports 
[2] build a buildroot image that qemu and u-boot support
[3] compile linux kernel that can replace buildroot kernel, and use it onto the buildroot+u-boot+qemu 
[4] the host is "x86" and the target is "arm"
source:
[1] first read the "README"!! for info
	$  gedit README &
[2] http://elinux.org/Virtual_Development_Board
[3] http://www.trimslice.com/wiki/index.php/U-Boot_images

steps:
[1] install the needed packages, arm toolchain, and kernel, buildroot, and u-boot git repo's
	// needed packages
	$ sudo apt-get install u-boot-tools qemu qemu-kvm libsdl1.2-dev device-tree-compiler
	// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi
	// cloning u-boot git repo
	$ cd <where you want>
	$ mkdir u-boot && cd u-boot
	$ git clone git://git.denx.de/u-boot.git
	// cloning stable linux kernel repo
	$ cd <where you want>
	$ mkdir linux && cd linux
	$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
	// cloning buildroot git repo
	$ cd <where you want>
	$ mkdir buildroot && cd buildroot
	$ git clone git://git.buildroot.net/buildroot


[2] building u-boot image
	// clean the sandbox
	$ make distclean ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// configure arm vexpress board before build
	// note: the target is ${target-from-boards.cfg-table}_config
	// so, vexpress_ca5x2 will be vexpress_ca5x2_config
	$ make versatileqemu_config ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// build
	$ make all ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- 2>&1 | tee u-boot_arm_versatilepd.log
	// to run it onto qemu -- for checking
	// this works 
	$ $ qemu-system-arm -M versatilepb -m 128M -nographic -kernel u-boot.bin

[3] building buildroot image
	// cleanning the sandbox
	$ git reset --hard && git clean -dfx
	// configure the buildsystem
	$ make qemu_arm_versatile_defconfig
	// build
	$ time make 2>&1 | tee qemu_arm_versatile.log
	// check suggested qemu arguments for this configurations
	// works
	$ qemu-system-arm -M versatilepb -kernel output/images/zImage -drive file=output/images/rootfs.ext2,if=scsi -append "root=/dev/sda console=ttyAMA0,115200" -serial stdio -net nic,model=smc91c111 -net user

[4] building u-boot + buildroot image
	// building self-contain u-boot image
	$ mkimage -A arm -C none -O linux -T kernel -d zImage -a 0x00010000 -e 0x00010000 zImage.uimg
	$ mkimage -A arm -C none -O linux -T ramdisk -d rootfs.ext2 -a 0x00800000 -e 0x00800000 rootfs.uimg
	$ dd if=/dev/zero of=flash.bin bs=1 count=6M
	$ dd if=u-boot.bin of=flash.bin conv=notrunc bs=1
	$ dd if=zImage.uimg of=flash.bin conv=notrunc bs=1 seek=2M
	$ dd if=rootfs.uimg of=flash.bin conv=notrunc bs=1 seek=4M
	
	// raw results
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ mkimage -A arm -C none -O linux -T kernel -d zImage -a 0x00010000 -e 0x00010000 zImage.uimg
	Image Name:   
	Created:      Sun Jul 27 13:52:04 2014
	Image Type:   ARM Linux Kernel Image (uncompressed)
	Data Size:    2116560 Bytes = 2066.95 kB = 2.02 MB
	Load Address: 00010000
	Entry Point:  00010000
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ mkimage -A arm -C none -O linux -T ramdisk -d rootfs.ext2 -a 0x00800000 -e 0x00800000 rootfs.uimg
	Image Name:   
	Created:      Sun Jul 27 13:52:18 2014
	Image Type:   ARM Linux RAMDisk Image (uncompressed)
	Data Size:    3249152 Bytes = 3173.00 kB = 3.10 MB
	Load Address: 00800000
	Entry Point:  00800000
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ dd if=/dev/zero of=flash.bin bs=1 count=6M
	6291456+0 records in
	6291456+0 records out
	6291456 bytes (6.3 MB) copied, 16.0967 s, 391 kB/s
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ dd if=u-boot.bin of=flash.bin conv=notrunc bs=1
	101096+0 records in
	101096+0 records out
	101096 bytes (101 kB) copied, 0.233834 s, 432 kB/s
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ dd if=zImage.uimg of=flash.bin conv=notrunc bs=1 seek=2M
	2116624+0 records in
	2116624+0 records out
	2116624 bytes (2.1 MB) copied, 4.68814 s, 451 kB/s
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ dd if=rootfs.uimg of=flash.bin conv=notrunc bs=1 seek=4M
	3249216+0 records in
	3249216+0 records out
	3249216 bytes (3.2 MB) copied, 7.77524 s, 418 kB/s
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ 
	
	// running qemu -- u-boot works, but I couldn't find the kernel memory address!!
	$ qemu-system-arm -M versatilepb -m 128M -kernel flash.bin -serial stdio

	// checking the images in u-boot
	alshamlan@alshamlan-K55A:~/development/buildroot+u-boot+linux+qemu+arm+versatile$ qemu-system-arm -M versatilepb -m 128M -kernel flash.bin -serial stdio
	pulseaudio: set_sink_input_volume() failed
	pulseaudio: Reason: Invalid argument
	pulseaudio: set_sink_input_mute() failed
	pulseaudio: Reason: Invalid argument


	U-Boot 2014.07-dirty (Jul 27 2014 - 02:55:54)

	DRAM:  128 MiB
	WARNING: Caches not enabled
	Using default environment

	In:    serial
	Out:   serial
	Err:   serial
	Net:   SMC91111-0
	Warning: SMC91111-0 using MAC address from net device

	Warning: Your board does not use generic board. Please read
	doc/README.generic-board and take action. Boards not
	upgraded by the late 2014 may break or be removed.
	VersatilePB # 
	VersatilePB # 
	VersatilePB # ls
	Unknown command 'ls' - try 'help'
	VersatilePB # iminfo 00210000

	## Checking Image at 00210000 ...
	   Legacy image found
	   Image Name:   
	   Image Type:   ARM Linux Kernel Image (uncompressed)
	   Data Size:    2116560 Bytes = 2 MiB
	   Load Address: 00010000
	   Entry Point:  00010000
	   Verifying Checksum ...    Bad Data CRC
	VersatilePB # iminfo 00410000

	## Checking Image at 00410000 ...
	   Legacy image found
	   Image Name:   
	   Image Type:   ARM Linux RAMDisk Image (uncompressed)
	   Data Size:    3249152 Bytes = 3.1 MiB
	   Load Address: 00800000
	   Entry Point:  00800000
	   Verifying Checksum ... OK
	VersatilePB # 




//-----------------------
// couldn't add the kernel!!
//--------------------------

[4] building linux kernel
	// reset and clean the git repo
	$ git reset --hard && git clean -dfx
	// check out v3.15.6
	$ git checkout -b v3.15.6
	// find the config makefile target for the selected board
	// check the supported platforms
	$ find  arch/arm/configs -name versatil*
		// raw result
		alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ find  arch/arm/configs -name versatil*
		arch/arm/configs/versatile_defconfig
		alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ 
	// clean the sandbox
	// building the kernel
	// clean just in case
	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- distclean
	// configure the kernel
	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- versatile_defconfig
   	// fix the configurations to run onto qemu
   	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
	   	// here you need to enable below feature.
		Kernel Features  --->  [*] Use the ARM EABI to compile the kernel. (enable this).
   	// building 
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- all 2>&1 | tee all_kernel_arm_versatile.log 
   	$ time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- zImage 2>&1 | tee zImage_kernel_arm_versatile.log
   	// prepare the modules
   	$ mkdir -p moudules
   	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules_install INSTALL_MOD_PATH=moudules  
	// testing linux kernel with buildroot userspace rootfs 

// -----------------------------------
// unedited
// -----------------------------------





Sat Jul 26, 2014
---------------------
[1] build an u-boot image that qemu supports 
[2] build a buildroot image that qemu and u-boot support
[3] compile linux kernel that can replace buildroot kernel, and use it onto the buildroot+u-boot+qemu 
[4] the host is "x86" and the target is "arm"
source:
[1] first read the "README"!! for info
	$  gedit README &
[2] http://elinux.org/Virtual_Development_Board
[3] http://www.trimslice.com/wiki/index.php/U-Boot_images

steps:
[1] install the needed packages, arm toolchain, and kernel, buildroot, and u-boot git repo's
	// needed packages
	$ sudo apt-get install u-boot-tools qemu qemu-kvm libsdl1.2-dev device-tree-compiler
	// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi
	// cloning u-boot git repo
	$ cd <where you want>
	$ mkdir u-boot && cd u-boot
	$ git clone git://git.denx.de/u-boot.git
	// cloning stable linux kernel repo
	$ cd <where you want>
	$ mkdir linux && cd linux
	$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git

[2] check what are arm boards that qemu support
	// asking the question what arm boards are supported
	$ qemu-system-arm -M ?
	// raw results
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ qemu-system-arm -M ?
	Supported machines are:
	versatileab          ARM Versatile/AB (ARM926EJ-S)
	versatilepb          ARM Versatile/PB (ARM926EJ-S)
	lm3s811evb           Stellaris LM3S811EVB
	z2                   Zipit Z2 (PXA27x)
	connex               Gumstix Connex (PXA255)
	sx1                  Siemens SX1 (OMAP310) V2
	realview-eb          ARM RealView Emulation Baseboard (ARM926EJ-S)
	cubieboard           cubietech cubieboard
	vexpress-a9          ARM Versatile Express for Cortex-A9
	lm3s6965evb          Stellaris LM3S6965EVB
	realview-pbx-a9      ARM RealView Platform Baseboard Explore for Cortex-A9
	musicpal             Marvell 88w8618 / MusicPal (ARM926EJ-S)
	mainstone            Mainstone II (PXA27x)
	terrier              Terrier PDA (PXA270)
	n810                 Nokia N810 tablet aka. RX-44 (OMAP2420)
	xilinx-zynq-a9       Xilinx Zynq Platform Baseboard for Cortex-A9
	nuri                 Samsung NURI board (Exynos4210)
	realview-eb-mpcore   ARM RealView Emulation Baseboard (ARM11MPCore)
	verdex               Gumstix Verdex (PXA270)
	spitz                Spitz PDA (PXA270)
	canon-a1100          Canon PowerShot A1100 IS
	akita                Akita PDA (PXA270)
	smdkc210             Samsung SMDKC210 board (Exynos4210)
	integratorcp         ARM Integrator/CP (ARM926EJ-S)
	sx1-v1               Siemens SX1 (OMAP310) V1
	kzm                  ARM KZM Emulation Baseboard (ARM1136)
	highbank             Calxeda Highbank (ECX-1000)
	n800                 Nokia N800 tablet aka. RX-34 (OMAP2420)
	collie               Collie PDA (SA-1110)
	realview-pb-a8       ARM RealView Platform Baseboard for Cortex-A8
	vexpress-a15         ARM Versatile Express for Cortex-A15
	none                 empty machine
	cheetah              Palm Tungsten|E aka. Cheetah PDA (OMAP310)
	tosa                 Tosa PDA (PXA255)
	midway               Calxeda Midway (ECX-2000)
	virt                 ARM Virtual Machine
	borzoi               Borzoi PDA (PXA270)
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$

[3] check what qemu boards are supported in buildroot
	// asking the question
	$ make help
	
	// raw results
	alshamlan@alshamlan-K55A:~/buildroot/buildroot$ make help
	Cleaning:
	  clean                  - delete all files created by build
	  distclean              - delete all non-source files (including .config)

	Build:
	  all                    - make world
	  toolchain              - build toolchain
	  <package>-rebuild      - force recompile <package>
	  <package>-reconfigure  - force reconfigure <package>
	  <package>-graph-depends    - generate graph of the dependency tree for package

	Configuration:
	  menuconfig             - interactive curses-based configurator
	  nconfig                - interactive ncurses-based configurator
	  xconfig                - interactive Qt-based configurator
	  gconfig                - interactive GTK-based configurator
	  oldconfig              - resolve any unresolved symbols in .config
	  silentoldconfig        - Same as oldconfig, but quietly, additionally update deps
	  olddefconfig           - Same as silentoldconfig but sets new symbols to their default value
	  randconfig             - New config with random answer to all options
	  defconfig              - New config with default answer to all options
		                     BR2_DEFCONFIG, if set, is used as input
	  savedefconfig          - Save current config as ./defconfig (minimal config)
	  allyesconfig           - New config where all options are accepted with yes
	  allnoconfig            - New config where all options are answered with no
	  randpackageconfig      - New config with random answer to package options
	  allyespackageconfig    - New config where pkg options are accepted with yes
	  allnopackageconfig     - New config where package options are answered with no

	Documentation:
	  manual                 - build manual in all formats
	  manual-html            - build manual in HTML
	  manual-split-html      - build manual in split HTML
	  manual-pdf             - build manual in PDF
	  manual-text            - build manual in text
	  manual-epub            - build manual in ePub
	  graph-build            - generate graphs of the build times
	  graph-depends          - generate graph of the dependency tree

	Miscellaneous:
	  source                 - download all sources needed for offline-build
	  source-check           - check selected packages for valid download URLs
	  external-deps          - list external packages used
	  legal-info             - generate info about license compliance

	  make V=0|1             - 0 => quiet build (default), 1 => verbose build
	  make O=dir             - Locate all output files in "dir", including .config

	Built-in configs:
	  altera_sockit_defconfig             - Build for altera_sockit
	  arm_foundationv8_defconfig          - Build for arm_foundationv8
	  armadeus_apf27_defconfig            - Build for armadeus_apf27
	  armadeus_apf28_defconfig            - Build for armadeus_apf28
	  armadeus_apf51_defconfig            - Build for armadeus_apf51
	  armadeus_apf9328_defconfig          - Build for armadeus_apf9328
	  at91rm9200df_defconfig              - Build for at91rm9200df
	  at91sam9260dfc_defconfig            - Build for at91sam9260dfc
	  at91sam9260eknf_defconfig           - Build for at91sam9260eknf
	  at91sam9261ek_defconfig             - Build for at91sam9261ek
	  at91sam9263ek_defconfig             - Build for at91sam9263ek
	  at91sam9g20dfc_defconfig            - Build for at91sam9g20dfc
	  at91sam9g45m10ek_defconfig          - Build for at91sam9g45m10ek
	  atmel_xplained_defconfig            - Build for atmel_xplained
	  atngw100_defconfig                  - Build for atngw100
	  atstk100x_defconfig                 - Build for atstk100x
	  beaglebone_defconfig                - Build for beaglebone
	  calao_qil_a9260_defconfig           - Build for calao_qil_a9260
	  calao_snowball_defconfig            - Build for calao_snowball
	  calao_tny_a9g20_lpw_defconfig       - Build for calao_tny_a9g20_lpw
	  calao_usb_a9260_defconfig           - Build for calao_usb_a9260
	  calao_usb_a9263_defconfig           - Build for calao_usb_a9263
	  calao_usb_a9g20_lpw_defconfig       - Build for calao_usb_a9g20_lpw
	  cubieboard2_defconfig               - Build for cubieboard2
	  cubieboard_defconfig                - Build for cubieboard
	  ea3250_defconfig                    - Build for ea3250
	  fdi3250_defconfig                   - Build for fdi3250
	  freescale_imx6sabresd_defconfig     - Build for freescale_imx6sabresd
	  freescale_imx6sololiteevk_defconfig - Build for freescale_imx6sololiteevk
	  freescale_mpc8315erdb_defconfig     - Build for freescale_mpc8315erdb
	  freescale_p1010rdb_pa_defconfig     - Build for freescale_p1010rdb_pa
	  gnublin_defconfig                   - Build for gnublin
	  integrator926_defconfig             - Build for integrator926
	  kb9202_defconfig                    - Build for kb9202
	  lego_ev3_defconfig                  - Build for lego_ev3
	  mini2440_defconfig                  - Build for mini2440
	  minnowboard_defconfig               - Build for minnowboard
	  mx53loco_defconfig                  - Build for mx53loco
	  nitrogen6x_defconfig                - Build for nitrogen6x
	  olimex_imx233_olinuxino_defconfig   - Build for olimex_imx233_olinuxino
	  openblocks_a6_defconfig             - Build for openblocks_a6
	  pandaboard_defconfig                - Build for pandaboard
	  phy3250_defconfig                   - Build for phy3250
	  qemu_arm_nuri_defconfig             - Build for qemu_arm_nuri
	  qemu_arm_versatile_defconfig        - Build for qemu_arm_versatile
	  qemu_arm_vexpress_defconfig         - Build for qemu_arm_vexpress
	  qemu_microblazebe_mmu_defconfig     - Build for qemu_microblazebe_mmu
	  qemu_microblazeel_mmu_defconfig     - Build for qemu_microblazeel_mmu
	  qemu_mips64_malta_defconfig         - Build for qemu_mips64_malta
	  qemu_mips64el_malta_defconfig       - Build for qemu_mips64el_malta
	  qemu_mips_malta_defconfig           - Build for qemu_mips_malta
	  qemu_mipsel_malta_defconfig         - Build for qemu_mipsel_malta
	  qemu_ppc_g3beige_defconfig          - Build for qemu_ppc_g3beige
	  qemu_ppc_mpc8544ds_defconfig        - Build for qemu_ppc_mpc8544ds
	  qemu_ppc_virtex_ml507_defconfig     - Build for qemu_ppc_virtex_ml507
	  qemu_sh4_r2d_defconfig              - Build for qemu_sh4_r2d
	  qemu_sparc_ss10_defconfig           - Build for qemu_sparc_ss10
	  qemu_x86_64_defconfig               - Build for qemu_x86_64
	  qemu_x86_defconfig                  - Build for qemu_x86
	  raspberrypi_defconfig               - Build for raspberrypi
	  s6lx9_microboard_defconfig          - Build for s6lx9_microboard
	  sheevaplug_defconfig                - Build for sheevaplug
	  telit_evk_pro3_defconfig            - Build for telit_evk_pro3
	  wandboard_defconfig                 - Build for wandboard
	  zedboard_defconfig                  - Build for zedboard

	See docs/README, or generate the Buildroot manual for further details

	alshamlan@alshamlan-K55A:~/buildroot/buildroot$ 

	// edited results from buildroot
	  qemu_arm_nuri_defconfig             - Build for qemu_arm_nuri
	  qemu_arm_versatile_defconfig        - Build for qemu_arm_versatile
	  qemu_arm_vexpress_defconfig         - Build for qemu_arm_vexpress

[4] check u-boot supports for qemu supported arm boards
	// asking the questions
	$ grep vexpress boards.cfg 
	$ grep nuri boards.cfg 
	$ grep versatile boards.cfg 
	
	// raw results
alshamlan@alshamlan-K55A:~/u-boot/u-boot$ grep vexpress boards.cfg 
Active  aarch64     armv8          -           armltd          vexpress64          vexpress_aemv8a                       vexpress_aemv8a:ARM64                                                                                                             David Feng <fenghua@phytium.com.cn>
Active  aarch64     armv8          -           armltd          vexpress64          vexpress_aemv8a_semi                  vexpress_aemv8a:ARM64,SEMIHOSTING,BASE_FVP                                                                                        Steve Rae <srae@broadcom.com>
Active  arm         armv7          -           armltd          vexpress            vexpress_ca15_tc2                     -                                                                                                                                 -
Active  arm         armv7          -           armltd          vexpress            vexpress_ca5x2                        -                                                                                                                                 Matt Waddel <matt.waddel@linaro.org>
Active  arm         armv7          -           armltd          vexpress            vexpress_ca9x4                        -                                                                                                                                 Matt Waddel <matt.waddel@linaro.org>
alshamlan@alshamlan-K55A:~/u-boot/u-boot$ grep nuri boards.cfg 
alshamlan@alshamlan-K55A:~/u-boot/u-boot$ grep versatile boards.cfg 
Active  arm         arm926ejs      versatile   armltd          versatile           versatileab                           versatile:ARCH_VERSATILE_AB                                                                                                       -
Active  arm         arm926ejs      versatile   armltd          versatile           versatilepb                           versatile:ARCH_VERSATILE_PB                                                                                                       -
Active  arm         arm926ejs      versatile   armltd          versatile           versatileqemu                         versatile:ARCH_VERSATILE_QEMU,ARCH_VERSATILE_PB                                                                                   -
alshamlan@alshamlan-K55A:~/u-boot/u-boot$
	
	// note, boards.cfg table is orgnized as follows:
	# Status, Arch, CPU:SPLCPU, SoC, Vendor, Board name, Target, Options, Maintainers

	// conclusion
	u-boot supoorts: 
	[1] arm versatile board
	[2] arm vexpress board

[3] building u-boot image
	// clean the sandbox
	$ make distclean ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// configure arm vexpress board before build
	// note: the target is ${target-from-boards.cfg-table}_config
	// so, vexpress_ca5x2 will be vexpress_ca5x2_config
	$ make vexpress_ca9x4_config ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// build
	$ make all ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- 2>&1 | tee u-boot_arm_versatilepd.log

note: The compilation will create a u-boot.bin binary image.

[4] to run it onto qemu
	// this works 
	$ qemu-system-arm -M vexpress-a9 -m 128M -nographic -kernel u-boot

[5] compiling linux kernel 
	// check out the README
	$ cat README
	// part from the README
	"make ${PLATFORM}_defconfig"
		                Create a ./.config file by using the default
		                symbol values from
		                arch/$ARCH/configs/${PLATFORM}_defconfig.
		                Use "make help" to get a list of all available
		                platforms of your architecture.
	// check the supported platforms
	$ find  arch/arm/configs -name vexpress*
	
	// raw results
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ find  arch/arm/configs -name vexpress*
	arch/arm/configs/vexpress_defconfig
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ 

	// building the kernel
	// clean just in case
	$ make distclean
	// configure the kernel
	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- vexpress_defconfig 
   	// building -- I got an error!!
   	$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage 2>&1 | tee kernel_arm_vexpress.log 
	
	// the error
	Kernel: arch/arm/boot/zImage is ready
	multiple (or no) load addresses: 
	This is incompatible with uImages
	Specify LOADADDR on the commandline to build an uImage
	make[1]: *** [arch/arm/boot/uImage] Error 1
	make: *** [uImage] Error 2
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$
	
	// but, I found vmlinux is ready!!
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ file vmlinux
	vmlinux: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), statically linked, BuildID[sha1]=4d92c129a095abccb42cb3704047b70dfddf35ed, not stripped
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ nautilus $PWD &
	[1] 3450
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$

	// run the kernel onto qemu -- didn't work
	qemu-system-arm -M vexpress-a9 -m 128M -kernel vmlinux -append 'root=/dev/sda console=ttyAMA0,115200 S rootwait' -nographic

	// trying zImage, which is also already built!!
	$ mkimage -A arm -O linux -T kernel -C none -a 0x80008000 -e 0x80008000 -n "Linux kernel" -d arch/arm/boot/zImage uImage

	// raw results
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ cd ~/kernel_git/linux-stable/
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ mkimage -A arm -O linux -T kernel -C none -a 0x80008000 -e 0x80008000 -n "Linux kernel" -d arch/arm/boot/zImage uImage
	Image Name:   Linux kernel
	Created:      Sun Jul 27 02:02:06 2014
	Image Type:   ARM Linux Kernel Image (uncompressed)
	Data Size:    3320672 Bytes = 3242.84 kB = 3.17 MB
	Load Address: 80008000
	Entry Point:  80008000
	alshamlan@alshamlan-K55A:~/kernel_git/linux-stable$ 

	// building self-contain u-boot image
	$ dd if=/dev/zero of=flash.bin bs=1 count=6M
	$ dd if=u-boot of=flash.bin conv=notrunc bs=1
	$ dd if=uImage of=flash.bin conv=notrunc bs=1 seek=2M
	
	// running qemu -- u-boot works, but I couldn't find the kernel memory address!!
	$ qemu-system-arm -M vexpress-a9 -m 128M -nographic -kernel flash.bin -serial stdio


//-------------------
// old approach
//------------------
[3] building u-boot image
	// clean the sandbox
	$ make distclean ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// configure arm vexpress board before build
	// note: the target is ${target-from-boards.cfg-table}_config
	// so, vexpress_ca5x2 will be vexpress_ca5x2_config
	$ make vexpress_ca5x2_config ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// build
	$ make all ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- 2>&1 | tee u-boot_arm_versatilepd.log

note: The compilation will create a u-boot.bin binary image.

[4] to run it onto qemu
	// this works 
	$ qemu-system-arm -M vexpress-a15 -m 128M -nographic -kernel u-boot
	// but buildroot uses "vexpress-a9" and not "vexpress-a15"
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ cat ~/buildroot/buildroot/board/qemu/arm-vexpress/readme.txt 
	Run the emulation with:

	  qemu-system-arm -M vexpress-a9 -kernel output/images/zImage -drive file=output/images/rootfs.ext2,if=sd -append "console=ttyAMA0,115200 root=/dev/mmcblk0" -serial stdio -net nic,model=lan9118 -net user

	The login prompt will appear in the terminal that started Qemu. The
	graphical window is the framebuffer.

	Tested with QEMU 1.7.0
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ 

	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel u-boot.bin
Note: "You can have a list of commands by entering help, and then try out various commands (hit “Ctrl-a” and then “x” to exit QEMU)."

[5] running hello world rather than the linux kernel


Fri Jul 25, 2014
---------------------
[1] try to use u-boot regradless to the ISA, so arm is the most documented. I will simply go with that!! 
[2] 

source:
[1] http://balau82.wordpress.com/2010/03/10/u-boot-for-arm-on-qemu/
[2] first read the "README"!! for info
	$  gedit README &
[3] http://balau82.wordpress.com/2010/02/28/hello-world-for-bare-metal-arm-using-qemu/
[4] http://rechtzeit.wordpress.com/2012/06/18/problem-running-u-boot-on-qemu-for-versatilepb-arm729ej-s/

steps:
[1] install the needed packages
	$ sudo apt-get install u-boot-tools qemu qemu-kvm libsdl1.2-dev device-tree-compiler

// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi
	
[2] cloning u-boot git repo
	$ cd <where you want>
	$ mkdir u-boot && cd u-boot
	$ git clone git://git.denx.de/u-boot.git

[3] building u-boot image
	// clean the sandbox
	$ make distclean ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
	// configure before build
	$ make versatilepb_config ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-

	// add (or Patch) include/configs/versatile.h
		Add this line

		#define CONFIG_ARCH_VERSATILE_QEMU

		just below

		#ifndef __CONFIG_H
		#define __CONFIG_H

	// build
	$ make all ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- 2>&1 | tee u-boot_arm_versatilepd.log

note: The compilation will create a u-boot.bin binary image.

[4] to run it onto qemu
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel u-boot.bin
Note: "You can have a list of commands by entering help, and then try out various commands (hit “Ctrl-a” and then “x” to exit QEMU)."

[5] running hello world rather than the linux kernel

// create "test.c" as follows:
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat test.c 
	volatile unsigned int * const UART0DR = (unsigned int *)0x101f1000;
	 
	void print_uart0(const char *s) {
	 while(*s != '\0') { /* Loop until end of string */
	 *UART0DR = (unsigned int)(*s); /* Transmit char */
	 s++; /* Next char */
	 }
	}
	 
	void c_entry() {
	 print_uart0("Hello world!\n");
	}
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

The code is pretty straightforward; a couple of details:

    [1] The volatile keyword is necessary to instruct the compiler that the memory pointed by UART0DR can change or has effects independently of the program.
    [2] The unsigned int type enforces 32-bits read and write access.
    [3] The QEMU model of the PL011 serial port ignores the transmit FIFO capabilities; in a real system on chip the “Transmit FIFO Full” flag must be checked in the UARTFR register before writing on the UARTDR register.

The QEMU emulator is written especially to emulate Linux guest systems; for this reason its startup procedure is implemented specifically: the -kernel option loads a binary file (usually a Linux kernel) inside the system memory starting at address 0x00010000. The emulator starts the execution at address 0x00000000, where few instructions (already in place) are used to jump at the beginning of the kernel image. The interrupt table of ARM cores, usually placed at address 0x00000000, is not present, and the peripheral interrupts are disabled at startup, as needed to boot a Linux kernel. Knowing this, to implement a working emulation I need to considerate a few things:

    [1] The software must be compiled and linked to be placed at 0x00010000
    [2] I need to create a binary image of our program
    [3] I can ignore interrupt handling for now

This is the startup.s assembler file I wrote, simplified from the one I wrote in the previous blog post (http://balau82.wordpress.com/2010/02/14/simplest-bare-metal-program-for-arm/):

	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat startup.s
	.global _Reset
	_Reset:
	 LDR sp, =stack_top
	 BL c_entry
	 B .
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 


test.ld source code:

	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat test.ld
	ENTRY(_Reset)
	SECTIONS
	{
	 . = 0x100000;
	 .startup . : { startup.o(.text) }
	 .text : { *(.text) }
	 .data : { *(.data) }
	 .bss : { *(.bss COMMON) }
	 . = ALIGN(8);
	 . = . + 0x1000; /* 4kB of stack memory */
	 stack_top = .;
	}
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

// compiling:
	$ arm-linux-gnueabi-as -mcpu=arm926ej-s -g startup.s -o startup.o
	$ arm-linux-gnueabi-gcc -c -mcpu=arm926ej-s test.c -o test.o
	$ arm-linux-gnueabi-ld -T test.ld -Map=test.map test.o startup.o -o test.elf
	$ arm-linux-gnueabi-objcopy -O binary test.elf test.bin

// Now create the U-Boot image test.uimg with:
	$ mkimage -A arm -C none -O linux -T kernel -d test.bin -a 0x00100000 -e 0x00100000 test.uimg
	
// Now we can create a single binary simply with:
	$ cat u-boot.bin test.uimg > flash.bin

// This binary can be run instead of the U-Boot binary with:
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel flash.bin

// To calculate the address, we must take the size of u-boot and sum the initial address where flash.bin is mapped. From the bash prompt, the following script prints the command to be written inside U-Boot:

	$ printf "bootm 0x%X\n" $(expr $(stat -c%s u-boot) + $(stat -c%s test.uimg))
	// raw
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ printf "bootm 0x%X\n" $(expr $(stat -c%s u-boot.bin) + 65536)
	bootm 0x28AE8
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ 
	
	// raw about the file sizes
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ ls -ls 
	total 2052
	  4 drwxrwxr-x   2 alshamlan alshamlan   4096 Jul 24 17:55 api
	  4 drwxrwxr-x  17 alshamlan alshamlan   4096 Jul 24 17:55 arch
	 12 drwxrwxr-x 264 alshamlan alshamlan  12288 Jul 24 17:55 board
	324 -rw-rw-r--   1 alshamlan alshamlan 328183 Jul 25 21:17 boards.cfg
	 12 drwxrwxr-x   3 alshamlan alshamlan  12288 Jul 25 22:01 common
	  4 -rw-rw-r--   1 alshamlan alshamlan   1772 Jul 24 17:55 config.mk
	 12 -rw-rw-r--   1 alshamlan alshamlan  12082 Jul 24 17:55 CREDITS
	  4 drwxrwxr-x   2 alshamlan alshamlan   4096 Jul 25 22:01 disk
	  4 drwxrwxr-x   8 alshamlan alshamlan   4096 Jul 24 17:55 doc
	  4 drwxrwxr-x  34 alshamlan alshamlan   4096 Jul 25 22:01 drivers
	  4 drwxrwxr-x   2 alshamlan alshamlan   4096 Jul 24 17:55 dts
	  4 drwxrwxr-x   4 alshamlan alshamlan   4096 Jul 24 17:55 examples
	100 -rw-rw-r--   1 alshamlan alshamlan 101304 Jul 25 22:13 flash.bin
	  4 drwxrwxr-x  12 alshamlan alshamlan   4096 Jul 25 22:01 fs
	 12 drwxrwxr-x  24 alshamlan alshamlan  12288 Jul 25 22:01 include
	  4 -rw-rw-r--   1 alshamlan alshamlan   2227 Jul 24 17:55 Kbuild
	  4 drwxrwxr-x   8 alshamlan alshamlan   4096 Jul 25 22:01 lib
	  4 drwxrwxr-x   2 alshamlan alshamlan   4096 Jul 24 17:55 Licenses
	 24 -rwxrwxr-x   1 alshamlan alshamlan  23394 Jul 24 17:55 MAKEALL
	 48 -rw-rw-r--   1 alshamlan alshamlan  45830 Jul 25 21:17 Makefile
	  8 -rwxrwxr-x   1 alshamlan alshamlan   4296 Jul 24 17:55 mkconfig
	  4 drwxrwxr-x   2 alshamlan alshamlan   4096 Jul 25 22:01 net
	  4 drwxrwxr-x   6 alshamlan alshamlan   4096 Jul 24 17:55 post
	220 -rw-rw-r--   1 alshamlan alshamlan 224446 Jul 25 21:17 README
	  4 drwxrwxr-x   3 alshamlan alshamlan   4096 Jul 25 21:17 scripts
	  4 -rw-rw-r--   1 alshamlan alshamlan     17 Jul 24 17:55 snapshot.commit
	  4 -rw-rw-r--   1 alshamlan alshamlan   1412 Jul 25 22:11 startup.o
	  4 -rw-rw-r--   1 alshamlan alshamlan     60 Jul 25 22:05 startup.s
	 20 -rw-rw-r--   1 alshamlan alshamlan  17400 Jul 25 22:01 System.map
	  4 drwxrwxr-x   6 alshamlan alshamlan   4096 Jul 25 22:01 test
	  4 -rwxrwxr-x   1 alshamlan alshamlan    144 Jul 25 22:12 test.bin
	  4 -rw-rw-r--   1 alshamlan alshamlan    300 Jul 25 22:04 test.c
	  8 -rwxrwxr-x   1 alshamlan alshamlan  34325 Jul 25 22:12 test.elf
	  4 -rw-rw-r--   1 alshamlan alshamlan    222 Jul 25 22:07 test.ld
	  4 -rw-rw-r--   1 alshamlan alshamlan   3068 Jul 25 22:12 test.map
	  4 -rw-rw-r--   1 alshamlan alshamlan   1192 Jul 25 22:12 test.o
	  4 -rw-rw-r--   1 alshamlan alshamlan    208 Jul 25 22:12 test.uimg
	  4 drwxrwxr-x  15 alshamlan alshamlan   4096 Jul 25 22:01 tools
	604 -rwxrwxr-x   1 alshamlan alshamlan 643506 Jul 25 22:01 u-boot
	  8 -rw-rw-r--   1 alshamlan alshamlan   7204 Jul 25 22:01 u-boot_arm_versatilepd.log
	100 -rw-rw-r--   1 alshamlan alshamlan 101096 Jul 25 22:01 u-boot.bin
	  4 -rw-rw-r--   1 alshamlan alshamlan   1290 Jul 25 22:01 u-boot.lds
	148 -rw-rw-r--   1 alshamlan alshamlan 150947 Jul 25 22:01 u-boot.map
	284 -rw-rw-r--   1 alshamlan alshamlan 290762 Jul 25 22:01 u-boot.srec
	alshamlan@alshamlan-K55A:~/u-boot/u-boot$ ls -ls 

// check the image in u-boot
	(u-boot) $ iminfo 0x28AE8
	
	// raw
	VersatilePB # iminfo 0x28AE8

	## Checking Image at 00028ae8 ...
	   Legacy image found
	   Image Name:   
	   Image Type:   ARM Linux Kernel Image (uncompressed)
	   Data Size:    144 Bytes = 144 Bytes
	   Load Address: 00100000
	   Entry Point:  00100000
	   Verifying Checksum ... OK
	VersatilePB # 

	// run the image
		(u-boot) $ bootm 0x28AE8

	// raw
	VersatilePB # bootm 0x28AE8
	## Booting kernel from Legacy Image at 00028ae8 ...
	   Image Name:   
	   Image Type:   ARM Linux Kernel Image (uncompressed)
	   Data Size:    144 Bytes = 144 Bytes
	   Load Address: 00100000
	   Entry Point:  00100000
	   Loading Kernel Image ... OK

	Starting kernel ...

	Hello world!



Fri Jul 25, 2014
---------------------
[1] try to use u-boot regradless to the ISA, so arm is the most documented. I will simply go with that!! 
[2] 

source:
[1] http://balau82.wordpress.com/2010/03/10/u-boot-for-arm-on-qemu/
[2] first read the "README"!! for info
	$  gedit README &
[3] http://balau82.wordpress.com/2010/02/28/hello-world-for-bare-metal-arm-using-qemu/

steps:
[1] install the needed packages
	$ sudo apt-get install u-boot-tools qemu qemu-kvm-extras libsdl1.2-dev device-tree-compiler

// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi
	// results -- installed commands
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-
	arm-linux-gnueabi-addr2line       arm-linux-gnueabi-elfedit         arm-linux-gnueabi-gcov-4.7        arm-linux-gnueabi-objdump
	arm-linux-gnueabi-ar              arm-linux-gnueabi-gcc             arm-linux-gnueabi-gprof           arm-linux-gnueabi-ranlib
	arm-linux-gnueabi-as              arm-linux-gnueabi-gcc-4.7         arm-linux-gnueabi-ld              arm-linux-gnueabi-readelf
	arm-linux-gnueabi-c++filt         arm-linux-gnueabi-gcc-ar-4.7      arm-linux-gnueabi-ld.bfd          arm-linux-gnueabi-size
	arm-linux-gnueabi-cpp             arm-linux-gnueabi-gcc-nm-4.7      arm-linux-gnueabi-ld.gold         arm-linux-gnueabi-strings
	arm-linux-gnueabi-cpp-4.7         arm-linux-gnueabi-gcc-ranlib-4.7  arm-linux-gnueabi-nm              arm-linux-gnueabi-strip
	arm-linux-gnueabi-dwp             arm-linux-gnueabi-gcov            arm-linux-gnueabi-objcopy         
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-

	
[2] cloning u-boot git repo
	$ cd <where you want>
	$ mkdir u-boot && cd u-boot
	$ git clone git://git.denx.de/u-boot.git
	// or behind the firewall
	$ git clone http://git.denx.de/u-boot.git

[3] building u-boot image
	// clean the sandbox
	$ make distclean
	// configure before build
	$ make versatilepb_config ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
/* result
alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ make versatilepb_config ARCH=arm CROSS_COMPILE=gcc-arm-linux-gnueabi 
Configuring for versatilepb - Board: versatile, Options: ARCH_VERSATILE_PB
alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 
*/

	// build
	$ make all ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- 2>&1 | tee u-boot_arm_versatilepd.log

note: The compilation will create a u-boot.bin binary image.

[4] to run it onto qemu
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel u-boot

	// raw
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ ls
	api    boards.cfg  CREDITS  drivers   fs       lib       Makefile  post     snapshot.commit  tools                       u-boot.bin  u-boot.srec
	arch   common      disk     dts       include  Licenses  mkconfig  README   System.map       u-boot                      u-boot.lds
	board  config.mk   doc      examples  Kbuild   MAKEALL   net       scripts  test             u-boot_arm_versatilepd.log  u-boot.map
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel u-boot.bin
	pulseaudio: set_sink_input_volume() failed
	pulseaudio: Reason: Invalid argument
	pulseaudio: set_sink_input_mute() failed
	pulseaudio: Reason: Invalid argument
	qemu: fatal: Trying to execute code outside RAM or ROM at 0x08000000

	R00=00000000 R01=00000183 R02=00000100 R03=00000000
	R04=00000000 R05=00000000 R06=00000000 R07=00000000
	R08=00000000 R09=00000000 R10=00000000 R11=00000000
	R12=00000000 R13=00000000 R14=00000000 R15=08000000
	PSR=400001d3 -Z-- A svc32
	s00=00000000 s01=00000000 d00=0000000000000000
	s02=00000000 s03=00000000 d01=0000000000000000
	s04=00000000 s05=00000000 d02=0000000000000000
	s06=00000000 s07=00000000 d03=0000000000000000
	s08=00000000 s09=00000000 d04=0000000000000000
	s10=00000000 s11=00000000 d05=0000000000000000
	s12=00000000 s13=00000000 d06=0000000000000000
	s14=00000000 s15=00000000 d07=0000000000000000
	s16=00000000 s17=00000000 d08=0000000000000000
	s18=00000000 s19=00000000 d09=0000000000000000
	s20=00000000 s21=00000000 d10=0000000000000000
	s22=00000000 s23=00000000 d11=0000000000000000
	s24=00000000 s25=00000000 d12=0000000000000000
	s26=00000000 s27=00000000 d13=0000000000000000
	s28=00000000 s29=00000000 d14=0000000000000000
	s30=00000000 s31=00000000 d15=0000000000000000
	FPSCR: 00000000
	Aborted (core dumped)
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ file u-boot.bin 
	u-boot.bin: data
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ file u-boot
	u-boot                      u-boot.bin                  u-boot.map                  
	u-boot_arm_versatilepd.log  u-boot.lds                  u-boot.srec                 
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ file u-boot
	u-boot: ELF 32-bit LSB  shared object, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), not stripped
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel u-boot
	pulseaudio: set_sink_input_volume() failed
	pulseaudio: Reason: Invalid argument
	pulseaudio: set_sink_input_mute() failed
	pulseaudio: Reason: Invalid argument


	U-Boot 2014.07-00058-gfbe79a1 (Jul 25 2014 - 11:05:31)

	DRAM:  128 MiB
	WARNING: Caches not enabled
	Flash: 64 MiB
	*** Warning - bad CRC, using default environment

	In:    serial
	Out:   serial
	Err:   serial
	Net:   SMC91111-0
	Warning: SMC91111-0 using MAC address from net device

	Warning: Your board does not use generic board. Please read
	doc/README.generic-board and take action. Boards not
	upgraded by the late 2014 may break or be removed.
	VersatilePB # 
	VersatilePB # reset
	resetting ...

Note: "You can have a list of commands by entering help, and then try out various commands (hit “Ctrl-a” and then “x” to exit QEMU)."

[5] running hello world rather than the linux kernel

The "bootm" command in particular is used to boot a program that is loaded in memory as a special U-Boot image, that can be created with the tool "mkimage". This program is usually an operating system kernel, but instead of running a full-blown Linux kernel, we can instead run the simple “Hello world” program described in (http://balau82.wordpress.com/2010/02/28/hello-world-for-bare-metal-arm-using-qemu/).
To do so, we create a single binary that contains both the U-Boot program and our “Hello world” program together. The initial address of the “Hello world” program must be changed with respect to the instructions present in the last blog post, because at 0x10000 (our last initial address) QEMU places the beginning of the U-Boot binary. Since the U-Boot binary is about 100KB, we can place our binary at 0x100000 (that is 1MB) to be safe.

The QEMU emulator supports the VersatilePB platform, that contains an ARM926EJ-S core and, among other peripherals, four UART serial ports; the first serial port in particular (UART0) works  as a terminal when using the -nographic or “-serial stdio” qemu option. The memory map of the VersatilePB board is implemented in QEMU in this board-specific C source; from that I note the address where the UART0 is mapped: 0x101f1000. The code that emulates the serial port inside QEMU (here in the source repository) implements a subset of the functionalities of the PL011 Prime Cell UART from ARM; there is a useful technical manual from the ARM info center that describes how to interact with the hardware. In details, there is a register (UARTDR) that is used to transmit (when writing in the register) and receive (when reading) bytes; this register is placed at offset 0x0, so I need to read and write at the beginning of the memory allocated for the UART0.

// create "test.c" as follows:
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat test.c 
	volatile unsigned int * const UART0DR = (unsigned int *)0x101f1000;
	 
	void print_uart0(const char *s) {
	 while(*s != '\0') { /* Loop until end of string */
	 *UART0DR = (unsigned int)(*s); /* Transmit char */
	 s++; /* Next char */
	 }
	}
	 
	void c_entry() {
	 print_uart0("Hello world!\n");
	}
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

The code is pretty straightforward; a couple of details:

    [1] The volatile keyword is necessary to instruct the compiler that the memory pointed by UART0DR can change or has effects independently of the program.
    [2] The unsigned int type enforces 32-bits read and write access.
    [3] The QEMU model of the PL011 serial port ignores the transmit FIFO capabilities; in a real system on chip the “Transmit FIFO Full” flag must be checked in the UARTFR register before writing on the UARTDR register.

The QEMU emulator is written especially to emulate Linux guest systems; for this reason its startup procedure is implemented specifically: the -kernel option loads a binary file (usually a Linux kernel) inside the system memory starting at address 0x00010000. The emulator starts the execution at address 0x00000000, where few instructions (already in place) are used to jump at the beginning of the kernel image. The interrupt table of ARM cores, usually placed at address 0x00000000, is not present, and the peripheral interrupts are disabled at startup, as needed to boot a Linux kernel. Knowing this, to implement a working emulation I need to considerate a few things:

    [1] The software must be compiled and linked to be placed at 0x00010000
    [2] I need to create a binary image of our program
    [3] I can ignore interrupt handling for now

This is the startup.s assembler file I wrote, simplified from the one I wrote in the previous blog post (http://balau82.wordpress.com/2010/02/14/simplest-bare-metal-program-for-arm/):

	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat startup.s
	.global _Reset
	_Reset:
	 LDR sp, =stack_top
	 BL c_entry
	 B .
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

And this is the linker script test.ld, modified to place the program at the right address:

	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat test.ld
	ENTRY(_Reset)
	SECTIONS
	{
	 . = 0x10000;
	 .startup . : { startup.o(.text) }
	 .text : { *(.text) }
	 .data : { *(.data) }
	 .bss : { *(.bss COMMON) }
	 . = ALIGN(8);
	 . = . + 0x1000; /* 4kB of stack memory */
	 stack_top = .;
	}
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

// Now compiling the code, these are the commands to run:
	$ arm-linux-gnueabi-as -mcpu=arm926ej-s -g startup.s -o startup.o
	$ arm-linux-gnueabi-gcc -c -mcpu=arm926ej-s -g test.c -o test.o
	$ arm-linux-gnueabi-ld -T test.ld test.o startup.o -o test.elf
	$ arm-linux-gnueabi-objcopy -O binary test.elf test.bin

	// raw results
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-as -mcpu=arm926ej-s -g startup.s -o startup.o
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-gcc -c -mcpu=arm926ej-s -g test.c -o test.o
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-ld -T test.ld test.o startup.o -o test.elf
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-objcopy -O binary test.elf test.bin
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ file test.bin 
	test.bin: data
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ file test.elf 
	test.elf: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

These commands create a test.elf program and a test.bin binary image that I can use with the QEMU emulator for ARM systems. 
// To run my program in the emulator, the command is:
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel test.bin
	
	// raw results
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel test.bin
	pulseaudio: set_sink_input_volume() failed
	pulseaudio: Reason: Invalid argument
	pulseaudio: set_sink_input_mute() failed
	pulseaudio: Reason: Invalid argument
	Hello world!
	QEMU 2.0.0 monitor - type 'help' for more information
	(qemu) 
	QEMU: Terminated
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

// to exit from qemu, press <Ctrl> + 'a' then 'x'

The -M option specifies the emulated system. The program prints “Hello world!” in the terminal and runs indefinitely; to exit QEMU, press “Ctrl + a” and then “x”.

It is possible also to debug the program using the CodeSourcery version of gdb, because QEMU implements a gdb connector using a TCP connection. To do so, I run the emulator with the correct options as follows:
	// install arm gdb
	$ sudo apt-get install gdb-arm-none-eabi 
	// run qemu
	$ qemu-system-arm -M versatilepb -m 128M -nographic -s -S -kernel test.bin
	
This command freezes the system before executing any guest code, and waits for a connection on the TCP port 1234. From another terminal, I run arm-none-eabi-gdb and enter the commands:

	(gdb) $ target remote localhost:1234
	(gdb) $ file test.elf

This connects to the QEMU system and loads the debugging symbols of the test program, whose binary image is already loaded in the system memory. From there, it is possible to run the program with the continue command, single-step the program and debug it in general. The exit command in gdb closes both the debugger and the emulator.

To summarize the necessary steps to create a “Hello world” program:

    [1] Install CodeSourcery toolchain
    [2] Install QEMU (in particular qemu-system-arm)
    [3] Write the test.c, startup.s and test.ld source files
    [4] Build the test ELF and binary image
    [5] Run QEMU ARM emulator using the created binary image as a kernel
    [6] Run the gdb debugger and attach to QEMU

// now, let include the hello world onto u-boot image
Create test.c, startup.s and test.ld as last time, but change line 4 of test.ld from “. = 0x10000” to “. = 0x100000“. Build the binary with:
the new test.ld source code:
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ cat test.ld
	ENTRY(_Reset)
	SECTIONS
	{
	 . = 0x100000;
	 .startup . : { startup.o(.text) }
	 .text : { *(.text) }
	 .data : { *(.data) }
	 .bss : { *(.bss COMMON) }
	 . = ALIGN(8);
	 . = . + 0x1000; /* 4kB of stack memory */
	 stack_top = .;
	}
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

// compiling:
	$ arm-linux-gnueabi-gcc -c -mcpu=arm926ej-s test.c -o test.o
	$ arm-linux-gnueabi-ld -T test.ld -Map=test.map test.o startup.o -o test.elf
	$ arm-linux-gnueabi-objcopy -O binary test.elf test.bin

// Now create the U-Boot image test.uimg with:
	$ mkimage -A arm -C none -O linux -T kernel -d test.bin -a 0x00100000 -e 0x00100000 test.uimg
	
	// raw results
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-gcc -c -mcpu=arm926ej-s test.c -o test.o
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-ld -T test.ld -Map=test.map test.o startup.o -o test.elf
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ arm-linux-gnueabi-objcopy -O binary test.elf test.bin
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ mkimage -A arm -C none -O linux -T kernel -d test.bin -a 0x00100000 -e 0x00100000 test.uimg
	Image Name:   
	Created:      Fri Jul 25 11:56:48 2014
	Image Type:   ARM Linux Kernel Image (uncompressed)
	Data Size:    144 Bytes = 0.14 kB = 0.00 MB
	Load Address: 00100000
	Entry Point:  00100000
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

With these options we affirm that the image is for ARM architecture, is not compressed, is meant to be loaded at address 0x100000 and the entry point is at the same address. I use “linux” as operating system and “kernel” as image type because in this way U-Boot cleans the environment before passing the control to our image: this means disabling interrupts, caches and MMU.

Now we can create a single binary simply with:
	$ cat u-boot test.uimg > flash.bin

This binary can be run instead of the U-Boot binary with:
	$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel flash.bin
	
	// raw results
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel flash.bin
	pulseaudio: set_sink_input_volume() failed
	pulseaudio: Reason: Invalid argument
	pulseaudio: set_sink_input_mute() failed
	pulseaudio: Reason: Invalid argument


	U-Boot 2014.07-00058-gfbe79a1 (Jul 25 2014 - 11:05:31)

	DRAM:  128 MiB
	WARNING: Caches not enabled
	Flash: 64 MiB
	*** Warning - bad CRC, using default environment

	In:    serial
	Out:   serial
	Err:   serial
	Net:   SMC91111-0
	Warning: SMC91111-0 using MAC address from net device

	Warning: Your board does not use generic board. Please read
	doc/README.generic-board and take action. Boards not
	upgraded by the late 2014 may break or be removed.
	VersatilePB # 

//-------------------------------
// still, I didn't make it work
//-------------------------------
	
at the U-Boot prompt, we can check that the image is inside the memory: it should be exactly after the u-boot code. To calculate the address, we must take the size of u-boot and sum the initial address where flash.bin is mapped. From the bash prompt, the following script prints the command to be written inside U-Boot:

	$ printf "bootm 0x%X\n" $(expr $(stat -c%s u-boot) + $(stat -c%s test.uimg))
	
	// raw results
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ printf "bootm 0x%X\n" $(expr $(stat -c%s u-boot) + 65536)
	bootm 0xC11CA
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 

in my case it prints “bootm 0xC11CA“. In fact, if I run “iminfo 0xC11CA” inside U-Boot prompt to check the memory content I get:

// raw unedited
//------------------
at the U-Boot prompt, we can check that the image is inside the memory: it should be exactly after the u-boot.bin code. To calculate the address, we must take the size of u-boot.bin and sum the initial address where flash.bin is mapped. From the bash prompt, the following script prints the command to be written inside U-Boot:
	$printf "bootm 0x%X\n" $(expr $(stat -c%s u-boot.bin) + 65536)

in my case it prints “bootm 0x21C68“. In fact, if I run “iminfo 0x21C68” inside U-Boot prompt to check the memory content I get:

	## Checking Image at 00021c68 ...
	Image Name:
	Image Type:   ARM U-Boot Standalone Program (uncompressed)
	Data Size:    376 Bytes =  0.4 kB
	Load Address: 00100000
	Entry Point:  00100000
	Verifying Checksum ... OK
	
I can then confidently run “bootm 0x21C68” (you should substitute your address in this command). This command copies the content of the image, that is actually test.bin, into the address 0x100000 as specified in the U-Boot image, and then jumps to the entry point. The emulator should print “Hello world!” as last time, and then run indefinitely (hit “Ctrl-a” and then “x” to exit). This is basically the same procedure that is used to boot a Linux kernel, with some modifications: for example, the Linux kernel accepts some parameters that must be received from U-Boot somehow. I plan to write a post about that in the future.
In a real world example, the binary file we created could be placed inside the parallel Flash memory of an embedded platform, and the boot process can be controlled from the serial port.


Thu Jul 24, 2014
----------------
objective:
[1] using buildroot builds into u-boot image
[2] then boot the u-boot image in qemu
[3] all of that is done in ubuntu platform

sources:
[1] http://stackoverflow.com/questions/20763344/just-black-screen-after-running-qemu

steps:
[1] install the needed packages
	$ sudo apt-get install u-boot-tools

// arm toolchian
	$ sudo apt-get install gcc-arm-linux-gnueabi 

	
[2] cloning u-boot git repo
	$ cd <where you want>
	$ mkdir u-boot && cd u-boot
	$ git clone git://git.denx.de/u-boot.git
	// or behind the firewall
	$ git clone http://git.denx.de/u-boot.git

[3] building u-boot image
// first read the "README"!! for info
	$  gedit README &

// building from sandbox
	// read the README
	$ gedit board/sandbox/README.sandbox
	// install the needed packages
	$ sudo apt-get -y install libsdl1.2-dev device-tree-compiler
	// clean the sandbox
	$ make distclean
	// build
	$ make sandbox_config all
	// test
	./u-boot
	

// raw

	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ make qemu_mips_config
	Configuring for qemu_mips - Board: qemu-mips, Options: SYS_BIG_ENDIAN
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ make qemu_mipsel_config
	Configuring for qemu_mipsel - Board: qemu-mips, Options: SYS_LITTLE_ENDIAN
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ 



extra:
// building linux kernel and run it in qemu
	$ make ARCH=arm distclean
	$ make ARCH=arm versatile_defconfig

	3)make ARCH=arm menuconfig

	here you need to enable below feature.

	Kernel Features ---> [*] Use the ARM EABI to compile the kernel. (enable this).

	4)make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- uImage

	5)qemu-system-arm -M versatilepb -m 128M -kernel arch/arm/boot/uImage -append "console=tty1"

	Here you will get console saying that kernel panic. to avoid this pass your rootfs parameter.

	I guess you built rootfs from busybox if so try below command to boot system completely

	6)qemu-system-arm -M versatilepb -m 128M -kernel arch/arm/boot/uImage -initrd rootfs.img -append "root=/dev/ram mem=128M rdinit=/sbin/init" -serial stdio.

// checking all the availabe cross-compile toolchain in ubuntu
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ sudo apt-get install gcc-
	gcc-4.4                               gcc-4.7-multilib                      gcc-arm-linux-androideabi
	gcc-4.4-base                          gcc-4.7-multilib-arm-linux-gnueabi    gcc-arm-linux-gnueabi
	gcc-4.4-base-mipsel-cross             gcc-4.7-multilib-arm-linux-gnueabihf  gcc-arm-linux-gnueabihf
	gcc-4.4-doc                           gcc-4.7-plugin-dev                    gcc-arm-none-eabi
	gcc-4.4-locales                       gcc-4.7-source                        gcc-avr
	gcc-4.4-mipsel-linux-gnu-base         gcc-4.8                               gcc-bfin-linux-gnu
	gcc-4.4-multilib                      gcc-4.8-aarch64-linux-gnu             gcc-c6x-linux-gnu
	gcc-4.4-source                        gcc-4.8-aarch64-linux-gnu-base        gcc-doc
	gcc-4.6                               gcc-4.8-arm-linux-gnueabihf           gcc-h8300-hms
	gcc-4.6-base                          gcc-4.8-arm-linux-gnueabihf-base      gcc-i686-linux-android
	gcc-4.6-doc                           gcc-4.8-base                          gcc-m68hc1x
	gcc-4.6-locales                       gcc-4.8-doc                           gcc-mingw-w64
	gcc-4.6-multilib                      gcc-4.8-locales                       gcc-mingw-w64-base
	gcc-4.6-plugin-dev                    gcc-4.8-multilib                      gcc-mingw-w64-i686
	gcc-4.6-source                        gcc-4.8-multilib-arm-linux-gnueabihf  gcc-mingw-w64-x86-64
	gcc-4.7                               gcc-4.8-multilib-powerpc-linux-gnu    gcc-msp430
	gcc-4.7-arm-linux-gnueabi             gcc-4.8-plugin-dev                    gcc-multilib
	gcc-4.7-arm-linux-gnueabi-base        gcc-4.8-powerpc64le-linux-gnu         gcc-opt
	gcc-4.7-arm-linux-gnueabihf           gcc-4.8-powerpc64le-linux-gnu-base    gcc-powerpc64le-linux-gnu
	gcc-4.7-arm-linux-gnueabihf-base      gcc-4.8-powerpc-linux-gnu             gcc-powerpc-linux-gnu
	gcc-4.7-base                          gcc-4.8-powerpc-linux-gnu-base        gcc-snapshot
	gcc-4.7-base-mipsel-cross             gcc-4.8-source                        gcc-tile-linux-gnu
	gcc-4.7-doc                           gcc-4.9-base                          
	gcc-4.7-locales                       gcc-aarch64-linux-gnu                 
	alshamlan@alshamlan-OptiPlex-980:~/u-boot/u-boot$ sudo apt-get install gcc-
	
// avaliable config in buildroot
	alshamlan@alshamlan-OptiPlex-980:~/buildroot/from_git/buildroot$ make help
	Cleaning:
	  clean                  - delete all files created by build
	  distclean              - delete all non-source files (including .config)

	Build:
	  all                    - make world
	  toolchain              - build toolchain
	  <package>-rebuild      - force recompile <package>
	  <package>-reconfigure  - force reconfigure <package>
	  <package>-graph-depends    - generate graph of the dependency tree for package

	Configuration:
	  menuconfig             - interactive curses-based configurator
	  nconfig                - interactive ncurses-based configurator
	  xconfig                - interactive Qt-based configurator
	  gconfig                - interactive GTK-based configurator
	  oldconfig              - resolve any unresolved symbols in .config
	  silentoldconfig        - Same as oldconfig, but quietly, additionally update deps
	  olddefconfig           - Same as silentoldconfig but sets new symbols to their default value
	  randconfig             - New config with random answer to all options
	  defconfig              - New config with default answer to all options
		                     BR2_DEFCONFIG, if set, is used as input
	  savedefconfig          - Save current config as ./defconfig (minimal config)
	  allyesconfig           - New config where all options are accepted with yes
	  allnoconfig            - New config where all options are answered with no
	  randpackageconfig      - New config with random answer to package options
	  allyespackageconfig    - New config where pkg options are accepted with yes
	  allnopackageconfig     - New config where package options are answered with no
	  busybox-menuconfig     - Run BusyBox menuconfig
	  linux-menuconfig       - Run Linux kernel menuconfig
	  linux-savedefconfig    - Run Linux kernel savedefconfig
	  uclibc-menuconfig      - Run uClibc menuconfig

	Documentation:
	  manual                 - build manual in all formats
	  manual-html            - build manual in HTML
	  manual-split-html      - build manual in split HTML
	  manual-pdf             - build manual in PDF
	  manual-text            - build manual in text
	  manual-epub            - build manual in ePub
	  graph-build            - generate graphs of the build times
	  graph-depends          - generate graph of the dependency tree

	Miscellaneous:
	  source                 - download all sources needed for offline-build
	  source-check           - check selected packages for valid download URLs
	  external-deps          - list external packages used
	  legal-info             - generate info about license compliance

	  make V=0|1             - 0 => quiet build (default), 1 => verbose build
	  make O=dir             - Locate all output files in "dir", including .config

	Built-in configs:
	  altera_sockit_defconfig             - Build for altera_sockit
	  arm_foundationv8_defconfig          - Build for arm_foundationv8
	  armadeus_apf27_defconfig            - Build for armadeus_apf27
	  armadeus_apf28_defconfig            - Build for armadeus_apf28
	  armadeus_apf51_defconfig            - Build for armadeus_apf51
	  armadeus_apf9328_defconfig          - Build for armadeus_apf9328
	  at91rm9200df_defconfig              - Build for at91rm9200df
	  at91sam9260dfc_defconfig            - Build for at91sam9260dfc
	  at91sam9260eknf_defconfig           - Build for at91sam9260eknf
	  at91sam9261ek_defconfig             - Build for at91sam9261ek
	  at91sam9263ek_defconfig             - Build for at91sam9263ek
	  at91sam9g20dfc_defconfig            - Build for at91sam9g20dfc
	  at91sam9g45m10ek_defconfig          - Build for at91sam9g45m10ek
	  atmel_xplained_defconfig            - Build for atmel_xplained
	  atngw100_defconfig                  - Build for atngw100
	  atstk100x_defconfig                 - Build for atstk100x
	  beaglebone_defconfig                - Build for beaglebone
	  calao_qil_a9260_defconfig           - Build for calao_qil_a9260
	  calao_snowball_defconfig            - Build for calao_snowball
	  calao_tny_a9g20_lpw_defconfig       - Build for calao_tny_a9g20_lpw
	  calao_usb_a9260_defconfig           - Build for calao_usb_a9260
	  calao_usb_a9263_defconfig           - Build for calao_usb_a9263
	  calao_usb_a9g20_lpw_defconfig       - Build for calao_usb_a9g20_lpw
	  cubieboard2_defconfig               - Build for cubieboard2
	  cubieboard_defconfig                - Build for cubieboard
	  freescale_imx6sabresd_defconfig     - Build for freescale_imx6sabresd
	  freescale_imx6sololiteevk_defconfig - Build for freescale_imx6sololiteevk
	  freescale_mpc8315erdb_defconfig     - Build for freescale_mpc8315erdb
	  freescale_p1010rdb_pa_defconfig     - Build for freescale_p1010rdb_pa
	  gnublin_defconfig                   - Build for gnublin
	  integrator926_defconfig             - Build for integrator926
	  kb9202_defconfig                    - Build for kb9202
	  lego_ev3_defconfig                  - Build for lego_ev3
	  mini2440_defconfig                  - Build for mini2440
	  minnowboard_defconfig               - Build for minnowboard
	  mx53loco_defconfig                  - Build for mx53loco
	  nitrogen6x_defconfig                - Build for nitrogen6x
	  olimex_imx233_olinuxino_defconfig   - Build for olimex_imx233_olinuxino
	  openblocks_a6_defconfig             - Build for openblocks_a6
	  pandaboard_defconfig                - Build for pandaboard
	  qemu_arm_nuri_defconfig             - Build for qemu_arm_nuri
	  qemu_arm_versatile_defconfig        - Build for qemu_arm_versatile
	  qemu_arm_vexpress_defconfig         - Build for qemu_arm_vexpress
	  qemu_microblazebe_mmu_defconfig     - Build for qemu_microblazebe_mmu
	  qemu_microblazeel_mmu_defconfig     - Build for qemu_microblazeel_mmu
	  qemu_mips64_malta_defconfig         - Build for qemu_mips64_malta
	  qemu_mips64el_malta_defconfig       - Build for qemu_mips64el_malta
	  qemu_mips_malta_defconfig           - Build for qemu_mips_malta
	  qemu_mipsel_malta_defconfig         - Build for qemu_mipsel_malta
	  qemu_ppc_g3beige_defconfig          - Build for qemu_ppc_g3beige
	  qemu_ppc_mpc8544ds_defconfig        - Build for qemu_ppc_mpc8544ds
	  qemu_ppc_virtex_ml507_defconfig     - Build for qemu_ppc_virtex_ml507
	  qemu_sh4_r2d_defconfig              - Build for qemu_sh4_r2d
	  qemu_sparc_ss10_defconfig           - Build for qemu_sparc_ss10
	  qemu_x86_64_defconfig               - Build for qemu_x86_64
	  qemu_x86_defconfig                  - Build for qemu_x86
	  qemu_xtensa_lx60_defconfig          - Build for qemu_xtensa_lx60
	  qmx6_defconfig                      - Build for qmx6
	  raspberrypi_defconfig               - Build for raspberrypi
	  s6lx9_microboard_defconfig          - Build for s6lx9_microboard
	  sheevaplug_defconfig                - Build for sheevaplug
	  telit_evk_pro3_defconfig            - Build for telit_evk_pro3
	  ts5x00_defconfig                    - Build for ts5x00
	  wandboard_defconfig                 - Build for wandboard
	  zedboard_defconfig                  - Build for zedboard

	See docs/README, or generate the Buildroot manual for further details

	alshamlan@alshamlan-OptiPlex-980:~/buildroot/from_git/buildroot$ 

