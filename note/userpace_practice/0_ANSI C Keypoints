//

// C based on integer
ASCI C doesn't have a bool type, everything is reprented as int (integrer)!! Even the char types, for example 'a' is equal to 97 

// avoid nested if's because they are hard to trace and debug!!
	/* Problem*/

	int number =3;

	if (number > 2)
	{
	  if (number < 4)
	  {
	    printf ("number is three");
	  }
	}

	/* Solution */
	int number = 3;

	if ((number > 2) && (number < 4))
	{
	  printf ("number is three");
	}

Again, this is a simple example, but I think you got the point. Use whatever method necessary and remember that '&&' is not always a substitute for nested ifs, but if you need overly complicated if structures, you probably need to rethink your program's logic.

// "myptr = &myarray[0]" is equivalent to "myptr = myarray"
One important thing to know, and at the same time one that illustrates perfectly the relationship between pointers and arrays, is that the value of an array-type object is the address of its' first (zero) element, so if myptr = &myarray[0], then myptr = myarray.

// pointer for string in struct, then having a function that prints the string!!
	struct users {
		int age;
		char gender;
		char *name;
		char *address;
	};


	void show_age(struct usrs i)
	{
		printf("User's age is %d.\n", i.age);
		printf("User's name is %s.\n", (&i)->name); // note this line
	}

// about malloc
this memory allocation:
	int *ptr = (int *) malloc(sizeof (int));
equvalent to:
	int *ptr = malloc(sizeof *ptr) // you can refrence to declation when definning a value

// both are the same outcome!!
	if(!ptr) 
		die("fail!"); 
or
	if(ptr == NULL) 
		die("fail!");

// debugging macro
	#ifndef __dbg_h__
	#define __dbg_h__

	#include <stdio.h>
	#include <errno.h>
	#include <string.h>

	#ifdef NDEBUG
	#define debug(M, ...)
	#else
	#define debug(M, ...) fprintf(stderr, "DEBUG %s:%d: " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)
	#endif

	#define clean_errno() (errno == 0 ? "None" : strerror(errno))

	#define log_err(M, ...) fprintf(stderr, "[ERROR] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

	#define log_warn(M, ...) fprintf(stderr, "[WARN] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

	#define log_info(M, ...) fprintf(stderr, "[INFO] (%s:%d) " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)

	#define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

	#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

	#define check_mem(A) check((A), "Out of memory.")

	#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__); errno=0; goto error; }

	#endif

// Note, for C program uses more than one file, try to use this method for portion of code is important and it must be used in the beginning of any code files. But, you when you want to compile all the source code, you don't want it to repeat in every file because every file has this portion of code. Therefore, you can attack this problem in the preprocessor layer as shown below!!
 	#ifndef __dbg_h__
	#define __dbg_h__
	...
	#endif


// about logic, 0 and 1
/*
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ cat -n q6.c 
	     1	#include<stdio.h>
	     2	
	     3	int main (int argc, char *argv[]) {
	     4	printf("2 > 1:%d\n \b2 < 1: %d\n", 2>1, 2<1);
	     5	return 0;
	     6	}
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make -B q6
	cc -g -O -Wall    q6.c   -o q6
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q6
	2 > 1:1
	2 < 1: 0
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 
*/
Note[1]: while(1) is an infinate loop, but also x=0; while(!x) is an infinate loop

// using float-point in for-loop, and doing number rounds up
	#include<stdio.h>

	int roundup (float *num)
	{
		return (*num - (int) *num) >= 0.5 ? (int) (*num +1) : (int) *num; // note: it works just with positive number!!
	}

	int main(int argc, char *argv[]){
	float i=0;
	for (i=0.1; i < 5; i+= 0.28)
		printf("%.3f rounds up onto %d\n", i, roundup(&i)); // function isn't needed, but it improves the code readability 
	return 0;
	}


/*
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ nano -i -c q7.c 
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make q7
	cc -g -O -Wall    q7.c   -o q7
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q7 
	0.100 rounds up onto 0
	0.380 rounds up onto 0
	0.660 rounds up onto 1
	0.940 rounds up onto 1
	1.220 rounds up onto 1
	1.500 rounds up onto 1
	1.780 rounds up onto 2
	2.060 rounds up onto 2
	2.340 rounds up onto 2
	2.620 rounds up onto 3
	2.900 rounds up onto 3
	3.180 rounds up onto 3
	3.460 rounds up onto 3
	3.740 rounds up onto 4
	4.020 rounds up onto 4
	4.300 rounds up onto 4
	4.580 rounds up onto 5
	4.860 rounds up onto 5
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 
*/



// user inputs a charachter, and that characher outputs onto the screen immediatley
	/*
	 * Prints out its output
	 */

	#include<stdio.h>

	char io ()
	{
		char c;
		c = getchar();
		putchar(c);
		return c;
	}

	int main (int argc, char *argv[]){
	// I used a function because I didn't want to use two getchar as shown below code
	while (io() != EOF) ; // to have EOF (End Of File), click ctrl + D 
	return 0;
	}

	/*
	// I don't like this code
	int main(){
	char c= getchar();
	while (c != EOF){
		putchar(c);
		c = getchar();
	}
	return 0;
	}
	*/

// note: I found a way even to improve it better
	#include<stdio.h>

	int main (int argc, char *argv[]){
	char c;
	while ( (c = getchar()) != EOF) // you can define a value and use logic operation in the same line
		putchar(c); // to have EOF (End Of File), click ctrl + D 
	return 0;
	}

// using getchar() and putchar(c) where c is int of char doesn't make a different!!!
// case 1: char c
	#include<stdio.h>
	int main()
	{
		char c; // using chat type
		while ((c = getchar()) != EOF) 
			putchar(c);
		return 0;
	}

// case 2: int c
	#include<stdio.h>
	int main()
	{
		int c; // using int type
		while ((c = getchar()) != EOF) 
			putchar(c);
		return 0;
	}
// Note[1]: both types give the same result here!! I'm aware of charticters in C are ASCII numbers, but I haven't imagen that the compiler wouldn't have an issue with it!!


// about compiler priority
case 1:
if you have this code:
	if (c = getchar() != EOF) 
!= has higher priority than =, so the above synatx equivalent to
	if (c = (getchar() != EOF)) // that not what we want, what we want is: ((c = getchar()) != EOF)

case 2:
let have the following:
	int nc, nw, nl, cc;
	nc = nw = nl = cc = 0;
that is equvialent to
	int nc, nw, nl, cc;
	nc = (nw = (nl = (cc = 0)));
	
// about the different between printf("%f", 5/9) and printf("%f", 5.0/9)
for 5/9 case:
/*
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ cat q1.c
#include<stdio.h>
int main ()
{
	printf("%f\n", 5/9);
}
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make -B q1
cc     q1.c   -o q1
q1.c: In function ‘main’:
q1.c:4:2: warning: format ‘%f’ expects argument of type ‘double’, but argument 2 has type ‘int’ [-Wformat]
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q1
0.000000
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$
*/
for 5.0/9 case:
/*
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ cat q2.c
#include<stdio.h>
int main ()
{
	printf("%f\n", 5.0/9);
}
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make q2
cc     q2.c   -o q2
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2
0.555556
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 
*/

