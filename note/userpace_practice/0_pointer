//

//------------------------------
//source: http://www.youtube.com/watch?v=7-EppTJK7WQ
//	and trial and error from gcc
//------------------------------

// Note[0]: about pointer
let us have this code:
	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;

	printf("Name\tAddress\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %u is used for address because it's unsigned integer
	printf("b\t%u\t%d\n", &b, b);
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &c, *c);

	printf("\n");
	return 0;
	}

// output
/*
	Name	Address	contant
	a	1368581880	1
	b	1368581884	2
	c	1368581872	1368582112
	*c	1368581872	1

*/

What's clear from the output is:
	[1] C has the address of what's *c pointing to, and because we haven't pointed anything yet, the pointing address is off
	[2] c and *c have different values!!

Now, the questions that I need to answer is:
	[1] a and b aren't defined as pointe, but what happen if I used *a without any pointer declaration of a!!
	[2] point to one of the values, and see the output

for Q2: it didn't work!! the code:

	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;


	printf("Name\tAddress\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %u is used for address because it's unsigned integer
	printf("a\t%u\t%d\n", &a, *a);	// %u is used for address because it's unsigned integer
	printf("b\t%u\t%d\n", &b, b);
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &c, *c);

	printf("\n");
	return 0;
	}

gcc error:
/*
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2
q2.c: In function ‘main’:
q2.c:10:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:11:27: error: invalid type argument of unary ‘*’ (have ‘int’)
q2.c:12:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:13:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
q2.c:13:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat]
q2.c:14:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
*/

so for the q1:
	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;

	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %u is used for address because it's unsigned integer
	printf("b\t%u\t%d\n", &b, b);
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &c, *c);

	printf("\n");
	return 0;
	}

// output is:
/*
	Name	Address		contant
	a	829079272	10
	b	829079276	2
	c	829079264	829079272
	*c	829079264	10
*/

Note:
	[1] there is a way to make *c identical to a from the output by using "&*c". Code:

	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;

	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\t\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %u is used for address because it's unsigned integer
	printf("b\t%u\t%d\n", &b, b);
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &*c, *c);

	printf("\n");
	return 0;
	}

// output result of the above code:
Name	Address		contant
a	791135496	10
b	791135500	2
c	791135488	791135496
*c	791135496	10


Still, I have more questions:
	[1] how does two pointers work **d for example
	[2] how two remove all the woaring from gcc
Q2, for this code:

	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;

	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\t\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %u is used for address because it's unsigned integer
	printf("b\t%u\t%d\n", &b, b);
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &*c, *c);

	printf("\n");
	return 0;
	}

//these is gcc output:
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2
q2.c: In function ‘main’:
q2.c:12:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:13:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:14:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
q2.c:14:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat]
q2.c:15:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]

// so fixing some of the warnings by this code:

	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;

	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\t\tcontant\n");
	printf("a\t%n\t%d\n", &a, a);	// %n is used for address because it's int *
	printf("b\t%n\t%d\n", &b, b);
	printf("c\t%n\t%n\n", &c, c);
	printf("*c\t%n\t%d\n", &*c, *c);

	printf("\n");
	return 0;
	}

// gcc warning:
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2
q2.c: In function ‘main’:
q2.c:14:1: warning: format ‘%n’ expects argument of type ‘int *’, but argument 2 has type ‘int **’ [-Wformat]

// there is a double pointer, so due to lack of understand, and also I'm looking into manpage from this command
	$ man 3 printf
// I couldn't find int ** arugemtnt in printf, so I can casting it in (int *) as shown below code:

	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;

	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\t\tcontant\n");
	printf("a\t%n\t%d\n", &a, a);	// %n is used for address because it's int *
	printf("b\t%n\t%d\n", &b, b);
	printf("c\t%n\t%n\n", (int *) &c, c);
	printf("*c\t%n\t%d\n", &*c, *c);

	printf("\n");
	return 0;
	}
// now, gcc doesn't have any errors!!

However, gcc doesn't have any warning, but the code breaks!! Simply put, it doesn't run all of it, breaks!!

// result
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
Name	Address		contant
a		10
b		2
c		
Segmentation fault (core dumped)
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 

// see the core dumped the exuatable binary without even continue to the end!!

so back to the warning, is better because it works

// Q2: using double pointer: int **d, and looking to all its info

// I faced some problems with double pointer, so let me show what works from now:


	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;
	int **d;
	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\t\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %n is used for address because it's int *
	printf("b\t%u\t%d\n", &b, b);	// %u is used for address because it's unsigned integer
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &*c, *c);

	printf("d\t%u\t%d\n", &d, d);
	printf("*d\t%u\t%d\n", &*d, *d);
	//printf("**d\t%d\t%d\n", &**d, **d);

	printf("\n");
	return 0;
	}

//gcc warnings:
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2
q2.c: In function ‘main’:
q2.c:13:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:14:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:15:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat]
q2.c:16:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:18:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int ***’ [-Wformat]
q2.c:18:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int **’ [-Wformat]
q2.c:19:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
q2.c:19:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat]


// the output results
/*
Name	Address		contant
a	72535448	10
b	72535452	2
c	72535432	72535448
*c	72535448	10
d	72535440	72535680
*d	72535680	1

*/ 

// still I'm facing problems after fixing the code:

	#include<stdio.h>
	#include<string.h>

	int main (){

	int a=1, b=2, *c;
	int **d;
	c = &a; 
	*c = 10; // changing a value through the pointer

	printf("Name\tAddress\t\tcontant\n");
	printf("a\t%u\t%d\n", &a, a);	// %n is used for address because it's int *
	printf("b\t%u\t%d\n", &b, b);	// %u is used for address because it's unsigned integer
	printf("c\t%u\t%d\n", &c, c);
	printf("*c\t%u\t%d\n", &*c, *c);

	printf("d\t%u\t%d\n", &d, d);
	printf("*d\t%u\t%d\n", &*d, *d);
	printf("**d\t%d\n", &**d);
	printf("**d\t%d\n", **d);
	//printf("**d\t%d\t%d\n", &**d, **d);

	printf("\n");
	return 0;
	}

// gcc warning:
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2
q2.c: In function ‘main’:
q2.c:13:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:14:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:15:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat]
q2.c:16:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int *’ [-Wformat]
q2.c:18:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int ***’ [-Wformat]
q2.c:18:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int **’ [-Wformat]
q2.c:19:1: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘int **’ [-Wformat]
q2.c:19:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 3 has type ‘int *’ [-Wformat]
q2.c:20:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘int *’ [-Wformat]


// output results
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
Name	Address		contant
a	1684120488	10
b	1684120492	2
c	1684120472	1684120488
*c	1684120488	10
d	1684120480	1684120720
*d	1684120720	1
**d	1
Segmentation fault (core dumped)

// so the observation is printf("**d\t%d\n", **d) breaks the result, so maybe casting to unsigned int my fix it

// moving to gnu gdb, so analyze more!! use flage -g to debug
	$ gcc q2.c -o q2 -g

from gdb, after running "run" command
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gdb q2
	GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
	Copyright (C) 2012 Free Software Foundation, Inc.
	License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
	and "show warranty" for details.
	This GDB was configured as "x86_64-linux-gnu".
	For bug reporting instructions, please see:
	<http://bugs.launchpad.net/gdb-linaro/>...
	Reading symbols from /tmp/interview/q2...done.
	(gdb) run
	Starting program: /tmp/interview/q2 
	Name	Address		contant
	a	4294959384	10
	b	4294959388	2
	c	4294959368	-7912
	*c	4294959384	10
	d	4294959376	-7680
	*d	4294959616	1

	Program received signal SIGSEGV, Segmentation fault.
	0x000000000040066e in main () at q2.c:21
	21	printf("**d\t%d\n", (unsigned int) **d);
	(gdb) 

//--------------------------------
//	topic: array represtnted as pointer
//	source: http://www.youtube.com/watch?v=7mOJN1c1JEo&list=PLhQjrBD2T380dhmG9KMjsOQogweyjEeVQ
//---------------------------------

// version 1 (bracket-type array)
	int x[N];
// version 2 (pointer-type array)
	int *x = malloc(sizeof(int)* N);

// the difference between V1 and V2 is: V1 goes to the stack, and v2 goes to the heap. 

// stack vs heap: stack will atomatically de-allocated, but heap the user de-allocate the memory by free() function. 

// the difference between V1 and V2 is: v1 isn't a variable, so you can do x[]++. On the other hand, v2 is a variable, so you can do x++

//----------------------------------------
//	topic: **str vs *str[]
//	source: gcc with trial and error appeoach
//----------------------------------------

// studying a way to count the element of *str[]
	#include<stdio.h>

	int main ( int argc, char * argv[]){

	char *str[]={ "1234!", "5678", "9ABC","DE"};
	printf("char *str[]={ \"1234!\", \"5678\", \"9ABC\", \"DE\"};\n");
	printf("strlen(str)=%d\n", strlen(str));
	printf("strlen(str[0])=%d\n", strlen(str[0]));
	printf("strlen(str[1])=%d\n", strlen(str[1]));
	printf("strlen(str[2])=%d\n", strlen(str[2]));
	printf("strlen(str[3])=%d\n", strlen(str[3]));
	printf("strlen(*str)=%d\n", strlen(*str));
	printf("sizeof(str)=%d\n", sizeof(str));
	printf("sizeof(str[0])=%d\n", sizeof(str[0]));
	printf("sizeof(str[1])=%d\n", sizeof(str[1]));
	printf("sizeof(str[2])=%d\n", sizeof(str[2]));
	printf("sizeof(*str)=%d\n", sizeof(*str));
	printf("sizeof(*str[0])=%d\n", sizeof(*str[0]));
	printf("sizeof(str)/sizeof(str[0])=%d\n", sizeof(str)/sizeof(str[0]));

	printf("\n");
	return 0;
	}// end on main
// gcc warnings
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2 
q2.c: In function ‘main’:
q2.c:7:28: warning: incompatible implicit declaration of built-in function ‘strlen’ [enabled by default]
q2.c:7:1: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [enabled by default]
q2.c:7:1: note: expected ‘const char *’ but argument is of type ‘char **’
q2.c:7:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:8:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:9:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:10:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:11:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:12:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:13:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:14:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:16:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:17:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:18:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:19:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 

// using valgrind
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ valgrind ./q2
==22745== Memcheck, a memory error detector
==22745== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==22745== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==22745== Command: ./q2
==22745== 
char *str[]={ "1234!", "5678", "9ABC", "DE"};
strlen(str)=3
strlen(str[0])=5
strlen(str[1])=4
strlen(str[2])=4
strlen(str[3])=2
strlen(*str)=5
sizeof(str)=32
sizeof(str[0])=8
sizeof(str[1])=8
sizeof(str[2])=8
sizeof(*str)=8
sizeof(*str[0])=1
sizeof(str)/sizeof(str[0])=4

==22745== 
==22745== HEAP SUMMARY:
==22745==     in use at exit: 0 bytes in 0 blocks
==22745==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==22745== 
==22745== All heap blocks were freed -- no leaks are possible
==22745== 
==22745== For counts of detected and suppressed errors, rerun with: -v
==22745== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 
// result output
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
	char *str[]={ "1234!", "5678", "9ABC", "DE"};
	strlen(str)=3
	strlen(str[0])=5
	strlen(str[1])=4
	strlen(str[2])=4
	strlen(str[3])=2
	strlen(*str)=5
	sizeof(str)=32
	sizeof(str[0])=8
	sizeof(str[1])=8
	sizeof(str[2])=8
	sizeof(*str)=8
	sizeof(*str[0])=1
	sizeof(str)/sizeof(str[0])=4

// as we can see strlen works for specific element such as str[0] that gives the number of chrachters in it without counting null which is \0

// also, sizeof(str)/sizeof(str[0]) gives the numbers of pointer of arrays. However, one attempt doesn't mean that every thing hold, so let change the code to make sure!!

// code version 2
	#include<stdio.h>

	int main ( int argc, char * argv[]){

	char *str[]={ "12", "345678", "9A","BCD", "E"};
	printf("char *str[]={ \"12\", \"345678\", \"9A\",\"BCD\", \"E\"};\n");
	printf("strlen(str)=%d\n", strlen(str));
	printf("strlen(str[0])=%d\n", strlen(str[0]));
	printf("strlen(str[1])=%d\n", strlen(str[1]));
	printf("strlen(str[2])=%d\n", strlen(str[2]));
	printf("strlen(str[3])=%d\n", strlen(str[3]));
	printf("strlen(str[4])=%d\n", strlen(str[4]));
	printf("strlen(*str)=%d\n", strlen(*str));
	printf("sizeof(str)=%d\n", sizeof(str));
	printf("sizeof(str[0])=%d\n", sizeof(str[0]));
	printf("sizeof(str[1])=%d\n", sizeof(str[1]));
	printf("sizeof(str[2])=%d\n", sizeof(str[2]));
	printf("sizeof(str[3])=%d\n", sizeof(str[3]));
	printf("sizeof(str[4])=%d\n", sizeof(str[4]));
	printf("sizeof(*str)=%d\n", sizeof(*str));
	printf("sizeof(*str[0])=%d\n", sizeof(*str[0]));
	printf("sizeof(str)/sizeof(str[0])=%d\n", sizeof(str)/sizeof(str[0]));


	printf("\n");
	return 0;
	}// end on main
// gcc warnings 
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2 
q2.c: In function ‘main’:
q2.c:7:28: warning: incompatible implicit declaration of built-in function ‘strlen’ [enabled by default]
q2.c:7:1: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [enabled by default]
q2.c:7:1: note: expected ‘const char *’ but argument is of type ‘char **’
q2.c:7:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:8:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:9:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:10:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:11:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:12:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:13:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:14:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:16:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:17:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:18:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:19:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:20:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:21:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:22:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 

// result output
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
char *str[]={ "12", "345678", "9A","BCD", "E"};
strlen(str)=3
strlen(str[0])=2
strlen(str[1])=6
strlen(str[2])=2
strlen(str[3])=3
strlen(str[4])=1
strlen(*str)=2
sizeof(str)=40
sizeof(str[0])=8
sizeof(str[1])=8
sizeof(str[2])=8
sizeof(str[3])=8
sizeof(str[4])=8
sizeof(*str)=8
sizeof(*str[0])=1
sizeof(str)/sizeof(str[0])=5

// it seems, the theory still holds!! 
// the theory:
[1] to have the number of pointer arrays such as char *str[]={"A","BC"}. Use sizeof(str)/sizeof(str[0]) which gives 2 becuase there just to elements in the pointer of arrays which are: A, and (B and C).
[2] to know the numbre of charchters in specific array such as *str[]={"A","BC"}. So, for the second element which are "BC", do the following strlen(str[1]) which gives 2 because str[1][0]='B', str[1][1]='C', and str[1][2]='\0' which is NULL that lets strlen function to stop counting the numbers of charchters!!

// let put the above conclusion under test!!

	#include<stdio.h>

	int main ( int argc, char * argv[]){

	char *str[]={ "A", "BC"};
	printf("char *str[]={ \"A\", \"BC\"};\n");
	printf("strlen(str)=%d\n", strlen(str));
	printf("strlen(str[0])=%d\n", strlen(str[0]));
	printf("strlen(str[1])=%d\n", strlen(str[1]));
	printf("strlen(*str)=%d\n", strlen(*str));
	printf("sizeof(str)=%d\n", sizeof(str));
	printf("sizeof(str[0])=%d\n", sizeof(str[0]));
	printf("sizeof(str[1])=%d\n", sizeof(str[1]));
	printf("sizeof(*str)=%d\n", sizeof(*str));
	printf("sizeof(*str[0])=%d\n", sizeof(*str[0]));
	printf("sizeof(str)/sizeof(str[0])=%d\n", sizeof(str)/sizeof(str[0]));
	printf("string:\t \bstr[0]=%s\n", str[0]);
	printf("string:\t \bstr[1]=%s\n", str[1]);
	printf("char:\t \bstr[0][0]=%c\n", str[0][0]);
	printf("char:\t \bstr[0][1]=%c\n", str[0][1]);
	printf("char:\t \bstr[1][0]=%c\n", str[1][0]);
	printf("char:\t \bstr[1][1]=%c\n", str[1][1]);
	printf("char:\t \bstr[1][2]=%c\n", str[1][2]);

	printf("\n");
	return 0;
	}// end on main

// gcc warnings and output result:
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2 
q2.c: In function ‘main’:
q2.c:7:28: warning: incompatible implicit declaration of built-in function ‘strlen’ [enabled by default]
q2.c:7:1: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [enabled by default]
q2.c:7:1: note: expected ‘const char *’ but argument is of type ‘char **’
q2.c:7:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:8:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:9:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:10:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:11:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:12:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:13:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:14:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:16:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
	char *str[]={ "A", "BC"};
	strlen(str)=0
	strlen(str[0])=1
	strlen(str[1])=2
	strlen(*str)=1
	sizeof(str)=16
	sizeof(str[0])=8
	sizeof(str[1])=8
	sizeof(*str)=8
	sizeof(*str[0])=1
	sizeof(str)/sizeof(str[0])=2
	string:	str[0]=A
	string:	str[1]=BC
	char:	str[0][0]=A
	char:	str[0][1]=
	char:	str[1][0]=B
	char:	str[1][1]=C
	char:	str[1][2]=

	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gedit q2.c
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 

// Now the question, instead of char *str[], if I used char **str what difference the code would have!!
	#include<stdio.h>

	int main ( int argc, char * argv[]){

	char **str={ "A", "BC"};
	printf("char **str={ \"A\", \"BC\"};\n");
	printf("strlen(str)=%d\n", strlen(str));
	printf("strlen(str[0])=%d\n", strlen(str[0]));
	printf("strlen(str[1])=%d\n", strlen(str[1]));
	printf("strlen(*str)=%d\n", strlen(*str));
	printf("sizeof(str)=%d\n", sizeof(str));
	printf("sizeof(str[0])=%d\n", sizeof(str[0]));
	printf("sizeof(str[1])=%d\n", sizeof(str[1]));
	printf("sizeof(*str)=%d\n", sizeof(*str));
	printf("sizeof(*str[0])=%d\n", sizeof(*str[0]));
	printf("sizeof(str)/sizeof(str[0])=%d\n", sizeof(str)/sizeof(str[0]));
	printf("string:\t \bstr[0]=%s\n", str[0]);
	printf("string:\t \bstr[1]=%s\n", str[1]);
	printf("char:\t \bstr[0][0]=%c\n", str[0][0]);
	printf("char:\t \bstr[0][1]=%c\n", str[0][1]);
	printf("char:\t \bstr[1][0]=%c\n", str[1][0]);
	printf("char:\t \bstr[1][1]=%c\n", str[1][1]);
	printf("char:\t \bstr[1][2]=%c\n", str[1][2]);

	printf("\n");
	return 0;
	}// end on main 
// gcc warnings
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2 
q2.c: In function ‘main’:
q2.c:5:1: warning: initialization from incompatible pointer type [enabled by default]
q2.c:5:1: warning: (near initialization for ‘str’) [enabled by default]
q2.c:5:1: warning: excess elements in scalar initializer [enabled by default]
q2.c:5:1: warning: (near initialization for ‘str’) [enabled by default]
q2.c:7:28: warning: incompatible implicit declaration of built-in function ‘strlen’ [enabled by default]
q2.c:7:1: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [enabled by default]
q2.c:7:1: note: expected ‘const char *’ but argument is of type ‘char **’
q2.c:7:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:8:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:9:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:10:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:11:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:12:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:13:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:14:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:16:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]

// output result
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
	char **str={ "A", "BC"};
	strlen(str)=1
	Segmentation fault (core dumped)

// it is clear that char *str[] isn't the same as **str becuase if there are the same, then "Segmentation fault (core dumped)" wouldn't happen!!

// However, I will commets the lines that create the "Segmentation fault (core dumped)" so this the code now which is compatable with char **str
	#include<stdio.h>

	int main ( int argc, char * argv[]){

	char **str={ "A", "BC"};
	printf("char **str={ \"A\", \"BC\"};\n");
	printf("strlen(str)=%d\n", strlen(str));
	//printf("strlen(str[0])=%d\n", strlen(str[0]));
	//printf("strlen(str[1])=%d\n", strlen(str[1]));
	//printf("strlen(*str)=%d\n", strlen(*str));
	printf("sizeof(str)=%d\n", sizeof(str));
	printf("sizeof(str[0])=%d\n", sizeof(str[0]));
	printf("sizeof(str[1])=%d\n", sizeof(str[1]));
	printf("sizeof(*str)=%d\n", sizeof(*str));
	printf("sizeof(*str[0])=%d\n", sizeof(*str[0]));
	printf("sizeof(str)/sizeof(str[0])=%d\n", sizeof(str)/sizeof(str[0]));
	//printf("string:\t \bstr[0]=%s\n", str[0]);
	//printf("string:\t \bstr[1]=%s\n", str[1]);
	//printf("char:\t \bstr[0][0]=%c\n", str[0][0]);
	//printf("char:\t \bstr[0][1]=%c\n", str[0][1]);
	//printf("char:\t \bstr[1][0]=%c\n", str[1][0]);
	//printf("char:\t \bstr[1][1]=%c\n", str[1][1]);
	//printf("char:\t \bstr[1][2]=%c\n", str[1][2]);

	printf("\n");
	return 0;
	}// end on main

// gcc warnings
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ gcc  q2.c -o q2 
q2.c: In function ‘main’:
q2.c:5:1: warning: initialization from incompatible pointer type [enabled by default]
q2.c:5:1: warning: (near initialization for ‘str’) [enabled by default]
q2.c:5:1: warning: excess elements in scalar initializer [enabled by default]
q2.c:5:1: warning: (near initialization for ‘str’) [enabled by default]
q2.c:7:28: warning: incompatible implicit declaration of built-in function ‘strlen’ [enabled by default]
q2.c:7:1: warning: passing argument 1 of ‘strlen’ from incompatible pointer type [enabled by default]
q2.c:7:1: note: expected ‘const char *’ but argument is of type ‘char **’
q2.c:7:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:11:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:12:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:13:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:14:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:15:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
q2.c:16:1: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat]
alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 

// result output
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
	char **str={ "A", "BC"};
	strlen(str)=1
	sizeof(str)=8
	sizeof(str[0])=8
	sizeof(str[1])=8
	sizeof(*str)=8
	sizeof(*str[0])=1
	sizeof(str)/sizeof(str[0])=1

	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ 

// I don't undertand why this is happing, so I need to look further about, I think a good way to start to look back to the debate of char **argv vs char *argv[]

// it seems when you use pointer of pointers there aren't any automatic NULL added by defults
	#include<stdio.h>

	int main ( int argc, char * argv[]){

	char **str={ "A\0", "BC\0"};
	printf("char **str={ \"A\0\", \"BC\0\"};\n");
	printf("strlen(str)=%d\n", strlen(str));
	//printf("strlen(str[0])=%d\n", strlen(str[0]));
	//printf("strlen(str[1])=%d\n", strlen(str[1]));
	//printf("strlen(*str)=%d\n", strlen(*str));
	printf("sizeof(str)=%d\n", sizeof(str));
	printf("sizeof(str[0])=%d\n", sizeof(str[0]));
	printf("sizeof(str[1])=%d\n", sizeof(str[1]));
	printf("sizeof(*str)=%d\n", sizeof(*str));
	printf("sizeof(*str[0])=%d\n", sizeof(*str[0]));
	printf("sizeof(str)/sizeof(str[0])=%d\n", sizeof(str)/sizeof(str[0]));
	//printf("string:\t \bstr[0]=%s\n", str[0]);
	//printf("string:\t \bstr[1]=%s\n", str[1]);
	//printf("char:\t \bstr[0][0]=%c\n", str[0][0]);
	//printf("char:\t \bstr[0][1]=%c\n", str[0][1]);
	//printf("char:\t \bstr[1][0]=%c\n", str[1][0]);
	//printf("char:\t \bstr[1][1]=%c\n", str[1][1]);
	//printf("char:\t \bstr[1][2]=%c\n", str[1][2]);

	printf("\n");
	return 0;
	}// end on main

// it still doesn't work!! I really don't get why it doesn't work!!

// ---------------------------------
//	topic: undersanding pointer to pointer better
//	source: http://www.thegeekstuff.com/2012/01/advanced-c-pointers/
//----------------------------------

As the definition of pointer says that its a special variable that can store the address of an other variable. Then the other variable can very well be a pointer. This means that its perfectly legal for a pointer to be pointing to another pointer.

Lets suppose we have a pointer ‘p1′ that points to yet another pointer ‘p2′ that points to a character ‘ch’. In memory, the three variables can be visualized as :

		P1	==>	P1	==>	Var1
content		5000		8000		'c'
address		1001		5000		8000	

So we can see that in memory, pointer p1 holds the address of pointer p2. Pointer p2 holds the address of character ‘ch’.

So ‘p2′ is pointer to character ‘ch’, while ‘p1′ is pointer to ‘p2′ or we can also say that ‘p2′ is a pointer to pointer to character ‘ch’.

Now, in code ‘p2′ can be declared as :
	char *p2 = &ch;
But ‘p1′ is declared as :
	char **p1 = &p2;
So we see that ‘p1′ is a double pointer (ie pointer to a pointer to a character) and hence the two *s in declaration.

//Now, that gives
	p1′ is the address of ‘p2′ ie 5000
	*p1′ is the value held by ‘p2′ ie 8000
	**p1′ is the value at 8000 ie ‘c’

// example:
	#include<stdio.h> 

	int main(void)
	{
	    char **ptr = NULL; 

	    char *p = NULL; 

	    char c = 'd'; 

	    p = &c;
	    ptr = &p; 

	    printf("\n c = [%c]\n",c);
	    printf("\n *p = [%c]\n",*p);
	    printf("\n **ptr = [%c]\n",**ptr); 

	    return 0;
	}
// Here is the output :
	$ ./doubleptr 

	 c = [d] 

	 *p = [d] 

	 **ptr = [d]


