// 

//---------------------------------
//	C development on Linux - Introduction - I.
//	source(s):
//		[1]	http://how-to.linuxcareer.com/c-development-on-linux-introduction
//		[2]	
//---------------------------------

// Functions
A simple function declaration in C would be like this:

	int sum (int a, int b)
	{
		return a + b;
	}

This would be a function named sum that returns an integer from calculating the sum of its' arguments, a and b, also integers. Note the blocks that make a clear delimitation as to where the function's body starts and when it ends.

You can, as in C, first declare a function, then define it, or declare it and define it in one shot, like we did above. You have to use the sub keyword in order to tell the Perl interpreter what you want to do. In Python our sum example would look like this:

	def sum ( a, b ):
	  return a + b

// Pointers and arrays
A pointer is a variable that holds the memory location of another variable. As in C, pointers and arrays are tied together pretty tight and offer many advanced features to the C++ programmer. Again, there is no important difference between the two. Perl has references that offer the same functionality. For example, this piece of code defines a variable named var and a reference to it named refvar:

	$var = 20;
	$refvar = \$var;

In C, we would have done something like
	int var;
	var = 20;
	int *refvar;
	refvar = &var;

Perl, like Python, doesn't allow the programmer to do direct memory manipulation. Some see this as a good thing, others not. Python offers ctypes, which is a library that offers the pointer() function for using pointers. The short story is: Python doesn't use pointers. The long story is that Python's way to reference variables, that is by-value only, is different to a programmer used to C.

If you used arrays on C++ or Perl, the concept is mostly the same. Perl has a different syntax, but if you already know what an array is, you'll be alright in C. Python offers the array module that offers this functionality, because it already has lists as a basic type, except arrays are more restrictive.

//Structures
In C, a struct is a record that contains a fixed, labelled set of objects, all wrapped into one. For example:
	struct customer {
	   int account;
	   char *name;
	   float balance;
	};

Quoting Wikipedia, "In C++, a structure is a class defined with the struct keyword. Its members and base classes are public by default. A class defined with the class keyword has private members and base classes by default. This is the only difference between structs and classes in C++.". In Perl until version 5, structs were a problem (or lack thereof), but now there is perldsc (Perl Data Structures Cookbook), available at perldoc.org. In Python you can always (well, almost) use tuples or dictionaries for this.

// Including files
As you have seen in the first part, in C one uses preprocessor directives to include definitions from other files. This functionality is offered also by C++, with the same syntax, except header files are named $name.hpp and that you don't need the file extension:

	#include <iostream>

iostream is the C++ equivalent of stdio.h. In Perl, we have the use keyword for this, and can be used like this:

	use Module;

In Python, the equivalent of use is import, used in exactly the same way as in Perl, except it doesn't require a semicolon at the end.

// Types in C

	char c;
	unsigned char uc;
	short s;
	unsigned short us;
	int i;
	unsigned u;
	long l;
	unsigned long ul;
	float f;
	double d;
	long double ld;
	const int ci;

Before we go on, it must be said that char, int, float and double are the primary data types in C. Unsigned and signed are modifiers, meaning that if you need to work with values smaller than zero, you should tell the compiler that your variable is signed, as in it can be larger or smaller than zero. long and short (these are applicable to integers usually) allow you to store bigger values, or smaller, and the number of bytes is machine-dependent, but a short must be always smaller than an int, which in turn must be always smaller than a long. As you can see, in practice one does not use long int or short int, just long or short. The const keyword tells the compiler that once a variable has a value, it cannot be changed.

Let's start with the smallest type, char. It is guaranteed to be large enough to hold one byte's worth, and it's always fixed size. If people will tell you that a byte is always eight bits, better think again. Every popular hardware architecture indeed uses eight-bit bytes, but there are exceptions, so don't make assumptions if you want to write portable code.

On x86, since a byte is eight bits, a char (unsigned) can hold values from 0 to 255, that is 2(^8). If a char is signed, then it can hold values from -128 to 127. But the name may mislead you: a character can indeed be stored in a char, but if you're using Unicode, we're talking multibyte there and you'll have to use wchar_t, but more on that later.

Now that you know what type modifiers are, we can get to integers. On integers, you can combine the sign and length modifiers, as seen in the example above, to fit your needs. Remember to have an editor handy and check with the limits.h header (on my system it's to be found in /usr/include) to find out the actual limits on your system. As a short rule, an int will hold values from 0 to 65535 or, if signed, from -32768 to 32767. And a long modifier will double the number of storage bytes, so if an int requires 2 bytes, a long will require 4. We'll leave it up to the user to figure out the rest of the integers and their minimal and maximal values. We will however, show you how to find out sizes and limits on your system.

// floating-point values
floats are floating-point values, which implies that you must define a variable like this:
	float value;
	value = 234.00;

even if it doesn't have nothing after the dot (the decimal part), so it's an integer actually. There are actually situations where you must declare an integer value as a float, because the value might change and the declared type must be able to store floating point values. All the values on your machine can be found in float.h.

// Variables

	char c = 'a';
	int i = 234;
	float f = 12643.984;
	long double ld = 16546581654161598309.87;

// code that tells what the sizes of types!!
As promised, since all talk and no play ain't good, we'll show you a little program you can use to see the minimal and maximal values of various types, but we'll just illustrate a few. The rest will be your job to do, following our example, with an editor having limits.h and float.h open. There will be some new elements here, but never worry, they will be explained.

	#include <stdio.h>
	#include <float.h>
	#include <limits.h>

	int main()
	{
	  unsigned long long ullmax = ULLONG_MAX;
	  long lmax = LONG_MAX;
	  long double ldmax = LDBL_MAX;
	  
	  printf("The max value of an unsigned long long is %Lu.\n", ullmax);
	  printf("The max value of a long is %ld.\n", lmax);
	  printf("The max value of a long double is %Lf.\n", ldmax);
	  
	  return 0;
	}
So, we declare three variables with meaningful names and assign them the values of three macros defined in limits.h and float.h.

In the first example '%Lu' means long long (the L), which is unsigned (the 'u'). For integers, the format string is 'd', for decimal, and because it's a long integer, it will be'%ld'. In the third printf, f stands for float, a double is basically a long float, and a long double is a long long float, hence the format.

// Operators
	[i]	Arithmetic operators
	[ii]	Relational operators
	[iii]	Casting
	[iv]	Increment and decrement operators
	[v]	Bitwise operators
	[vi]	Logical operators

// [i] Arithmetic operators
This subchapter, of course, deals with the usual basic operators you learned in primary school. But there's a little more. Foe example,. the +, -, *, / and % operators are the binary operators. % is the modulo operator, meaning that if we have 50 % 2, the result will be 0 because the result of the division 50 / 2 has an integer as a result. You can use the first four operators with any numeric value, but modulo deals only with integers. Precedence is the same as in the arithmetics book.

// [ii] Relational operators
These operators are >, >=, <=, <, and they all have the same precedence. For the next part we recommend extra care, because it's cause for much confusion in the beginner's league, and non-beginners alike. Like said above, one uses '=' to give some value to a variable. But if you want to check if a variable has a certain value, you use '==', and if it hasn't, use '!=', where '!' is the logical negation operator, as you'll see. Let's take the following (useless) example:

	#include <stdio.h>

	int main()
	{
	  int var = 4;
	  
	  if (var == 4)
	    printf("var is 4!\n");
	  else
	    printf("There's something amiss.\n");
	  
	  return 0;
	}
// [iii] Casting
In a nutshell, casting is forcing the compiler to forget about a variable's type and treat as having another type that you supply. This isn't done randomly, only between compatible types, and care is recommended when using casting. For example, let's say we want to find out the ASCII value of 'a'. The code could look like this:

	#include <stdio.h>

	int main()
	{
	  char c = 'a';
	  printf("The ASCII value of 'a' is %d.\n", (int)c);
	  
	  return 0;
	}

You will get the value 97, which is indeed the ASCII value of 'a'. So, by using parentheses before and after the type you want to "impose" and all this before the variable's name, you get casting. The example above works because a char is nothing more than a small int, so the types are compatible. Try casting the variable above to other types and note the results.

// [iv] Increment and decrement operators
These are unary operators and can be prefixed as well as postfixed. What does that mean? It means that you can write either ++c or c++, and the result may or may not be similar. The difference is that with '++' prefixed, the value of the variable is first incremented by one, then used, and the other way around. We'll show you a short example of when it matters and when it doesn't.

	#include <stdio.h>

	int main()
	{
	  int x;
	  int n = 10;
	  int z;
	  
	  n++; /* n will be 11 now */
	  ++n; /*ditto, prefix or postfix unimportant */
	  
	  x = n++; /* x will be 10 */
	  z = ++n; /* z will be 11 */
	  
	  return 0;
	}

But what if you want to increment/decrement with more than one? Simple, since c++ is the equivalent of c+=1. Replace 1 with whatever value you need and you're set. These compound operators can also be used with any other binary arithmetic operators (e.g. *= or /=) and the bitwise operators as well, like 'a &= b'.

// [v] Bitwise operators

In C you can do bitwise operations easily, but remember! They work and are to be used only with integer types, signed or unsigned. These operators are:

	& - bitwise AND
	| - bitwise OR
	^ - XOR
	<< - left shift
	>> - right shift
	-  - one's complement

// [vi] Logical operators
We've already dealt with '!', which negates any logical expression, but there are two very important logical operators (be careful not to mix them up with the bitwise ones): and and or, respectively. So, if I want to write in C something like "if variable 1 has value 2 and variable 2 has value 8", I'll write like this:

	if (var1 == 2 && var2 == 8)
	  ...

Here both conditions must evaluate as true for the instructions following if to execute. If either will do, or both, we replace '&&' with '||' (conjunction versus disjunction).

// Other operators
People that have some C experience may have noticed the lack of some operators. Of course, and we're aware of that, but what sense would it make to list the indirection operator while readers don't know what a pointer is? So, the other operators, specific to other parts of C, will be dealt with in due time.

// ----------------------------------------
// chapter: Flow Control - IV.
// source: http://how-to.linuxcareer.com/c-development-on-linux-flow-control-iv
// ----------------------------------------

// if/else/else if
This part of flow control is probably the most intuitive and simpler, although you can easily fall to the dark side and start writing unintelligible code with if's. The idea is simple: if (condition_is_true) do_something; else do_something_else; . So it's all about logic, binary logic that is, in which an expression can have two values: true or false. If you used C or Java, you're used with the bool datatype. A bool variable can be only true or only false at a given moment. But C, although it doesn't have the bool datatype, makes it easy to deal with binary logic, as you will see.

example: if the age entered is above a threshold, then we tell the user he's old. If not, we tell him/her he/she is still young and blooming. The code for such a program would look like this:

	#include <stdio.h>
	#define LIMIT 50

	int main()
	{
	  int age;
	  printf("Hello, please enter your age!\n");
	  scanf("%d", &age);	// scanf is used for storing the user input
	  if(age < LIMIT)
	  {
	    printf("Your age is %d.\n", age);
	    printf("Quite young, I say.\n");
	  }
	  else if(age == LIMIT)
	  {
	    printf("You say your age is %d.\n", age);
	    printf("Almost there.\n");
	  }
	  else
	  {
	    printf("So your age is %d, huh?\n", age);
	    printf("Geezer.\n");
	  }
	  
	  return 0;
	}

For example you will see we defined a constant named LIMIT (it's recommended to capitalize your constants) with a value of 50, which is the threshold we talked about above. Next you will notice that C doesn't use 'then' after the if expression like the Bourne shell does, for example. Finally, we wrote this program like this because we can illustrate another important concept: blocks. A block is a series of instructions that belong together, united by braces. Please bear in mind that if you use else if you can omit the final else, depending on the situation.

Well, C allows you to nest ifs and things may go south very easily and create bugs that will be hard to trace, or your code can become a mess to read by others and even you, so if you plan to really use nested ifs and can't live without them, we recommend you abuse the use of braces for clarity. There are lots of situations where the logical AND operator can save you and make your code become more readable. Consider the following example:

	int number = 3;

	if ((number > 2) && (number < 4))
	{
	  printf ("number is three");
	}

	/* This could have been written like this:*/

	int number =3;

	if (number > 2)
	{
	  if (number < 4)
	  {
	    printf ("number is three");
	  }
	}

Again, this is a simple example, but I think you got the point. Use whatever method necessary and remember that '&&' is not always a substitute for nested ifs, but if you need overly complicated if structures, you probably need to rethink your program's logic.

// while and for
With this section of our article, we introduce another essential concept of C programming: loops. A loop allows you to repeat a certain instruction or block depending on a condition, that is, execute something until some condition changes its truth value from true to false. As you can see, this concept is related to conditional instructions and they can be used together with an if statement.

these conditions and loops:
[i] 	if/if else, else
[ii]	while
[iii]	for
[iv] 	switch/case
[v]	do/while
[vi]	break, continue, and goto

// [ii]	while
The theoretical concept of while is 'while (expression_is_true) execute_something;' . With each iteration, the expression in reevaluated and if it's still true, the instruction(s) is/are executed again, until the expression we test against becomes false. From here we can infer that if we want to write an infinite loop using while, we can write

	while(1)
	{
	  do_stuff();
	  do_more_stuff();
	}

Like we said, C doesn't have a bool keyword, but you can do something to overcome this: you can compile your programs to adhere to the C99 edition of the standard (-std=c99 as a gcc flag), which will let you access the _Bool datatype, you can use stdbool.h which defines 1 as true and 0 as false or you can define TRUE and FALSE with preprocessor instructions.

Anyway, let's continue with a complete, working example. Let's say we want to output some message on the screen 5 times. We will talk about the same example later using for, but for now let's see how to do it with while.

	#include <stdio.h>

	int main()
	{
	  int i;
	  i = 5;
	  while(i != 0)
	  {
	    printf("Hello!\n");
	    i--;
	  }

	  return 0;
	}
	
	/* better coding than the above example */
	#include<stdio.h>

	int main (int argc, char *argv[]){  // argc and argv are a must for a professional programmer
	int i=5;
	while (i != 0)
		printf("Hello World!!\n", i--); // you still can decreament i in printf even when you're not using it there!!

	return 0;
	}


So while executes the instructions between its braces until 'i != 0' evaluates as false, that is when i equals zero, then it stops. For this loop to work, we need to decrement i at each pass, until it reaches zero.

// [iii] for
A loop written with for is more compact and organized, but it does the same thing as a while loop: evaluate an expression and execute something if the expression is true. This means that there are situations where the instructions may not execute at all, if the condition is false from the start. You'll see in a whim why this is important. Using for vs while is a matter of situation, habit and personal preference, so there isn't really anything one can do and the other can't.

A for loop has three parts: initialization, loop, increment/decrement. It's important to know that any part of the three can be omitted, but the semicolons, as you will see, must remain. So, a infinite loop with for would look like this:

	for(;;)
	{
	  do_something();
	  do_something_else();
	}

doing the above while example in for loop:

	#include<stdio.h>

	void foo();

	int main ( int argc , char * argv[]){

	foo();

	printf("\n");
	return 0;
	}

	void foo(){

	int i = 5 ;
	for ( ; i != 0 ;)
		printf("[%d] Hello World!!\n", i--);

	}

// [iv] switch/case
If you want to use an interactive program and you realize that at one point you'll have to deal with multiple options, chosen from a list of constants, then switch is what you need. This situation is often encountered when writing interactive applications, where you will use dialogs like this: "If you want to do that, press that; if you need this, press this" and so on. For example, we will show you a program that shows you an integer value that you introduce in hex or octal, depending on your choice.

	#include <stdio.h>

	int main()
	{
	  char option;
	  int number;
	  
	  printf("Please enter the number you want converted.\n");
	  /*Please refrain from using gets() because of its
	 * insecure "features" */
	  scanf("%i", &number);
	  
	  printf("What kind of conversion do you need?\n");
	  printf("Press 'o' for octal and 'x' for hexadecimal.\n");
	  
	  while((option = getchar()) != EOF && (option = getchar()) != '\n') // that line, I don't undersatnd everything in it!!
	  {
	    switch(option)
	    {
	      case 'o':
		printf("The number in octal is 0%o.\n", number);
		break;
	      case 'x':
		printf("The number in hex is 0x%x.\n", number);
		break;
	      default:
		printf("Option not valid.\n");
	  break;
	    }
	  }
	  return 0;
	}
Now let's dissect the program and see what and how it does things. One thing newly introduced here is the getchar() function, as defined in stdio.h . It's used here to get a single character from user input and then write the character to a variable. We could have used option = getchar() once, before the while, but we wrote the code like this to emphasize how you can use it. We'll leave it up to you to figure out why we check for EOF and the newline character, and we encourage you to try and see what happens if you omit those checks. The syntax of a switch statement is pretty simple and self-explanatory, so we'll be pretty brief.

We use break; in every case because otherwise the loop would continue to the next tag (tags are what is written before the colon). The default: tag is not mandatory, but it's useful to do something in case to other tag matches the existing data, and it's also considered good programming practice. As another exercise, we recommend you try and rewrite our code below using scanf() instead of getchar() and see how it goes. Will it work?

// [v] do/while
We said earlier that while and for evaluate first and execute after, so there are chances the instructions might never get executed. There will be situations when you will want the exact reverse, and this where do/while enters the stage. The logical flow is inverted, as compared to while, as in do (something) while (condition_is_true). So the evaluation is done after the execution, which guarantees at least one round before the compiler realizes that the condition is false (or not).

Let's see how an infinite loop would look like with do/while:

	do
	  printf("Hello!\n");
	while(1);

You can simply try to verify how the flow goes by simply replacing 1 with 0 in the above code and see what happens: The program will print 'Hello!' once, before realizing that the while expression evaluates as false. do/while constructions are usually less used that their counterparts, but you will see that there are situations where they make your life easier. 

// [vi] break, continue, and goto
We already "met" break before, and it can be simply described as the method of getting out of a loop in other ways than the default. You can use it with loops or switch constructions, as opposed to continue, which doesn't really make sense in a switch. We'll leave it to you to write some code where break and continue are used and useful, and we will continue with one of the C programmer's "enemies": goto. 

its use is not recommended in any case, maybe except for some system-related programs. It's not recommended because with goto you can easily turn your work into spaghetti code, that is, code that's very hard to read and debug because the reader is forced to "jump" to various sections of the code in order to understand it. But for the sake of completeness, here's how it works. You declare a label, afterwards you assign some instructions to it and then you can use it in different portions of your code. Usually you can get away with a custom function instead of this, so use goto ONLY when all else fails.

	if(error_unknown)
	  goto error;

	/*[...]*/
	error:
	printf("Generic error!.\n");

Now whenever you have an untreated/unknown error, you can use the error goto label to print that very helpful message. Again, avoid goto like the plague. It's easier than you might realize to get used to it and create a bad habit of writing spaghetti code. We can't emphasize this enough.

// Creating your functions
For a simple start, let's say you wanna write a calculator. We won't focus on the interface (GUI vs curses vs slang vs CLI) as we're interested on the internals. It would be clunky to not create a function for every operation you decide to support, unless there is one already, like pow() , defined in math.h, which returns the result of a base raised to a power. So, for example, for addition you will have a function named add() that takes two arguments, at least for now, and returns the result. So when the user chooses to add the number (s)he introduced, you just call the function with the numbers the user entered and you needn't worry about anything else. 

 A function usually (but not always) takes something, does a number of operations on that something and spits out the result. "Not always" because main(), as you could see before, can be called with no arguments, and there are other examples as well. But for now, let's focus on our examples. The numbers that need to be added together are the arguments, that "something" you give the function for processing. The processing part is in the body of the function, when you tell it to add the numbers together. After that, the "spitting out" part is called returning a value, which is, in our case, the result of the addition.

Let's see what we talked about in a practical example:

	#include <stdio.h>
	/* this contains the definition of printf()*/
	double add(double x, double y);

	int main()
	{
	  float first, second;
	  printf("Please enter the first number.\n");
	  scanf("%F",&first);
	  printf("Please enter the second number.\n");
	  scanf("%F",&second);
	  
	  double add(double a, double b)
	  {
	    return a + b;
	  }
	  
	  printf("The result of the addition is %F\n", add(first, second));
	  
	  return 0;
	}

The above code, although simplistic at best, helps us point out precisely what we talked about before. First we declare the function, before main(), and the purpose is to know the name, the type of the arguments and the type the function returns. This line is also called defining the function prototype. As you can see, the arguments' names from the declaration need not be the same as the ones used in the definition, but if that troubles you, use a constant naming scheme, it's alright. 

Before we use the function we must define it, as in tell the world what is it exactly that it does. Even if the function's body is single-line, just as it is in our example, it is best you use braces for readability and for good habit. Here, everything the function does is return the result of the addition between two numbers.

We suggest you use names for functions, arguments and ordinary variables or constants that reflect what they do, again for good habit and for sparing the programmers reading your code the attempts to guess what variable "xyzgth" does or is used for.

Also, use comments. Even if in the above code comments might seem overkill, they're not. When you look at the code two months later, you won't have any idea what was in your mind when you wrote the code. So use and abuse comments, they'll save you, trust me.

There are functions that can accept a variable number of arguments, like printf() for example. You are allowed to use Google to see what they do and try to rewrite the add() function to accept more than two arguments, or create another function. You can also use "man 3 printf".

// main function
We told you before that main() can be called with no arguments. Of course, that means it can be called with arguments as well. When is this useful? In programs simple such as ours, since we call them with no arguments, the parentheses of main() are empty. But when your programs will grow in complexity, especially if they will be command-line oriented you will need to add the functionality of arguments, like gcc's -v flag that prints the version. When such functionality is desired, main() must have arguments, two to be precise. The main function becomes

	int main(int argc, char **argv)
	{
	  ....
	}

Before you freak out over the cryptic names and the double asterisks, wait till you get the explanation, which is actually simple. The first argument is an integer named argc, and the name comes from "ARGument Count". A little better, right? About the second argument...well, the name stands for "ARGument Vector" officially and it's a pointer to a pointer to a char.

Now, in English, while argc stores the number of arguments, argv stores the arguments as a series of strings. for now all you need to know is that if, for example, the user will type three arguments to the program, index zero of argv will be the name of the program itself, index one will store the first argument to the program and so on. This is how you can use a switch/case to check for the arguments passed to your programs. 

Before we give you a short example, we feel compelled to tell you that main has two arguments as defined by the standard, and this is how it's used on most Linux and Unix systems. However, if you (will) work on Windows or Darwin, main() will have one or two more arguments, but those are system-dependent and so are not defined or required by the standard. Also, "char **argv" might also be written as "char *argv[]". You will see both, depending on the developer's preference.

You might remember we told you in the first part of our series how we're gonna use Kimball Hawkins' yest program for examples. It's time we start, so here's how yest deals with a part of the possible user input:

	if ( strncmp( argv[i], "--help", 6 ) == 0 ||
		     strncmp( argv[i], "-?",     2 ) == 0 ||
		     strncmp( argv[i], "?",      1 ) == 0 ||
		     strncmp( argv[i], "help",   4 ) == 0 )
		    yest_help();	/* help requested, display it */

	if ( strncmp( argv[i], "--version", 9 ) == 0 ||
		     strncmp( argv[i], "--license", 9 ) == 0 )
		    yest_version();	/* version/license information requested */

You may see in this code how Kimball comments his code, although the name of the functions he calls - yest_help() and yest_version() - are pretty self-explanatory. The standard strncmp() function, to be found in string.h, compares two strings, in our case argv[i] and "help", for example, but only the first x characters (4 in the "help" line) and returns zero if the first string matches the second.

// Things to be aware of
C does not allow you to define a function inside another, with the exception main(), which is, as we can see, special. Be also aware that what you define inside a function "lives" inside a function only. So you can have a variable named "a" defined inside three different functions with no problems at all, but that may lead to issues in larger programs, so we don't recommend it.

// Custom header files
As your programs will grow bigger and bigger, you'll find the need to split them. You can have more than one source files, but you can also write your own headers. So going back to our addition program, you can create a header named operations.h which will have the line "double add(double x, double y);", so your program will deal only with the definition, the part where you say that add() will return a + b. Including your custom header is done just as you include system-installed ones with one important exception: remember to use double quotes instead of angle brackets, like this: #include "operations.h". This header can be placed in the directory where the other source files are stored or in another path, specified as an argument to gcc so it would know where to look. Header files can contain also constants definitions (with #define) or other declarations, as long as you know that they will be used in every source file of the program.

// Recursive functions
As we expect you to have some programming background, we're certain that you know what recursive functions are and how/when to use them. This is why this subchapter will be shorter than it would normally be. In short, one says about a function to be recursive when it calls itself. 

But we will give you a short example, so that you understand better when and how to use it. You probably remember from school when you were taught about factorials. A factorial is the product of a all integers smaller than it or equal, as long as they're greater than zero. The notation for this is an exclamation sign, so 6! = 6*5*4*3*2*1=720. How can we do this in C in the most efficient manner? Of course, using recursion.

	int factorial(int number)
	{
	  if(number <= 1)
	    return 1;
	  else
	    return number * factorial(number-1)
	}

	/*  complete example */
	#include<stdio.h>

	int factorial (int num)
	{
	// note: 0!=1
	if (num == 0)
		return 1;
	return num * factorial(num -1);
	}

	int main (int argc, char *argv[]){
	printf("%d!=%d\n", atoi(argv[1]), factorial(atoi(argv[1])) );
	return 0;
	}

// ----------------------------
// chapter: Pointers and Arrays - VI.
//------------------------------

It seems natural and common sense that we should start with the warnings, and we heartily recommend you remember them: while pointers make your life as a C developer easier, they also can introduce hard-to-find bugs and incomprehensible code. You will see, if you continue reading, what we're talking about and the seriousness of said bugs, but the bottom line is, as said before, be extra careful.

A simple definition of a pointer would be "a variable whose value is the address of another variable".  On the other hand, an array can be defined as a collection of items identified by indexes. You will see later why pointers and arrays are usually presented together, and how to become efficient in C using them. If you have a background in other, higher-level languages, you are familiar with the string datatype. In C, arrays are the equivalent of string-typed variables, and it is argued that this approach is more efficient.

// Pointers
You have seen the definition of a pointer, now let's start with some in-depth explanations and, of course, examples. A first question you may ask yourself is "why should I use pointers?". I've heard some horror stories about senior C developers that swear they never used pointers because they're "tricky", but that only means the developer is incompetent, nothing more. Plus, there are situations where you'll have to use pointers, so they are not to be treated as optional, because they're not. As before, I believe in learning by example, so here goes:

	int x, y, z;
	x = 1;
	y = 2;

	int *ptoi; /* ptoi is, and stands for, pointer to integer*/
	ptoi = &x; /* ptoi points to x */
	z = *ptoi; /* z is now 1, x's value, towards which ptoi points */
	ptoi = &y; /*ptoi now points to y */

We first declared three integers, that's x, y and z, and gave x and y values 1 and 2, respectively. This is the simple part. The new element comes along with the declaration of the variable ptoi, which is a pointer to an integer, so it points towards an integer. This is accomplished by using the asterisk before the name of the variable and it's said to be a redirect operator. The line 'ptoi = &x;' means "ptoi now points towards x, which must be an integer, as per ptoi's declaration above". You can now work with ptoi like you would with x (well, almost). Knowing this, the next line is the equivalent of 'z = x;'. Next, we dereference ptoi, meaning we say "stop pointing to x and start pointing to y". One important observation is necessary here: the & operator can only be use on memory-resident objects, those being variables (except register[1]) and array elements.

[1] register-type variables are one of the elements of C that exist, but the majority of the programmers shun (to keep away from) them. A variable with this keyword attached suggests to the compiler that it will be used often and it should be stored in a processor register for faster access. Most modern compilers ignore this hint and decide for themselves anyway, so if you're not sure you need register, you don't.

We said that ptoi must point to an integer. How should we proceed if we wanted a generic pointer, so we won't have to worry about data types? Enter the pointer to void. This is all we'll tell you, and the first assignment is to find out what uses can the pointer to void can have and what are its' limitations.

// Array
It's good to know that, when working with arrays, you don't have to use pointers, but it's nice to do so, because operations will be faster, with the downside of less comprehensible code. An array declaration has the result of declaring a number of consecutive elements available through indexes, like so:

	int a[5];
	int x; 

	a[2] = 2;
	x = a[2];

a is a 5-element array, with the third element being 2 (index numbering starts with zero!), and x is defined as also being 2. Many bugs and errors when first dealing with arrays is that one forgets the 0-index problem. When we said "consecutive elements" we meant that it's guaranteed that the array's elements have consecutive locations in memory, not that if a[2] is 2, then a[3] is 3. There is a data structure in C called an enum that does that, but we won't deal with it just yet. Example, a program that reverses the characters in a string:

	#include <stdio.h>
	#include <string.h>

	int main()
	{
	  char stringy[30];
	  int i;
	  char c;
	  printf("Type a string .\n");
	  fgets(stringy, 30, stdin);
	  printf("\n");

	  for(i = 0; i < strlen(stringy); i++)
	    printf("%c", stringy[i]);
	  printf("\n");
	  for(i = strlen(stringy); i >= 0; i--)
	    printf("%c", stringy[i]);
	  printf("\n");

	  return 0;
	}

This is one way of doing this without using pointers. It has flaws in many respects, but it illustrates the relation between strings and arrays. stringy is a 30-character array that will be used to hold user input, i will be the array index and c will be the individual character to be worked on. So we ask for a string, we save it to the array using fgets, prints the original string by starting from stringy[0] and going on, using a loop incrementally, until the string ends. The reverse operation gives the desired result: we again get the string's length with strlen() and start a countdown 'til zero then print the string character by character. Another important aspect is that any character array in C ends with the null character, represented graphically by '\0'.

How would we do all this using pointers? Don't be tempted to replace the array with a pointer to char, that won't work. Instead, use the right tool for the job. For interactive programs like the one above, use arrays of characters of fixed length, combined with secure functions like fgets(), so you won't be bitten by buffer overflows. For string constants, though, you can use

	char * myname = "David";

and then, using the functions provided to you in string.h, manipulate data as you see fit.

// Pointers and arrays

You can, and are encouraged to, use arrays in conjunction with pointers, although at first you might be startled because of the syntax. Generally speaking, you can do anything array-related with pointers, with the advantage of speed at your side. You might think that with today's hardware, using pointers with arrays just to gain some speed isn't worth it. However, as your programs grow in size and complexity, said difference will start being more obvious, and if you ever think of porting your application to some embedded platform, you will congratulate yourself. Actually, if you understood what was said up to this point, you won't have reasons to get startled. Let's say we have an array of integers and we want to declare a pointer to one of the array's elements. The code would look like this:

	int myarray[10];
	int *myptr;
	int x;
	myptr = &myarray[0];
	x = *myptr;

So, we have an array named myarray, consisting of ten integers, a pointer to an integer, that gets the address of the first element of the array, and x, which gets the value of said first element via a pointer. Now you can do all sorts of nifty tricks to move around through the array, like

	*(myptr + 1);

which will point towards the next element of myarray, namely myarray[1].

One important thing to know, and at the same time one that illustrates perfectly the relationship between pointers and arrays, is that the value of an array-type object is the address of its' first (zero) element, so if myptr = &myarray[0], then myptr = myarray.

// Considerations on strings in C and calls

Before we have seen that you can do either

	char *mystring;
	mystring = "This is a string."

or you can do the same by using

	char mystring[] = "This is a string.";

In the second case, as you might have inferred, mystring is an array big enough as to hold the data attributed to it. The difference is that by using arrays you can operate on individual characters inside the string, while by using the pointer approach you cannot. Going a little further, another issue you should be aware of is that if you forget about pointers, calls in C are made by value. So when a function needs something from a variable, a local copy is made and work is done on that. But if the function alters the variable, changes are not reflected, because the original stays intact. By using pointers, you can use calling by reference, as you will see in our example below. Also, calling by value might become resource-intensive if the objects being worked on are big. Technically, there is also a call by pointer, but let's keep it simple for now.

Let's say we want to write a function that takes an integer as an argument and increments it with some value. You will probably be tempted to write something like this:

	void incr(int a)
	{
	  a+=20;
	}

Now if you try this, you will see that the integer will not be incremented, because only the local copy will be. If you would have written

	void incr(int &a)
	{
	  a+=20;
	}

your integer argument will be incremented with twenty, which is what you want. 

// note: function in C can only hold four arguments and return one value!!, so if you want more than one output from a function you can use pointer to overcome this issue!!

// Pointers to pointers

Yes, pointers are variables just like any other, so they can have other variables point to them. While simple pointers as seen above have one level of "pointing", pointers to pointers have two, so such a variable points to another that points to another. You think this is maddening? You can have pointers to pointers to pointers to pointers to....ad infinitum, but you already crossed the threshold of sanity and usefulness if you got such declarations. We recommend using cdecl, which is a small program usually available in most Linux distros that "translates"between C and C++ and English and the other way around. So, a pointer to a pointer can be declared as

	int **ptrtoptr;

Now, as per how multiple-level pointers are of use, there are situations when you have functions, like the comparison above, and you want to get a pointer from them as return value. You also might want an array of strings, which is a very useful feature, as you will see in a whim.

// Multi-dimensional arrays
The arrays you have seen so far are unidimensional, but that doesn't mean you are limited to that. For example, a bi-dimensional array can be imagined in your mind as being an array of arrays. My advice would be to use multi-dimensional arrays if you feel the need, but if you're good with a simple, good ole' unidimensional one, use that so your life as a coder will be simpler. To declare a bi-dimensional array (we use two dimensions here, but you're not limited to that number), you will do

	int bidimarray [4][2];

which will have the effect of declaring a 4-by-2 integer array. To access the second element vertically (think of a crossword puzzle if that helps!) and the first horizontally, you can do

	bidimarray [2][1];

Remember that these dimensions are for our eyes only: the compiler allocates memory and works with the array about the same way, so if you don't see the utility of this, don't use it. Ergo, our array above can be declared as

	int bidimarray[8]; /* 4 by 2, as said */

// Command line arguments
In our previous installment (the act of installing) of the series we talked about main and how it can be used with or without arguments. When your program needs it and you have arguments, they are char argc and char *argv[]. Now that you know what arrays and pointers are, things start to make way more sense. However, we thought about getting in a bit of detail here. char *argv[] can be written as char **argv as well. As some food for thought, why do you think that is possible? Please remember that argv stands for "argument vector" and is an array of strings. Always you can rely on the fact that argv[0] is the name of the program itself, while argv[1] is the first argument and so on. So a short program to see the its' name and the arguments would look like this:

	#include <stdio.h>
	#include <stdlib.h>

	int main(int argc, char **argv)
	{
		while(argc--)
		        printf("%s\n", *argv++);
		return 0;
	}

// Structures - VII

We will continue in this part of our tutorial with the complex data types in C, and we will talk about structures. Many modern programming languages offer them, one shape or another, and so does C. As you will see later, structures allow you to manipulate data easier, by allowing you to store different variables of (possibly) different types under one single "roof".

// Beginning structures
One interesting parallel is the one referring to a database table: if you have a table called users (the unique name), then you will put in that table the exact data which pertains directly to the users: age, gender, name, address, and so on. But these are different types! No problem, you can do that with a table, just as you can do it with a struct: age will be an integer, gender will be a char, name will be a string and so on. Then you will be able to access the members of the table easily, by referring to the name of the table/member. But this is not a database course, so let's move on. But before that, let's take a short look at a logical aspect: you are invited to create structs with members that have something in common from a logical point of view, like the example above. Make it easier for you and the people that will later look at your code. So, let's see how our users database table would translate in a C struct:

	struct users {
		int age;
		char gender;
		char *name;
		char *address;
	};

Please do not forget the semicolon at the end. OK, so I boasted that the members of the structure are simple to access. Here's how, provided you want to access the age of the user:

	printf("The age of the user is %d.\n", users.age);

But for that printf to work, we'll have to define the age first. That can be done like this

	struct users {
		int age;
		...
	} usrs;
	usrs.age = 25;
	...

	...

What we did here is declare an instance of the struct (you can have as many instances as you please), named "usrs". You can have usrs1, usrs2, usrs3 and so on, so you can use these attributes (like age, gender, address) on all of them. The second way to do this is to declare the struct as we did the first time (e.g. without instances) and then declare the respective instances later in the code:

	...
	struct users usrs1, usrs2, usrs3;

...and then take care of the age, gender, address and so on as we did above.

When we talk about structs in conjunction with functions, the most important thing to talk about is probably the fact that structs are regarded as a whole, not as a compound made of several elements. Here's an example:

	void show_age(usrs i)
	{
		printf("User's age is %d.\n", i.age);
		printf("User's name is %s.\n", (&i)->name);
	}

What this function does is: it takes a numeric argument and prints out all the users that have that specific age. You might have noticed a new operator in the above code (if you haven't, look again). The "->" operator does exactly what the dot operator does, allowing you to access a member of the structure, with the specification that it's used when pointers are involved, just as the dot operator is used in cases when pointers are not involved. One more important consideration here. Given the following code:

	struct mystruct {
		int myint;
		char *mystring;
	} *p;

what do you think the following expression will do?

	++p->myint;

// Advanced topics

One of the things you'll see pretty often in relation with structures, but not only, is the typedef keyword. As the name implies, it allows you to define custom datatypes, like in the examples below:

	typedef int Length; /* now Length is a synonym for int */
	typedef char * String;

Regarding structs , typedef basically eliminates the need to use the 's' word. So here's a struct declared in this manner:

	typedef struct colleagues {
		int age;
		char gender;
		...
	} colls;

Let's presume you have a program, written in C, and you want to count the number of occurrences of all the keywords the standard defines. We need two arrays: one to store the keywords and another to store the number of occurrences corresponding to each keyword. This implementation can be written as such:

	char *keywords[NRKEYWORDS];
	int results [NRKEYWORDS];

Looking at the concept you will soon see that it uses a pairs concept, which is more efficiently described by using a structure. So, because of the end result we'll need, we will have an array whose each element is a structure. Let's see.

	struct keyword {
		char *keywords;
		int results; 
	} keywrdtbl [NRKEYWORDS];

Now let's initialize the array with the keywords and the initial number of occurrences which will, of course, be 0.

	struct keyword {
		 char *keywords;
		 int results;
	 } keywrdtbl [] = {
		 "auto", 0, 
		 "break", 0, 
		 "case", 0,
		 ...
		 "while", 0
	 };

The last subject on structs I will deal with is the matter of pointers to structs. If you wrote the program in the last exercise, you might already have quite a good idea how it could be re-written so it can use pointers instead on indexes. So if you like writing code, you might consider this as an optional exercise. So there's nothing much around here, just a few aspects, like (very important), you must introduce some extra code with extra care so that when parsing the source code of the file you're scanning for keywords, and of course the search function must be modified, you won't create or stumble upon an illegal pointer.

Another issue to be careful with is the size of the structs. Don't be fooled : there can be only one way to get a structure's way right, and that is by using sizeof().

	#include <stdio.h>

	struct test {
		int one;
		int two;
		char *str;
		float flt;
	};

	int main()
	{
		printf("Struct's size is %d.\n", sizeof(struct test));
		return 0;
	}	 

This should return 24, but that is not guaranteed, and K&R explains this is because of various alignment requirements. I recommend using sizeof whenever you are in doubt, and presume nothing.

// Unions

A union resembles much a structure, what differs is the way the compiler deals with the storage (memory) for it. In short, a union is a complex data type that can store different types of data, but one member at a time. So regardless how big the variable stored will be, it will have its' place, but others won't be allowed in the union at that precise moment. Hence the name "union". The declarations and definitions of unions are the same as structures, and it's guaranteed that the union will take as much memory as its' biggest member.

// Bitfields
If you will want to use C in embedded systems programming and/or low-level stuff is your game, then this part will seem appealing. A bitfield (some write it bit field), doesn't have a keyword assigned like enum or union, and it requires you to know your machine. It allows you to go beyond the tipical word-based limitations other languages confine you to. It also allows you to, and this might be a formal definition, "pack" more than one object in a single word.

// Enums
To start with a short historical fact, enums were introduced in C when C89 was out the door, meaning K&R lacked this nifty type. An enum allows the programmer to create a set of named values, also known as enumerators, which have as their main characteristic that they have an integer value associated with them, either implicitly (0,1,2...) or explicitly by the programmer (1,2,4,8,16...) . This makes it easy to avoid magic numbers.

	enum Pressure { pres_low, pres_medium, pres_high };
	enum Pressure p = pres_high;
Now, this is easier, if we need pres_low to be 0, medium 1 and so forth, and you won't have to use #defines for this. I recommend a bit of reading if you're interested. http://codingrelic.geekhold.com/2008/10/ode-to-enum.html


//----------------------------------
// topic: Basic I/O
// ---------------------------------

We will treat concepts like standard input, output and error, in-depth printf() and file access, among others.

// Basic I/O
Before we go any further, let's take some time and see what this I/O is about. As many of you know, the term stands for Input/Output and has a broad meaning, but in our case we are interested on how to print messages to the console and how to get input from the user. The standard C library defines a series of functions for this. 

// Standard I/O
In short, the above subtitle means "get input from the user, print characters on the standard output and print errors on standard error". Nowadays, the main input source, at least at this level, is the keyboard, and the device the system prints on is the screen, but things weren't always like this. Input was made on teletypes (by the way, the device name tty comes from that), and the process was slow and clunky. Any Unix-like system still has some historical leftovers regarding, but not only, I/O, but for the rest of this article we will treat stdin as the keyboard and stdout/stderr as the screen. You know that you can redirect to a file, by using the '>' operator offered by your shell, but we aren't interested in that for the time being. Before we begin the article finally, a little reminder: Mac OS up to version 9 has some unique features regarding our subject that pushed me to read some documentation before starting development on it. For example, on all Unix(-like) systems the Enter key generates a LF (line feed). On Windows it's CR/LF , and on Apple up to Mac OS 9 it's CR. In short, every commercial Unix vendor tried to make their OSes "unique" by adding features. Speaking of documentation, your system's manual pages will prove invaluable, although maybe arid at times, and also a good book on Unix design will look good at your side.

We've seen printf() in our previous installments and how to print text on the screen. We've also seen scanf() as a means to get text from the user. For single characters, you can count on getchar() and putchar(). We'll see now some useful functions from headers included in the standard library. The first header we will talk about is ctype.h, and it contains functions useful for checking the case of a character or changing it. Remember that every standard header has a manual page, explaining what functions are available, and said functions in turn have man pages, detailing the return types, arguments and so on. Here's an example that converts every character in a string to lowercase, using tolower(). How would you attain the opposite?

	#include <stdio.h>
	#include <ctype.h>

	int main()
	{
	  int c; /* the character read*/
	  while ((c = getchar()) != EOF)	// note: EOF is in Linux Cntr + D
	    putchar (tolower(c));
	  return 0;
	}

Another question for you is: in what way should the code be modified so that it prints the lower-cased result only after a sentence? That is, provided the sentence is always ended by a dot and a space.

// printf() in detail
Since it's a function so widely used, I only felt that it deserves a sub-section of its' own. printf() accepts arguments prefixed with the '%' symbol and followed by a letter (or more), thus telling it what kind of input it should expect. We've worked before with '%d', which stands for decimal, which is appropriate when working with integers. Here's a more complete list of printf()'s format specifiers:


	[1]	d, i - integer
	[2]	o - octal, without the prefixing zero
	[3]	x, X - hexadecimal, without the prefixing 0x
	[4]	u - unsigned int
	[5]	c - char
	[6]	s - string, char *
	[7]	f, e, E, g, G, - float - check your system's printf() manual
	[8]	p - pointer, void *, implementation-dependent, standard between Linux distros

While you're at it, pay special attention to the variable argument list part, and note that Linux has a command named printf, as part of coreutils, so make sure that you use the section 3 manpage (Linux-specific, as other Unices may have the manual sections laid out differently).

scanf() is the opposite of printf, in that it takes input from the user instead of outputting to the user. The format specifiers are almost the same, with certain exceptions regarding floats and the fact that it doesn't have a %p. Why do you think that is? It also supports variable arguments lists, just like printf().

// File access
This is another essential part of I/O and since C is relatively low-level, it allows you to read and write files to disk in a simple manner. The header that offers this simple functionality is stdio.h, and the function you will be using is fopen(). It takes the filename as the argument, as well as the mode it should be read (read/write (r,w). append (a) or binary(b), as opposed to text - but the latter's implementation is system-dependent). fopen() returns a FILE pointer, which is a type. Before anything you will need a file pointer, as illustrated:

	FILE *fp; /*file pointer */
	fp = fopen("/home/user/testfile.txt", "w");
	fprintf(fp, "My test file.")

full code as shown below

	 /*	This program creates a file if it doesn't exist and write a sentence into the file.
	 *	On the other hand, if the file exist, then the program would overwrite the existence file with a sentence   
	 *	that is hard-coded into this code!!
	 */	
	#include <stdio.h>

	int main()
	{
	FILE *fp; /*file pointer */
	fp = fopen("testfile.txt", "w");
	fprintf(fp, "My test file.\n") ;
	fclose(fp); // closing the file 
	return 0;
	}

Simple: I opened a file on my disk and wrote to it the string "My test file". You might have guessed, I have some exercises. Would it make a difference if the file exists or not? What if it existed, but was empty? Should I have used append instead of write mode? Why?

After using the file, one must close it. This is important, because by closing your program tells the operating system "Hey, I'm done with this file. Close all dirty buffers and write my file to disk in a civilized manner, so no data loss occurs".

	fclose(fp);

Here's a real life example of using file I/O from Kimball Hawkins' yest program, which helps us remember two things: one, that because of the Unix design (everything is a file), stdin, stdout and stderr are files, so they can be used with file I/O functions, and two, that the next part treats stderr and exit.

	void store_time()
	{
	    if ( time_ok == FALSE ) return;	/* No time information, skip it */

	    /* Hour */
	    if ( tfield[0] > 24 ) {
		fprintf(stderr, "ERROR: Bad input hour: '%d'\n", tfield[0]);
		exit(1);
	    }
	    theTime->tm_hour = tfield[0];

	    /* Minute */
	    if ( tfield[1] > 0 ) {
		if ( tfield[1] > 60 ) {
		    fprintf(stderr, "ERROR: Bad input minute: '%d'\n", tfield[1]);
		    exit(1);
		}
		theTime->tm_min = tfield[1];
	    }
	}
// Treating errors with stderr and exit
Your program must have some way to deal with errors and let the OS and the user know something went wrong. While this part is in no way a dissertation on how to treat your possible situations in C, it deals with a very useful and well-thought element of Unix: output errors to another place, different than stdin, so that the user can separate the two when debugging the issue. Also, use exit codes so that the user knows when the program finished successfully and when it didn't. 

This is why stderr exists, for the first part, and this is why exit() also exists, for the second part. The astute (clever; cunning; ingenious; shrewd) reader already got the idea from the code sample above, so all it takes is tell the system not to output text on the default/standard output, but to the special "channel" that exists especially for this. 

Regarding exit(), it works like this: zero for success, any other value between 1 and 255 in case of failure. It's included in stdlib.h and does not return a value. It is up to you, as you can see in Kimball's code above, to tell exit if there is a problem, so it can inform the parent function about the exit status.

// Useful headers
Needless to say, knowing the standard C library is mandatory if you want to get serious with C development on Linux. So here are a few other headers that offer facilities related to I/O and more:

[1] string.h
This header will prove very helpful when working with string conversions (strto*()), comparing strings (strcmp()) or checking a string's length (strlen()).

[2] ctype.h
Besides case conversion, ctype.h offers functions that check various properties of characters. Some of them are isalnum(), isupper(), isalpha() or isspace(), and you are invited to guess what they do and how they work.

[3] math.h
Many functions needed for more than the four basic arithmetic operations are to be found here, including sin(), cos() or exp().

// Further reading
The more experienced readers will nail me to the cross for not treating more advanced subjects like malloc() or size_t. As I repeatedly said, this series in not intended as a know-all online book for C development (there is no such thing, anyway), but rather a good starting point for beginners. I feel that the future C developer must be relatively well versed in pointers and how memory allocation works before he/she starts having malloc() nightmares. After the end of this series, you are recommended to get a in-depth book on C, after asking some opinions from the Old Ones (not H.P. Lovecraft's Old Ones, I hope), so you avoid false or misleading information. While you'll know about free() and malloc() until we finish, it's probably best to get a printed book and sleep with it under your pillow.

//------------------------------------------
//	topic: C development on Linux - Coding style and recommendations - IX.
//	source:http://how-to.linuxcareer.com/c-development-on-linux-coding-style-and-recommendations-ix
//------------------------------------------

// Note: My style will be the Linux Kernel style, this artical talks about GNU style, so I would execulude the GNU style points

Our next issue is a technical one, and a promise I had to keep: the malloc() issue. Besides writing pertinent and meaningful error messages, unlike the ones we've all seen in other operating systems, check that malloc() and friends always return zero. These are very serious issues, and you'll get a few words lesson about malloc() and when to use it. By now you know what allocating memory automatically or statically is. But these methods don't cover all bases. When you need to allocate memory and have more control over the operation, there's malloc() and friends, for dynamic allocation. Its' purpose is to allocate available memory from the heap, then the program uses the memory via a pointer that malloc() returns, then said memory must be free()d. And "must" is to be written with capitals in 2 feet letters with a burning red color. That's about it with malloc(), and the reasons have already been exposed earlier in the previous part.

You are urged to use a consistent interface in all your command-line programs. If you're already a seasoned GNU/Linux user you have noticed that almost all programs have --version and --help, plus, for example, -v for verbose, if such is the case. We'll not get into all of it here; grab a copy of the GNU Coding Standards, you will need it anyway.

There are some that say you can't avoid nested ifs. There are others that say "why avoid nested ifs?" And there are yet others that simply do not use nested ifs. You will create your own opinion on this as time passes and lines of code you write increase. The idea is, if you use them, make them as readable as humanly possible, as they easily can lead to almost-spaghetti code, hard to read and to maintain. And again, use comments.

The GNU coding standard say that it's good to have your code be as portable as can be, "but not paramount". Portable hardware-wise? That depends on the program's purpose and what machines you have at your disposal. We are referring more to the software side, namely portability between Unix systems, open source or not. Avoid ifdefs if you can, avoid assumptions regarding file locations (e.g. Solaris installs third-party software under /opt, while BSD and GNU/Linux do not), and generally aim for clean code. Speaking of assumptions, do not even assume that a byte is eight bits or that a CPU's address space must be an even number.

Documenting your code, in form of manual pages and well-written READMEs and so on, is another paramount aspect of software development. Yes, it IS a tedious task, but if you don't have a documentation writer on your team, it's your responsibility to do it, as every good programmer does his/her job from A to Z.

//------------------------------------------
//	topic: C development on Linux - Building a program - X.
//	source: http://how-to.linuxcareer.com/c-development-on-linux-building-a-program-x 
//------------------------------------------

Besides knowing exactly what you want to achieve, you need to be familiar with the tools to achieve what you want. And there is a lot more to Linux development tools than gcc, although it alone would be enough to compile programs, but it would be a tedious task as the size of your project increases. This is why other instruments have been created, and we'll see here what they are and how to get them. I already more than suggested you read the gcc manual, so I will only presume that you did.

// make
Imagine you have a multi-file project, with lots of source files, the works. Now imagine that you have to modify one file (something minor) and add some code to another source file. It would be painful to rebuild all the project because of that. Here's why make was created: based on file timestamps, it detects which files need to be rebuilt in order to get to the desired results (executables, object files...), named targets. If the concept still looks murky, don't worry: after explaining a makefile and the general concepts, it will all seem easier, although advanced make concepts can be headache-inducing.

make has this exact name on all platforms I worked on, that being quite a lot of Linux distros, *BSD and Solaris. So regardless of what package manager you're using (if any), be it apt*, yum, zypper, pacman or emerge, just use the respective install command and make as an argument and that's it. Another approach would be, on distros with package managers that have group support, to install the whole C/C++ development group/pattern. Speaking of languages, I wanted to debunk a myth here, that says makefiles (the set of rules that make has to follow to reach the target) is only used by C/C++ developers. Wrong. Any language with a compiler/interpreter able to be invoked from the shell can use make's facilities. In fact, any project that needs dependency-based updating can use make. So an updated definition of a makefile would be a file that describes the relationships and dependencies between the files of a project, with the purpose of defining what should be updated/recompiled in case one or more files in the dependency chain changes. Understanding how make works is essential for any C developer who works under Linux or Unix - yes, commercial Unix offers make as well, although probably some version that differs from GNU make, which is our subject. "Different version" means more than numbers, it means a BSD makefile is incompatible with a GNU makefile. So make sure you have GNU make installed if you're not on a Linux box.

In the first part of this article, and some subsequent ones, we used and talked about parts of yest, a small program that displays yesterday's date by default, but does a lot of nifty date/time-related things. After working with the author, Kimball Hawkins, a small makefile was born, which is what we'll be working with.

First, let's see some basics about the makefile. The canonical name should be GNUmakefile, but if no such file exists it looks for names like makefile and Makefile, in that order, or so the manual page says. By the way, of course you should read it, and read it again, then read it some more. It's not as big as gcc's and you can learn a lot of useful tricks that will be useful later. The most used name in practice, though, is Makefile, and I have never seen any source with a file named GNUmakefile, truth be told. If, for various reasons, you need to specify another name, use make's -f, like this:

	$ make -f mymakefile 

Here's yest's Makefile, that you can use to compile and install said program, because it's not uploaded of Sourceforge yet. Although it's only two-file program - the source and the manpage - you will see make becomes useful already.

	# Makefile for compiling and installing yest

	UNAME := $(shell uname -s)
	CC = gcc
	CFLAGS = -Wall
	CP = cp
	RM = rm
	RMFLAGS = -f
	GZIP = gzip
	VERSION = yest-2.7.0.5

	yest:
	ifeq ($(UNAME), SunOS)
		$(CC) -DSUNOS $(CFLAGS) -o yest $(VERSION).c
	else
		$(CC) $(CFLAGS) -o yest $(VERSION).c
	endif

	all: yest install maninstall

	install: maninstall
		$(CP) yest /usr/local/bin

	maninstall:
		$(CP) $(VERSION).man1 yest.1
		$(GZIP) yest.1
		$(CP) yest.1.gz /usr/share/man/man1/

	clean:
		$(RM) $(RMFLAGS) yest yest.1.gz

	deinstall:
		$(RM) $(RMFLAGS) /usr/local/bin/yest /usr/share/man/man1/yest1.gz

If you look carefully at the code above, you will already observe and learn a number of things. Comments begin with hashes, and since makefiles can become quite cryptic, you better comment your makefiles. Second, you can declare your own variables, and then you can make good use of them. Next comes the essential part: targets. Those words that are followed by a colon are called targets, and one use them like make [-f makefile name] target_name. If you ever installed from source, you probably typed 'make install'. Well, 'install' is one of the targets in the makefile, and other commonly-used targets include 'clean', 'deinstall' or 'all'. Another most important thing is that the first target is always executed by default if no target is specified. In our case, if I typed 'make', that would have been the equivalent of 'make yest', as you can see, which means conditional compilation (if we are on Solaris/SunOS we need an extra gcc flag) and creation of an executable named 'yest'. Targets like 'all' in our example are doing nothing by themselves, just tell make that they depend on other files/targets to be up to date. Watch the syntax, namely stuff like spaces and tabs, as make is pretty pretentious about things like this.

Here's a short makefile for a project that has two source files. The filenames are src1.c and src2.c and the executable's name needs to be exec. Simple, right?

	exec: src1.o src2.o
	      gcc -o exec src1.o src2.o
	      
	src1.o: src1.c
		gcc -c src1.c
		
	src2.o: src2.c
		gcc -c src2.c

The only target practically used, which is also the default, is 'exec'. It depends on src1.o and src2.o, which, in turn, depend on the respective .c files. So if you modify, say, src2.c, all you have to do is run make again, which will notice that src2.c is newer than the rest and proceed accordingly. There is much more to make than covered here, but there is no more space. As always, some self-study is encouraged, but if you only need basic functionality, the above will serve you well.

// The configure script
Usually it's not just 'make && make install', because before those two there exists a step that generates the makefile, especially useful when dealing with bigger projects. Basically, said script checks that you have the components needed for compilation installed, but also takes various arguments that help you change the destination of the installed files, and various other options (e.g. Qt4 or GTK3 support, PDF or CBR file support, and so on). Let's see in a short glance what those configure scripts are all about.

You don't usually write the configure script by hand. You use autoconf and automake for this. As the names imply, what they do is generate configure scripts and Makefiles, respectively. For example, in our previous example with the yest program, we actually could use a configure script that detects the OS environment and changes some make variables, and after all that generates a makefile. We've seen that the yest makefile checks if we're running on SunOS, and if we are, adds a compiler flag. I would expand that to check if we're working on a BSD system and if so, invoke gmake (GNU make) instead of the native make which is, as we said, incompatible with GNU makefiles. Both these things are done by using autoconf: we write a small configure.in file in which we tell autoconf what we need to check, and usually you will want to check for more than OS platform. Maybe the user has no compiler installed, no make, no development libraries that are compile-time important and so on. For example, a line that would check the existence of time.h in the system standard header locations would look like so:

	AC_CHECK_HEADERS(time.h)

We recommend you start with a not-too-big application, check the source tarball contents and read the configure.in and/or configure.ac files. For tarballs that have them, Makefile.am is also a good way to see how an automake file looks. There are a few good books on the matter, and one of them is Robert Mecklenburg's "Managing Projects with GNU Make".

// gcc tips and usual command-line flags
I know the gcc manual is big and I know many of you haven't even read it. I take pride in reading it all (all that pertains to IA hardware anyway) and I must confess. I got a headache afterwards. Then again, there are some options you should know, even though you will learn more as you go.

You have already encountered the -o flag, that tells gcc what the resulting outfile, and -c, that tells gcc not to run the linker, thus producing what the assembler spits out, namely object files. Speaking of which, there are options that control the stages at which gcc should stop execution. So to stop before the assembly stage, after the compilation per se, use -S. In the same vein, -E is to be used if you want to stop gcc right after preprocessing.

It's a good practice to follow a standard, if not for uniformity, but for good programming habits. If you're in the formative period as a C developer, choose a standard (see below) and follow it. The C language was standardized first after Kernighan and Ritchie (RIP) published "The C Programming Language" in 1978. It was a non-formal standard, but in was shortly dubbed K&R and respected. But now it's obsolete and not recommended. Later, in the '80s and the '90s, ANSI and ISO developed an official standard, C89, followed by C99 and C11. gcc also supports other standards, like gnuxx, where xx can be 89 or 99, as examples. Check the manual for details, and the option is '-std=', "enforced" by '-pedantic'.

Warnings-related options start with "-W", like '-Wall' (it tells gcc to enable all errors, although they're not quite all enabled) or '-Werror' (treat warnings as errors, always recommended). You can pass supplemental arguments to the programs that help with the intermediary steps, such as preprocessor, assembler or linker. For example, here's how to pass an option to the linker:

	 $ gcc [other options...] -Wl,option [yet another set of options...] 

Similarly and intuitively, you can use 'Wa,' for the assembler and 'Wp,' for the preprocessor. Take note of the comma and the white space that tells the compiler that the preprocessor/assembler/linker part has ended. Other useful families of options include '-g' and friends for debugging, '-O' and friends for optimization or '-Idirectory' - no white space - to add a header-containing location.

//----------------------------------
//	topic: C development on Linux - Packaging for Debian and Fedora - XI.
//	source: http://how-to.linuxcareer.com/c-development-on-linux-packaging-for-debian-and-fedora-xi
//----------------------------------

// Before we go further...
Let's get some concepts and general ideas out of the way, just so we make sure we are on the same page. What we are about to outline here is available regardless of the project you decide to package (or contribute) for, be it Arch, NetBSD or OpenSolaris. The idea is: be careful. Check the code, whether it's yours or not, and make sure you remember that perhaps lots of people will use your code. You have a responsibility on your hands, and a pretty big one at that. If you doubt this, reverse places for a second: a package maintainer isn't careful when inspecting code and some sneaky, but grave bug makes his way installed on your computer. It's sneaky, as it only manifests itself on certain hardware and in certain situations, but it's grave enough to delete all the files resident inside your home folder. You happen to have that exact combination of hardware and mayhem ensues, as you forgot to write to DVD those pictures from your holiday. You get angry, your first reaction is to manifest negative feeling towards the operating system (or distribution) and so, following your decision to change distributions immediatley, that distro loses one user, all because one person's lack of attention and thoroughness.

// Debian
Given Debian's excellent documentation, we won't be able to cover all the things one needs to become a developer. After all, this is not what we wanted. What we wanted is to show you basically how to get from a tarball to a .deb. Becoming a Debian developer takes lots of time and involves you helping out the community via IRC or mailing lists, reporting and helping fixing bugs, and so on, so that is not the object of our article. Have a look at the documentation the project provides for more insight. The Debian policy, New maintainer's guide and the Developer's reference are more than important for starting up, they must be like some kind of a book you sleep under the pillow with.

Your first stop should be, as outlined above, the policy, where you MUST acquaint yourself with the filesystem hierarchy, the archives, the fields in a control file and specific items to be remembered regarding diferent categories of software: binaries, libraries, source, games, documentation, ... Remember that a .deb file is nothing more than an archive, and it's made of two parts: the control part, with the control file and the install/ uninstall scripts, and the payload, where the files to be installed reside. It's not as hard as one would think it is. It's a very good idea that you download a .deb file, even better if it's packing some software you are familiar with, and start looking inside to see what's what. [HINT] - You can use the control file to create your own, as long as you're careful. As an example, let's take vim. deb files are nothing but ar(1) archives, so they can simply be unpacked by using the following command:

	$ ar vx vim-nox_7.3.547-5_amd64.deb

Of course, v stands for verbose, and x stands for extract. After this operation, we will see three files: control.tar.gz, data.tar.xz and a small text file called debian-binary, which is nothing more but a file telling dpkg, the Debian package manager, what binary format is used. But that is of no interest for the time being. Nor is the data archive, which consists of the files that are to be unpacked on your system: the binary, manual pages, libraries, and so on, depending on the software we are talking about. The control archive is of utmost importance here. If you unpack it, you will see the essential file, named control, the md5sums of the files to be installed, and two scripts, one that takes care of the post installation issues, and the other that takes care of pre-removal. Since we had yest as a software example, let's take it and see how the control file would look. It is up to you to decide, dear reader, if yest needs those two scripts and if so, how should they be altered. So here's a control file, taken from vim-nox and modified for yest.

	Package: yest
	Source: yest
	Version: 2.7.0.5
	Architecture: amd64
	Maintainer: Rares Aioanei 
	Installed-Size: 40355
	Depends: libc6 (>= 2.11)
	Suggests: 
	Provides: yest
	Section: other
	Priority: normal
	Homepage: sourceforge.net/projects/yest
	Description: This is a command line date/time manipulation and formatting program, very useful in scripts. You can easily add or subtract days, hours and/or minutes from a specified date. Supports all date(1) output formats plus more.

There you go, folks. Do you think there is anything else you need to create a package? Check if all your files are in place, then you can use a more old-school method, especially since the software is small and simple and un-quirksome, if such words exist.

	 $ dpkg -b yestdir yest.deb

Now, a lot of folks will tell me, and I can't wait, of course, that this is an old method of doing stuff and so on. And they're right. I suggest looking through the dpkg-buildpackage manual page, as well as lintian for checking the quality of your .deb, and remember to do this before you start anything, so you can make sure you have it all installed:

	 # apt-get install build-essential autoconf automake autotools-dev dh-make debhelper devscripts fakeroot xutils lintian pbuilder

// Fedora
In my opinion, Fedora/Red Hat makes it easier for people to package for them compared to Debian and derivatives. That being said, easier doesn't always mean better, at least in the IT world. You will be able to make an educated opinion after this article, we hope.

Again, make sure you have all the tools installed, which can be done by typing this:

	# yum install @development-tools fedora-packager

Now create a user named makerpm, make sure that he is in the mock group and assign a password:

	 # useradd -m -G mock makerpm && passwd makerpm

Log in as that user and issue the command

	$ rpmdev-setuptree

in the home directory. You will see, after the command exits, a new directory structure named rpmbuild. Take some time to examine it and figure out the purposes of each directory and file. Now, just as Debian makes use of control files, Fedora uses specfiles. They are called like so because they have the .spec extension, so the user knows it specifies the parameters of package building: version, name, author, maintainer, depends, and so on. Anyways, I am getting ahead of myself. Let's start just like we did before and download a source package (again vim, for consistency) to see where's where. For that one needs to install the yum-utils package, which offers yumdownloader:

	$ yumdownloader --source vim-enhanced

Now, to install into ~/rpmbuild, we type

	 $ rpm -ivh vim-enhanced[...].src.rpm

Remember that an RPM file is an archive, just as .deb files are. The difference is the format: while Debian uses ar, Fedora/RH uses cpio as the format of choice. Knowing this, what would be the method to use for manually unpacking .rpms?

You may have noticed there is a directory named SPECS in your ~/rpmbuild. cd to it and create a file using vim or emacs, a file named yest.spec. You will be pleasantly surprised to find that those two editors are modified by Fedora in such a way so that they offer you a "skeleton" of a specfile (as long as the file you want to create has the .spec extension), so you can just fill in the blanks. Now, your assignment is, based on the control file above and your knowledge so far, to write a complete specfile for yest and, of course, create a RPM out of it. The Fedora wiki has a detailed explanation on every section of a specfile, please read it. We will only help you with the actual building and checking of the package. In short, use yest.spec as an argument to rpmlint to check the file's compliance with the Fedora Packaging Guidelines and then, when everything proves to be in order, and after you read the rpmbuild manual, do something like this:

	$ rpmbuild -ba yest.spec

The options given to rpmbuild stand for "build all", but you can also build just the source package, using -bs. Remember that Mock and Koji are two very helpful tools, and also remember that rpmlint is your ticket towards quality specfiles.

//---------------------------
//	topic: C development on Linux - Getting a package in the official Debian repositories - XII.
//	source: http://how-to.linuxcareer.com/c-development-on-linux-getting-a-package-in-the-official-debian-repositories-xii
//---------------------------

This is the last installment of our C development series, and arguably the most non-technical one. If you followed us from the beginning and practiced as much as possible, you now have some basic knowledge on C development and how to package your (favorite) application for two of the most used Linux distribution families, Debian and Redhat. This article is about the community, how to contribute, how to collaborate and finally, how to get your package in the official Debian archives. If you read the previous articles in the series you won't need any other technical knowledge; all you need is the will to put your knowledge to work for community's benefit.

// Getting started
You have an application, you packaged it and now you're anxious to upload it to the Debian archives (by the way, many of the ideas presented here apply to many Open Source projects: what differs usually is the way of doing things). We'd say not so fast. Take a minute to breathe and find ways to make yourself known to the community. Take some time to read the Debian New Maintainer's Guide, if you haven't already, and remember the key word here: community. Everyone is a volunteer, and we chose Debian especially because of its democratic views, and nobody is paid or forced in any way to do your bidding. Anyway, since we know how much you like to read guides and manuals, part of this article will consist of some sane advice regarding collaboration. First, get used to get by on your own. Nobody likes a person that, when he or she hits the first sign of trouble, instead of going to the best Internet friend, $SEARCH_ENGINE, start polluting the forums, mailing lists and IRC channels with puerile questions like "What gcc flags do I need to compile my code for i686?". The only thing you will gain is a less than friendly RTFM and lots of missing geek points. Yes, we know that the gcc manual is big and a sure shot for headaches, but reading the manual, then searching the net first is the Right Way (TM). No exceptions. You will make a first good impression when you show the other developers that you made your homework. On the other hand, giving beginners a hard time, especially when such behavior is not called for, will not get you any popularity. Remember that you were once like them, remember that you, as we all, still have a lot to learn, and perhaps point the person towards a resource you think is helpful. In this context, remember that word again: community. Your work doesn't mean much, despite the fact that it means the world to you, unless the community finds it useful. Collaborate with them and be ready to accept feedback, and be thankful for it, even though you might not like what you hear. Leave your pride at the door and remember that the best and maybe only way to make your software better is community feedback. But don't fall into extremes, and try to be impartial. Perhaps some people will try to put you down just for the fun of it: ignore them and concentrate on constructive criticism.

// Tools of the trade
The first tool you will ever need as a Debian developer, or any other distro/project for that matter, is patience. It doesn't really matter if it's your own software you're packaging, or someone else's, as we did with yest. One doesn't become a developer over night, especially in a quality-oriented project as Debian. Now, to get into the practical side of things, the first and most obvious tool you need is the compiler for the language your program is written in. Or, if the program is written in some interpreted language, make sure the interpreter (Perl, Python, Ruby...) is there as a dependency. We, however, will concentrate on the C side, as this is after all a C development article series, and will give you a non-exhaustive list of utilities you better have installed on your development machine:

	auto* tools (autoconf, automake, ...)
	debhelper and dh-make -- Debian-specific
	devscripts, fakeroot -- same, see the Guide for details
	a VCS of your choice, depending on the situation at hand -- we prefer to take no sides here
	gnupg -- for digitally signing your packages, mandatory in Debian
	lintian -- the name is a combination of lint and Debian, so it's self-explanatory
	patch - you should know by know why you'd need it
	pbuilder -- for creating a chroot

If you were careful, you would have noticed that we omitted an important utility in that list. Can you spot it?

// Documentation
Debian recommends two documents. In fact, no. Debian recommends the two documents, but we say it's essential you read them more than once and keep them handy at all times. Those are the Debian Policy and the Developers Reference, both available via Web and as packages. Also the GNU Coding Standards should be at hand when you need it, especially when/if you're writing the application yourself.

// Upstream
Since we're focusing on yest as the primary example for this series, it's easy to figure out that we're just packagers, not primary developers, so we need to keep contact with upstream. The rules of communication outlined above apply, of course, and close collaboration with upstream makes for a healthy package that gets updated promptly as soon as the author uploads the new version. Although said author probably tested the software before releasing it into the wild, if you do some unit testing for yourself before uploading the package, even better. Take a look at tools like DejaGNU for this and report any issues found to upstream. Speaking of reporting, you must understand the responsibility you're taking upon yourself when becoming maintainer. ALL bug reports from Debian users will come to you, and it's your duty to act as a catalyst between the users and upstream in order to fix all issues.

// The mentor
Many of you, especially the older ones like me, have seen the Karate Kid series. If anything, that movie shows a relationship between a master and an apprentice (OK, you can use Star Wars as an example as well...). If you think that you ask to become a developer and your wish is granted in minutes, you forgot about patience. No, you need to ask for mentoring first, showing your accomplishments, your motivations and so on. After a while, after you've proven worthy, you will submit an application to become a maintainer, with the mentor vouching for you.

// Uploading
You're almost there, all you have to do is perform the upload proper. If you've come this far, you can already pat yourself on the back. Now, the application you need is called dupload(1), and you should create a file named dupload.conf(5) in your home directory and start modifying settings. You can, if the manual page of the file seems scary, take /etc/dupload.conf as an example. After saving ~/dupload.conf, you can do something like this:

	 $ dupload yest-2.7.0.5_i386.changes

Now, it's left as an exercise to the reader to find out what else must be done when uploading a package for the first time. Also, chapter 9 of the Debian New Maintainer's Guide should be read and read again and then some more.
