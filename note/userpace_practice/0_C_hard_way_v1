// 

//-------------------------------------
// source: http://c.learncodethehardway.org/
// source: http://c.learncodethehardway.org/book/
// -------------------------------------

//-----------------------------------------
//	topic: Exercise 0: The Setup
//	source: http://c.learncodethehardway.org/book/ex0.html
//-----------------------------------------

// system setups before developing in C:
	$ sudo apt-get install build-essential	# ubuntu or Debian-base systems
// or
	$ su -c "yum groupinstall development-tools" # for  RPM based Linux like Fedora

// using nano flages
source: http://www.nano-editor.org/dist/v2.2/nano.html

	[1] -c, --const
	Constantly display the cursor position and line number on the statusbar. Note that this overrides -U. use -c flag for 
	displaying line number in nano

	[2] -i, --autoindent
	Automatically indent new lines to the same number of spaces and tabs as the previous line. 

	[3] -m, --mouse
	Enable mouse support, if available for your system. When enabled, mouse clicks can be used to place the cursor, set the 
	mark (with a double click), and execute shortcuts. The mouse will work in the X Window System, and on the console when 
	gpm is running. 

// for defult compling, we can use make command
// for example
	$ nano q1.c
// then write this in q1.c
	#include<stdio.h>
	#include<string.h>

	void foo(void){
	int i=0;
	char str[]="\nMy name is mohammad";
	printf("%s\n", str);
	for (; i<= strlen(str); i++)
		printf("%c", str[strlen(str)- i]);
	}

	int main ( int argc, char *argv[]){
	foo();
	return 0;
	}
// then use make command instead of gcc
	$ make q1
// terminal output
/*
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make q1
	cc     q1.c   -o q1
*/
// use the executable
	$ ./q1


// as what we can see, make command uses this syntix "cc     q1.c   -o q1", but if we need to add flages. Example:
	$ rm ex1
	$ CFLAGS="-Wall" make ex1
	cc -Wall    ex1.c   -o ex1
	ex1.c: In function 'main':
	ex1.c:3: warning: implicit declaration of function 'puts'
	$ ./ex1
	Hello world.
	$   
// read puts command
	$ man 3 puts

//-------------------------------------------------
// topic:	Exercise 2: Make Is Your Python Now
// source:	http://c.learncodethehardway.org/book/ex2.html
//-------------------------------------------------

// Note[1]: use Make as an interpreter for gcc
Make will for the rest of this book, be your Python. It will build your code, and run your tests, and set things up and do all the stuff for you that Python normally does.

// example:
	$ make ex1
	# or this one too
	$ CFLAGS="-Wall" make ex1

	In the first command you're telling make, "I want a file named ex1 to be created." Make then does the following:

	[1] Does the file ex1 exist already?
	[2] No. Ok, is there another file that starts with ex1?
	[3] Yes, it's called ex1.c. Do I know how to build .c files?
	[4] Yes, I run this command cc ex1.c   -o ex1 to build them.
	[5] I shall make you one ex1 by using cc to build it from ex1.c.

The second command in the listing above is a way to pass "modifiers" to the make command. If you're not familiar with how the Unix shell works, you can create these "environment variables" which will get picked up by programs you run. Sometimes you do this with a command like export CFLAGS="-Wall" depending on the shell you use. You can however also just put them before the command you want to run, and that environment variable will be set only while that command runs.

In this example I did CFLAGS="-Wall" make ex1 so that it would add the command line option -Wall to the cc command that make normally runs. That command line option tells the compiler cc to report all warnings (which in a sick twist of fate isn't actually all the warnings possible).

You can actually get pretty far with just that way of using make, but let's get into making a Makefile so you can understand make a little better. To start off, create a file with just this in it:

	CFLAGS=-Wall -g

	clean:
	   rm -f ex1

Save this file as Makefile in your current directory. Make automatically assumes there's a file called Makefile and will just run it. Also, WARNING: Make sure you are only entering TAB characters, not mixtures of TAB and spaces.

This Makefile is showing you some new stuff with make. First we set CFLAGS in the file so we never have to set it again, as well as adding the -g flag to get debugging. Then we have a section named clean which tells make how to clean up our little project.

Make sure it's in the same directory as your ex1.c file, and then run these commands:

	$ make clean
	$ make ex1

// note to remove all executable from the folder in make use this
	clean:
	    file * | grep ELF | awk '{print $1}' | tr ':' ' '| xargs rm

// What You Should See
If that worked then you should see this:
	$ make clean
	rm -f ex1
	$ make ex1
	cc -Wall -g    ex1.c   -o ex1
	ex1.c: In function 'main':
	ex1.c:3: warning: implicit declaration of function 'puts'
	$

Here you can see that I'm running make clean which tells make to run our clean target. Go look at the Makefile again and you'll see that under this I indent and then I put the shell commands I want make to run for me. You could put as many commands as you wanted in there, so it's a great automation tool.

Notice also that, even though we don't mention ex1 in the Makefile, make still knows how to build it plus use our special settings

That should be enough to get you started, but first let's break this make file in a particular way so you can see what happens. Take the line rm -f ex1 and dedent it (move it all the way left) so you can see what happens. Re-run make clean and you should get something like this:

	$ make clean
	Makefile:4: *** missing separator.  Stop.

Always remember to indent, and if you get weird errors like this then double check you're consistently using tab characters since some make variants are very picky.


//-------------------------------------------------
// topic:	Exercise 3: Formatted Printing
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
How to use printf. I think "man 3 printf" is better!!

//-------------------------------------------------
// topic:	Exercise 4: Introducing Valgrind
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//Def -- Valgrind: 
	[1] is a GPL licensed programming tool for memory debugging, memory leak detection, and profiling. It is named after the main entrance to Valhalla in Norse mythology. [2] Valgrind is an instrumentation framework for building dynamic analysis tools. There are Valgrind tools that can automatically detect many memory management and threading bugs, and profile your programs in detail. You can also use Valgrind to build new tools.

	The Valgrind distribution currently includes six production-quality tools: a memory error detector, two thread error detectors, a cache and branch-prediction profiler, a call-graph generating cache and branch-prediction profiler, and a heap profiler. It also includes three experimental tools: a heap/stack/global array overrun detector, a second heap profiler that examines how heap blocks are used, and a SimPoint basic block vector generator. It runs on the following platforms: X86/Linux, AMD64/Linux, ARM/Linux, PPC32/Linux, PPC64/Linux, S390X/Linux, MIPS/Linux, ARM/Android (2.3.x and later), X86/Android (4.0 and later), X86/Darwin and AMD64/Darwin (Mac OS X 10.6 and 10.7, with limited support for 10.8).


Valgrind is a program that runs your programs, and then reports on all of the horrible mistakes you made. It's a wonderful free piece of software that I use constantly while I write C code.

// installing
	$ sudo apt-get install valgrind
// note, there are valgrind's GUIs. To look for them
	$ sudo apt-cache search valgrind

// from the source-code:
You could install Valgrind with the package manager for your OS, but I want you to learn to install things from source. This involves the following process:

	[1] Download a source archive file to get the source.
	[2] Unpack the archive to extract the files onto your computer.
	[3] Run ./configure to setup build configurations.
	[4] Run make to make it build, just like you've been doing.
	[5] Run sudo make install to install it onto your computer.

Here's a script of me doing this very process, which I want you to try to replicate:

	# 1) Download it (use wget if you don't have curl)
	curl -O http://valgrind.org/downloads/valgrind-3.6.1.tar.bz2

	# use md5sum to make sure it matches the one on the site
	md5sum valgrind-3.6.1.tar.bz2

	# 2) Unpack it.
	tar -xjvf valgrind-3.6.1.tar.bz2

	# cd into the newly created directory
	cd valgrind-3.6.1

	# 3) configure it
	./configure

	# 4) make it
	make

	# 5) install it (need root)
	sudo make install

// valgrid running in ubuntu!! 
If you run valgrind and it says something like by 0x4052112: (below main) (libc-start.c:226) instead of a line number in main.c then add run your valgrind command like this valgrind --track-origins=yes ./ex4 to make it work. For some reason the Debian or Ubuntu version of valgrind does this but not other versions.

// Using Valgrind.k
Using Valgrind is easy, you just run valgrind the program and it runs your program, then prints out all the errors your program made while it was running. In this exercise we'll break down one of the error outputs and you can get an instant crash course in "Valgrind hell". Then we'll fix the program.

First, here's a purposefully broken version of the ex3.c code for you to build, now called ex4.c. For practice, type it in again:

	#include <stdio.h>

	/* Warning: This program is wrong on purpose. */
	int main()
	{
	    int age = 10;
	    int height;

	    printf("I am %d years old.\n");
	    printf("I am %d inches tall.\n", height);

	    return 0;
	}

You'll see it's the same except I've made two classic mistakes:
[1] I've failed to initialize the height variable.
[2] I've forgot to give the first printf the age variable.

Now we will build this just like normal, but instead of running it directly, we'll run it with Valgrind:

	$ make ex4
	cc -Wall -g    ex4.c   -o ex4
	ex4.c: In function 'main':
	ex4.c:10: warning: too few arguments for format
	ex4.c:7: warning: unused variable 'age'
	ex4.c:11: warning: 'height' is used uninitialized in this function
	$ valgrind ./ex4
	==3082== Memcheck, a memory error detector
	==3082== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
	==3082== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
	==3082== Command: ./ex4
	==3082== 
	I am -16775432 years old.
	==3082== Use of uninitialised value of size 8
	==3082==    at 0x4E730EB: _itoa_word (_itoa.c:195)
	==3082==    by 0x4E743D8: vfprintf (vfprintf.c:1613)
	==3082==    by 0x4E7E6F9: printf (printf.c:35)
	==3082==    by 0x40052B: main (ex4.c:11)
	==3082== 
	==3082== Conditional jump or move depends on uninitialised value(s)
	==3082==    at 0x4E730F5: _itoa_word (_itoa.c:195)
	==3082==    by 0x4E743D8: vfprintf (vfprintf.c:1613)
	==3082==    by 0x4E7E6F9: printf (printf.c:35)
	==3082==    by 0x40052B: main (ex4.c:11)
	==3082== 
	==3082== Conditional jump or move depends on uninitialised value(s)
	==3082==    at 0x4E7633B: vfprintf (vfprintf.c:1613)
	==3082==    by 0x4E7E6F9: printf (printf.c:35)
	==3082==    by 0x40052B: main (ex4.c:11)
	==3082== 
	==3082== Conditional jump or move depends on uninitialised value(s)
	==3082==    at 0x4E744C6: vfprintf (vfprintf.c:1613)
	==3082==    by 0x4E7E6F9: printf (printf.c:35)
	==3082==    by 0x40052B: main (ex4.c:11)
	==3082== 
	I am 0 inches tall.
	==3082== 
	==3082== HEAP SUMMARY:
	==3082==     in use at exit: 0 bytes in 0 blocks
	==3082==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
	==3082== 
	==3082== All heap blocks were freed -- no leaks are possible
	==3082== 
	==3082== For counts of detected and suppressed errors, rerun with: -v
	==3082== Use --track-origins=yes to see where uninitialised values come from
	==3082== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 4 from 4)
	$

// analyzing above activity
This one is huge because Valgrind is telling you exactly where every problem in your program is. Starting at the top here's what you're reading, line by line (line numbers are on the left so you can follow):

1
	You do the usual make ex4 and that builds it. Make sure the cc command you see is the same and has the -g option or your 
	Valgrind output won't have line numbers.
2-6
	Notice that the compiler is also yelling at you about this source file and it warns you that you have "too few arguments for format". That's where you forgot to include the age variable.
7
	Then you run your program using valgrind ./ex4.
8
	Then Valgrind goes crazy and yells at you for:

14-18
	On line main (ex4.c:11) (read as "in the main function in file ex4.c at line 11) you have "Use of uninitialised value of 
	size 8". You find this by looking at the error, then you see what's called a "stack trace" right under that. The line to 
	look at first (ex4.c:11) is the bottom one, and if you don't see what's going wrong then you go up, so you'd try 
	printf.c:35. Typically it's the bottom most line that matters (in this case, on line 18).
20-24
	Next error is yet another one on line ex4.c:11 in the main function. Valgrind hates this line. This error says that some 
	kind of if-statement or while-loop happened that was based on an uninitialized variable, in this case height.
25-35
	The remaining errors are more of the same because the variable keeps getting used.
37-46
	Finally the program exits and Valgrind tells you a summary of how bad your program is.

That is quite a lot of information to take in, but here's how you deal with it:
[1] Whenever you run your C code and get it working, rerun it under Valgrind to check it.
[2] For each error that you get, go to the source:line indicated and fix it. You may have to search online for the error message to figure out what it means.
[3] Once your program is "Valgrind pure" then it should be good, and you have probably learned something about how you write code.


//-------------------------------------------------
// topic:	Exercise 5: The Structure Of A C Program
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
Just explaing each part of C such as: main function, #include, and so on...

//-------------------------------------------------
// topic:	Exercise 6: Types Of Variables
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

You should be getting a grasp of how a simple C program is structured, so let's do the next simplest thing which is making some variables of different types:

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    int distance = 100;
	    float power = 2.345f;
	    double super_power = 56789.4532;
	    char initial = 'A';
	    char first_name[] = "Zed";
	    char last_name[] = "Shaw";

	    printf("You are %d miles away.\n", distance);
	    printf("You have %f levels of power.\n", power);
	    printf("You have %f awesome super powers.\n", super_power);
	    printf("I have an initial %c.\n", initial);
	    printf("I have a first name %s.\n", first_name);
	    printf("I have a last name %s.\n", last_name);
	    printf("My whole name is %s %c. %s.\n",
		    first_name, initial, last_name);

	    return 0;
	}

Your output should look like mine, and you can start to see how the format strings for C are similar to Python and other languages. They've been around for a long time.

	$ make ex6
	cc -Wall -g    ex6.c   -o ex6
	$ ./ex6
	You are 100 miles away.
	You have 2.345000 levels of power.
	You have 56789.453200 awesome super powers.
	I have an initial A.
	I have a first name Zed.
	I have a last name Shaw.
	My whole name is Zed A. Shaw.
	$

You'll notice that C makes a distinction between single-quote for char and double-quote for char[] or strings.

Extra Credit
[1] Research how many different ways you can write a number. Try octal, hexadecimal, and others you can find.
Ans: use "man 3 printf." you would find this 
/*
 o, u, x, X 	The unsigned int argument is converted to unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x 			and X)  notation.  The letters abcdef are used for x conversions; the letters ABCDEF are used for X conversions. 
		The precision, if any, gives the minimum number of digits that must appear; if the converted value requires 
		fewer digits, it is padded on the  left with zeros.  The default precision is 1.  When 0 is printed with an 
		explicit precision 0, the output is empty. */

[2] Try printing an empty string that's just "".
Ans: the compliler would not have any issue with this because for a string ends with '\0' which is NULL. So, even "" this would have '\0' in it!! So, basically, ""  is not empty because it has '\0'  

//-------------------------------------------------
// topic:	Exercise 7: More Variables, Some Math
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

Let's get familiar with more things you can do with variables by declaring various ints, floats, chars, and doubles. We'll then use these in various math expressions so you get introduced to C's basic math.

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    int bugs = 100;
	    double bug_rate = 1.2;

	    printf("You have %d bugs at the imaginary rate of %f.\n",
		    bugs, bug_rate);

	    long universe_of_defects = 1L * 1024L * 1024L * 1024L;
	    printf("The entire universe has %ld bugs.\n",
		    universe_of_defects);

	    double expected_bugs = bugs * bug_rate;
	    printf("You are expected to have %f bugs.\n",
		    expected_bugs);

	    double part_of_universe = expected_bugs / universe_of_defects;
	    printf("That is only a %e portion of the universe.\n",
		    part_of_universe);

	    // this makes no sense, just a demo of something weird
	    char nul_byte = '\0';
	    int care_percentage = bugs * nul_byte;
	    printf("Which means you should care %d%%.\n",
		    care_percentage);

	    return 0;
	}

// output result
	$ make ex7
	cc -Wall -g    ex7.c   -o ex7
	$ ./ex7
	You have 100 bugs at the imaginary rate of 1.200000.
	The entire universe has 1073741824 bugs.
	You are expected to have 120.000000 bugs.
	That is only a 1.117587e-07 portion of the universe.
	Which means you should care 0%.
	$

// analyzing the code
	ex7.c:1-4
	The usual start of a C program.
	ex7.c:5-6
	Declare an int and double for some fake bug data.
	ex7.c:8-9
	Print out those two, so nothing new here.
	ex7.c:11
	Declare a huge number using a new type long for storing big numbers.
	ex7.c:12-13
	Print out that number using %ld which adds a modifier to the usual %d. Adding 'l' (the letter ell) means "print this as a long decimal".
	ex7.c:15-17
	Just more math and printing.
	ex7.c:19-21
	Craft up a depiction of your bug rate compared to the bugs in the universe, which is a completely inaccurate calculation. It's so small though that we have to use %e to print it in scientific notation.
	ex7.c:24
	Make a character, with a special syntax '\0' which creates a 'nul byte' character. This is effectively the number 0.
	ex7.c:25
	Multiply bugs by this character, which produces 0 for how much you should care. This demonstrates an ugly hack you find sometimes.
	ex7.c:26-27
	Print that out, and notice I've got a %% (two percent chars) so I can print a '%' (percent) character.
	ex7.c:28-30
	The end of the main function.

//-------------------------------------------------
// topic:	Exercise 8: Sizes And Arrays
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

In the last exercise you did math, but with a '\0' (nul) character. This may be odd coming from other languages, since they try to treat "strings" and "byte arrays" as different beasts. C however treats strings as just arrays of bytes, and it's only the different printing functions that know there's a difference.

Before I can really explain the significance of this, I have to introduce a few more concepts: sizeof and arrays. Here's the code we'll be talking about:

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    int areas[] = {10, 12, 13, 14, 20};
	    char name[] = "Zed";
	    char full_name[] = {
		'Z', 'e', 'd',
		 ' ', 'A', '.', ' ',
		 'S', 'h', 'a', 'w', '\0'
	    };

	    // WARNING: On some systems you may have to change the
	    // %ld in this code to a %u since it will use unsigned ints
	    printf("The size of an int: %ld\n", sizeof(int));
	    printf("The size of areas (int[]): %ld\n",
		    sizeof(areas));
	    printf("The number of ints in areas: %ld\n",
		    sizeof(areas) / sizeof(int));
	    printf("The first area is %d, the 2nd %d.\n",
		    areas[0], areas[1]);

	    printf("The size of a char: %ld\n", sizeof(char));
	    printf("The size of name (char[]): %ld\n",
		    sizeof(name));
	    printf("The number of chars: %ld\n",
		    sizeof(name) / sizeof(char));

	    printf("The size of full_name (char[]): %ld\n",
		    sizeof(full_name));
	    printf("The number of chars: %ld\n",
		    sizeof(full_name) / sizeof(char));

	    printf("name=\"%s\" and full_name=\"%s\"\n",
		    name, full_name);

	    return 0;
	}

// compling and running it
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make q1
	cc     q1.c   -o q1
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q1 
	The size of an int: 4
	The size of areas (int[]): 20
	The number of ints in areas: 5
	The first area is 10, the 2nd 12.
	The size of a char: 1
	The size of name (char[]): 4
	The number of chars: 4
	The size of full_name (char[]): 12
	The number of chars: 12
	name="Zed" and full_name="Zed A. Shaw"

//-------------------------------------------------
// topic:	Exercise 9: Arrays And Strings
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In the last exercise you went through an introduction to creating basic arrays and how they map to strings. In this exercise we'll more completely show the similarity between arrays and strings, and get into more about memory layouts.

This exercise shows you that C stores its strings simply as an array of bytes, terminated with the '\0' (nul) byte. You probably clued into this in the last exercise since we did it manually. Here's how we do it in another way to make it even more clear by comparing it to an array of numbers:

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    int numbers[4] = {0};
	    char name[4] = {'a'};

	    // first, print them out raw
	    printf("numbers: %d %d %d %d\n",
		    numbers[0], numbers[1],
		    numbers[2], numbers[3]);

	    printf("name each: %c %c %c %c\n",
		    name[0], name[1],
		    name[2], name[3]);

	    printf("name: %s\n", name);

	    // setup the numbers
	    numbers[0] = 1;
	    numbers[1] = 2;
	    numbers[2] = 3;
	    numbers[3] = 4;

	    // setup the name
	    name[0] = 'Z';
	    name[1] = 'e';
	    name[2] = 'd';
	    name[3] = '\0';

	    // then print them out initialized
	    printf("numbers: %d %d %d %d\n",
		    numbers[0], numbers[1],
		    numbers[2], numbers[3]);

	    printf("name each: %c %c %c %c\n",
		    name[0], name[1],
		    name[2], name[3]);

	    // print the name like a string
	    printf("name: %s\n", name);

	    // another way to use name
	    char *another = "Zed";

	    printf("another: %s\n", another);

	    printf("another each: %c %c %c %c\n",
		    another[0], another[1],
		    another[2], another[3]);

	    return 0;
	}

// output

	$ make ex9
	cc -Wall -g    ex9.c   -o ex9
	$ ./ex9
	numbers: 0 0 0 0
	name each: a   
	name: a
	numbers: 1 2 3 4
	name each: Z e d 
	name: Zed
	another: Zed
	another each: Z e d
	$

You'll notice some interesting things about this program:

[1] I didn't have to give all 4 elements of the arrays to initialize them. This is a short-cut that C has where, if you set just one element, it'll fill the rest in with 0.
[2] When each element of numbers is printed they all come out as 0.
[3] When each element of name is printed, only the first element 'a' shows up because the '\0' character is special and won't display.
[4] Then the first time we print name it only prints "a" because, since the array will be filled with 0 after the first 'a' in the initializer, then the string is correctly terminated by a '\0' character.
[5] We then setup the arrays with a tedious manual assignment to each thing and print them out again. Look at how they changed. Now the numbers are set, but see how the name string prints my name correctly?
[6] There's also two syntaxes for doing a string: char name[4] = {'a'} on line 6 vs. char *another = "name" on line 44. The first one is less common and the second is what you should use for string literals like this.

Notice that I'm using the same syntax and style of code to interact with both an array of integers and an array of characters, but that printf thinks that the name is just a string. Again, this is because to the C language there's no difference between a string and an array of characters.

Finally, when you make string literals you should usually use the char *another = "Literal" syntax. This works out to be the same thing, but it's more idiomatic and easier to write.

// warning
The source of almost all bugs in C come from forgetting to have enough space, or forgetting to put a '\0' at the end of a string. In fact it's so common and hard to get right that the majority of good C code just doesn't use C style strings. In later exercises we'll actually learn how to avoid C strings completely.

In this program the key to breaking it is to forget to put the '\0' character at the end of the strings. There's a few ways to do this:

[1] Get rid of the initializers that setup name.
[2] Accidentally set name[3] = 'A'; so that there's no terminator.
[3] Set the initializer to {'a','a','a','a'} so there's too many 'a' characters and no space for the '\0' terminator.

Try to come up with some other ways to break this, and as usual run all of these under Valgrind so you can see exactly what is going on and what the errors are called. Sometimes you'll make these mistakes and even Valgrind can't find them, but try moving where you declare the variables to see if you get the error. This is part of the voodoo of C, that sometimes just where the variable is located changes the bug.

//-------------------------------------------------
// topic:	Exercise 10: Arrays Of Strings, Looping
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
You can make an array of various types, and have the idea down that a "string" and an "array of bytes" are the same thing. The next thing is to take this one step further and do an array that has strings in it. We'll also introduce your first looping construct, the for-loop to help print out this new data structure.

The fun part of this is that there's been an array of strings hiding in your programs for a while now, the char *argv[] in the main function arguments. Here's code that will print out any command line arguments you pass it:

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    int i = 0;

	    // go through each string in argv
	    // why am I skipping argv[0]?
	    for(i = 1; i < argc; i++) {
		printf("arg %d: %s\n", i, argv[i]);
	    }

	    // let's make our own array of strings
	    char *states[] = {
		"California", "Oregon",
		"Washington", "Texas"
	    };
	    int num_states = 4;  // you can use strlen( *states) instead of hard-coded

	    for(i = 0; i < num_states; i++) {
		printf("state %d: %s\n", i, states[i]);
	    }

	    return 0;
	}

// output result
To play with this program you have to run it two ways. The first way is to pass in some command line arguments so that argc and argv get set. The second is to run it with no arguments so you can see that the first for-loop doesn't run since i < argc will be false.

	$ make ex10
	cc -Wall -g    ex10.c   -o ex10
	$ ./ex10 i am a bunch of arguments
	arg 1: i
	arg 2: am
	arg 3: a
	arg 4: bunch
	arg 5: of
	arg 6: arguments
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas
	$
	$ ./ex10
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas
	$

// Understanding Arrays Of Strings. Note: it is also called poniter of arrays
From this you should be able to figure out that in C you make an "array of strings" by combining the char *str = "blah" syntax with the char str[] = {'b','l','a','h'} syntax to construct a 2-dimensional array. The syntax char *states[] = {...} on line 14 is this 2-dimension combination, with each string being one element, and each character in the string being another.

//-------------------------------------------------
// topic:	Exercise 11: While-Loop And Boolean Expressions
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In C, there's not really a "boolean" type, and instead any integer that's 0 is "false" and otherwise it's "true". In the last exercise the expression i < argc actually resulted in 1 or 0, not an explicit True or False like in Python. This is another example of C being closer to how a computer works, because to a computer truth values are just integers.

Now you'll take and implement the same program from the last exercise but use a while-loop instead. This will let you compare the two so you can see how one is related to another.

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    // go through each string in argv
	    int i = 0;
	    while(i < argc) {
		printf("arg %d: %s\n", i, argv[i]);
		i++;
	    }

	    // let's make our own array of strings
	    char *states[] = {
		"California", "Oregon",
		"Washington", "Texas"
	    };

	    int num_states = 4;
	    i = 0;  // watch for this
	    while(i < num_states) {
		printf("state %d: %s\n", i, states[i]);
		i++;
	    }

	    return 0;
	}

You can see from this that a while-loop is simpler:
	while(TEST) {
	    CODE;
	}

It simply runs the CODE as long as TEST is true (1). This means that to replicate how the for-loop works we need to do our own initializing and incrementing of i.

// The output is basically the same, so I just did it a little different so you can see another way it runs.
	$ make ex11
	cc -Wall -g    ex11.c   -o ex11
	$ ./ex11
	arg 0: ./ex11
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas
	$
	$ ./ex11 test it
	arg 0: ./ex11
	arg 1: test
	arg 2: it
	state 0: California
	state 1: Oregon
	state 2: Washington
	state 3: Texas

// Note:
In your own code you should favor for-loop constructs over while-loop because a for-loop is harder to break. Here's a few common ways:

Forget to initialize the first int i; so have it loop wrong.
Forget to initialize the second loop's i so that it retains the value from the end of the first loop. Now your second loop might or might not run.
Forget to do a i++ increment at the end of the loop and you get a "forever loop", one of the dreaded problems of the first decade or two of programming.

//-------------------------------------------------
// topic:	Exercise 12: If, Else-If, Else
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

// Example: code that uses an if-statement to make sure you enter only 1 or 2 arguments:
	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    int i = 0;

	    if(argc == 1) {
		printf("You only have one argument. You suck.\n");
	    } else if(argc > 1 && argc < 4) {
		printf("Here's your arguments:\n");

		for(i = 0; i < argc; i++) {
		    printf("%s ", argv[i]);
		}
		printf("\n");
	    } else {
		printf("You have too many arguments. You suck.\n");
	    }

	    return 0;
	}

// output result
	$ make ex12
	cc -Wall -g    ex12.c   -o ex12
	$ ./ex12
	You only have one argument. You suck.
	$ ./ex12 one
	Here's your arguments:
	./ex12 one 
	$ ./ex12 one two
	Here's your arguments:
	./ex12 one two 
	$ ./ex12 one two three
	You have too many arguments. You suck.
	$

//-------------------------------------------------
// topic:	Exercise 13: Switch Statement
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In other languages like Ruby you have a switch-statement that can take any expression. Some languages like Python just don't have a switch-statement since an if-statement with boolean expressions is about the same thing. For these languages, switch-statements are more alternatives to if-statements and work the same internally.

The switch-statement is actually entirely different and is really a "jump table". Instead of random boolean expressions, you can only put expressions that result in integers, and these integers are used to calculate jumps from the top of the switch to the part that matches that value. Here's some code that we'll break down to understand this concept of "jump tables":

	#include <stdio.h>

	int main(int argc, char *argv[])
	{
	    if(argc != 2) {
		printf("ERROR: You need one argument.\n");
		// this is how you abort a program
		return 1;
	    }

	    int i = 0;
	    for(i = 0; argv[1][i] != '\0'; i++) {
		char letter = argv[1][i];

		switch(letter) {
		    case 'a':
		    case 'A':
		        printf("%d: 'A'\n", i);
		        break;

		    case 'e':
		    case 'E':
		        printf("%d: 'E'\n", i);
		        break;

		    case 'i':
		    case 'I':
		        printf("%d: 'I'\n", i);
		        break;

		    case 'o':
		    case 'O':
		        printf("%d: 'O'\n", i);
		        break;

		    case 'u':
		    case 'U':
		        printf("%d: 'U'\n", i);
		        break;

		    case 'y':
		    case 'Y':
		        if(i > 2) {
		            // it's only sometimes Y
		            printf("%d: 'Y'\n", i);
		        }
		        break;

		    default:
		        printf("%d: %c is not a vowel\n", i, letter);
		}
	    }

	    return 0;
	}

In this program we take a single command line argument and print out all of the vowels in an incredibly tedious way to demonstrate a switch-statement. Here's how the switch-statement works:

[1] The compiler marks the place in the program where the switch-statement starts, let's call this location Y.
[2] It then evaluates the expression in switch(letter) to come up with a number. In this case the number will be the raw ASCII code of the letter in argv[1].
[3] The compiler has also translated each of the case blocks like case 'A': into a location in the program that is that far away. So the code under case 'A' is at Y+'A' in the program.
[4] It then does the math to figure out where Y+letter is located in the switch-statement, and if it's too far then it adjusts it to Y+default.
[5] Once it knows the location, the program "jumps" to that spot in the code, and then continues running. This is why you have break on some of the case blocks, but not others.
[6] If 'a' is entered, then it jumps to case 'a', there's no break so it "falls through" to the one right under it case 'A' which has code and a break.
[7] Finally it runs this code, hits the break then exits out of the switch-statement entirely.

// output
	$ make ex13
	cc -Wall -g    ex13.c   -o ex13
	$ ./ex13
	ERROR: You need one argument.
	$
	$ ./ex13 Zed
	0: Z is not a vowel
	1: 'E'
	2: d is not a vowel
	$
	$ ./ex13 Zed Shaw
	ERROR: You need one argument.
	$
	$ ./ex13 "Zed Shaw"
	0: Z is not a vowel
	1: 'E'
	2: d is not a vowel
	3:   is not a vowel
	4: S is not a vowel
	5: h is not a vowel
	6: 'A'
	7: w is not a vowel
	$
Remember that there's that if-statement at the top that exits with a return 1; when you don't give enough arguments. Doing a return that's not 0 is how you indicate to the OS that the program had an error. Any value that's greater than 0 can be tested for in scripts and other programs to figure out what happened.


//-------------------------------------------------
// topic:	Exercise 14: Writing And Using Functions
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
Until now you've just used functions that are part of the stdio.h header file. In this exercise you will write some functions and use some other functions.

	#include <stdio.h>
	#include <ctype.h>

	// forward declarations
	int can_print_it(char ch);
	void print_letters(char arg[]);

	void print_arguments(int argc, char *argv[])
	{
	    int i = 0;

	    for(i = 0; i < argc; i++) {
		print_letters(argv[i]);
	    }
	}

	void print_letters(char arg[])
	{
	    int i = 0;

	    for(i = 0; arg[i] != '\0'; i++) {
		char ch = arg[i];

		if(can_print_it(ch)) {
		    printf("'%c' == %d ", ch, ch);
		}
	    }

	    printf("\n");
	}

	int can_print_it(char ch)
	{
	    return isalpha(ch) || isblank(ch);
	}


	int main(int argc, char *argv[])
	{
	    print_arguments(argc, argv);
	    return 0;
	}

In this example you're creating functions to print out the characters and ASCII codes for any that are "alpha" or "blanks". Here's the breakdown:

ex14.c:2
	Include a new header file so we can gain access to isalpha and isblank.
ex14.c:5-6
	Tell C that you will be using some functions later in your program, without having to actually define them. This is a 
	"forward declaration" and it solves the chicken-and-egg problem of needing to use a function before you've defined it.
ex14.c:8-15
	Define the print_arguments which knows how to print the same array of strings that main typically gets.
ex14.c:17-30
	Define the next function print_letters that is called by print_arguments and knows how to print each of the characters 
	and their codes.
ex14.c:32-35
	Define can_print_it which simply returns the truth value (0 or 1) of isalpha(ch) || isblank(ch) back to its caller 
	print_letters.
ex14.c:38-42
	Finally main simply calls print_arguments to make the whole chain of function calls go.

// output result
	$ make ex14
	cc -Wall -g    ex14.c   -o ex14

	$ ./ex14
	'e' == 101 'x' == 120 

	$ ./ex14 hi this is cool
	'e' == 101 'x' == 120 
	'h' == 104 'i' == 105 
	't' == 116 'h' == 104 'i' == 105 's' == 115 
	'i' == 105 's' == 115 
	'c' == 99 'o' == 111 'o' == 111 'l' == 108 

	$ ./ex14 "I go 3 spaces"
	'e' == 101 'x' == 120 
	'I' == 73 ' ' == 32 'g' == 103 'o' == 111 ' ' == 32 ' ' == 32 's' == 115 'p' == 112 'a' == 97 'c' == 99 'e' == 101 's' == 115 
	$

// note
The isalpha and isblank do all the work of figuring out if the given character is a letter or a blank. When I do the last run it prints everything but the '3' character, since that is a digit.

// note [2]
Use man to lookup information on isalpha and isblank. Use the other similar functions to print out only digits or other characters.

//-------------------------------------------------
// topic:	Exercise 15: Pointers Dreaded Pointers
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
To demonstrate pointers in a way we can talk about them, I've written a frivolous program that prints a group of people's ages in three different ways:

	#incle//////////////////ude <stdio.h>

	int main(int argc, char *argv[])
	{
	    // create two arrays we care about
	    int ages[] = {23, 43, 12, 89, 2};
	    char *names[] = {
		"Alan", "Frank",
		"Mary", "John", "Lisa"
	    };

	    // safely get the size of ages
	    int count = sizeof(ages) / sizeof(int); // better style than strlen() == (sizeof(ages) / sizeof(int)) - 1
	    int i = 0;

	    // first way using indexing
	    for(i = 0; i < count; i++) {	// because of i < count then we don't need to subtrack count by 1
		printf("%s has %d years alive.\n",
		        names[i], ages[i]);
	    }

	    printf("---\n");

	    // setup the pointers to the start of the arrays
	    int *cur_age = ages;
	    char **cur_name = names;

	    // second way using pointers
	    for(i = 0; i < count; i++) {
		printf("%s is %d years old.\n",
		        *(cur_name+i), *(cur_age+i));	// good example for increamenting pointer
	    }

	    printf("---\n");

	    // third way, pointers are just arrays
	    for(i = 0; i < count; i++) {
		printf("%s is %d years old again.\n",
		        cur_name[i], cur_age[i]);	// using array notation in a pointer, what I was doing
	    }

	    printf("---\n");

	    // fourth way with pointers in a stupid complex way
	    for(cur_name = names, cur_age = ages;
		    (cur_age - ages) < count;
		    cur_name++, cur_age++)
	    {
		printf("%s lived %d years so far.\n",
		        *cur_name, *cur_age);
	    }

	    return 0;
	}

Before explaining how pointers work, let's break this program down line-by-line so you get an idea of what's going on. As you go through this detailed description, try to answer the questions for yourself on a piece of paper, then see if what you guessed was going on matches my description of pointers later.

ex15.c:6-10
	Create two arrays, ages storing some int data, and names storing an array of strings.
ex15.c:12-13
	Some variables for our for-loops later.
ex15.c:16-19
	You know this is just looping through the two arrays and printing how old each person is. This is using i to index into 
	the array.
ex15.c:24
	Create a pointer that points at ages. Notice the use of int * to create a "pointer to integer" type of pointer. That's 
	similar to char *, which is a "pointer to char", and a string is an array of chars. Seeing the similarity yet?
ex15.c:25
	Create a pointer that points at names. A char * is already a "pointer to char", so that's just a string. You however 
	need 2 levels, since names is 2-dimensional, that means you need char ** for a "pointer to (a pointer to char)" type. 
	Study that too, explain it to yourself.
ex15.c:28-31
	Loop through ages and names but instead use the pointers plus an offset of i. Writing *(cur_name+i) is the same as 
	writing name[i], and you read it as "the value of (pointer cur_name plus i)".
ex15.c:35-39
	This shows how the syntax to access an element of an array is the same for a pointer and an array.
ex15.c:44-50
	Another admittedly insane loop that does the same thing as the other two, but instead it uses various pointer arithmetic 
	methods:
ex15.c:44
	Initialize our for-loop by setting cur_name and cur_age to the beginning of the names and ages arrays.
ex15.c:45
	The test portion of the for-loop then compares the distance of the pointer cur_age from the start of ages. Why does that 
	work?
ex15.c:46
	The increment part of the for-loop then increments both cur_name and cur_age so that they point at the next element of 
	the name and age arrays.
ex15.c:48-49
	The pointers cur_name and cur_age are now pointing at one element of the arrays they work on, and we can print them out 
	using just *cur_name and *cur_age, which means "the value of wherever cur_name is pointing".

// result output
	$ make ex15
	cc -Wall -g    ex15.c   -o ex15
	$ ./ex15
	Alan has 23 years alive.
	Frank has 43 years alive.
	Mary has 12 years alive.
	John has 89 years alive.
	Lisa has 2 years alive.
	---
	Alan is 23 years old.
	Frank is 43 years old.
	Mary is 12 years old.
	John is 89 years old.
	Lisa is 2 years old.
	---
	Alan is 23 years old again.
	Frank is 43 years old again.
	Mary is 12 years old again.
	John is 89 years old again.
	Lisa is 2 years old again.
	---
	Alan lived 23 years so far.
	Frank lived 43 years so far.
	Mary lived 12 years so far.
	John lived 89 years so far.
	Lisa lived 2 years so far.
	$

// Explaining Pointers example!!
When you type something like ages[i] you are "indexing" into the array ages, and you're using the number that's held in i to do it. If i is set to 0 then it's the same as typing ages[0]. We've been calling this number i an "index" since it's a location inside ages that we want. It could also be called an "address", that's a way of saying "I want the integer in ages that is at address i".

If i is an index, then what's ages? To C ages is a location in the computer's memory where all of these integers start. It is also an address, and the C compiler will replace anywhere you type ages with the address of the very first integer in ages. Another way to think of ages is it's the "address of the first integer in ages". But, the trick is ages is an address inside the entire computer. It's not like i which was just an address inside ages. The ages array name is actually an address in the computer.

That leads to a certain realization: C thinks your whole computer is one massive array of bytes. Obviously this isn't very useful, but then C layers on top of this massive array of bytes the concept of types and sizes of those types. You already saw how this worked in previous exercises, but now you can start to get an idea that C is somehow doing the following with your arrays:
	[1] Creating a block of memory inside your computer.
	[2] "Pointing" the name ages at the beginning of that block.
	[3] "Indexing" into the block by taking the base address of ages and getting the element that's i away from there.
	[4] Converting that address at ages+i into a valid int of the right size, such that the index works to return what you 
	want: the int at index i.

If you can take a base address, like ages, and then "add" to it with another address like i to produce a new address, then can you just make something that points right at this location all the time? Yes, and that thing is called a "pointer". This is what the pointers cur_age and cur_name are doing. They are variables pointing at the location where ages and names live in your computer's memory. The example program is then moving them around or doing math on them to get values out of the memory. In one instance, they just add i to cur_age, which is the same as what it does with array[i]. In the last for-loop though these two pointers are being moved on their own, without i to help out. In that loop, the pointers are treated like a combination of array and integer offset rolled into one.

A pointer is simply an address pointing somewhere inside the computer's memory, with a type specifier so you get the right size of data with it. It is kind of like a combined ages and i rolled into one data type. C knows where pointers are pointing, knows the data type they point at, the size of those types, and how to get the data for you. Just like i you can increment them, decrement them, subtract or add to them. But, just like ages you can also get values out with them, put new values in, and all the array operations.

The purpose of a pointer is to let you manually index into blocks or memory when an array won't do it right. In almost all other cases you actually want to use an array. But, there are times when you have to work with a raw block of memory and that's where a pointer comes in. A pointer gives you raw, direct access to a block of memory so you can work with it.

The final thing to grasp at this stage is that you can use either syntax for most array or pointer operations. You can take a pointer to something, but use the array syntax for accessing it. You can take an array and do pointer arithmetic with it.

// Note: Practical Pointer Usage
There are four primary useful things you do with pointers in C code:
[1] Ask the OS for a chunk of memory and use a pointer to work with it. This includes strings and something you haven't seen yet, structs.
[2] Passing large blocks of memory (like large structs) to functions with a pointer so you don't have to pass the whole thing to them.
[3] Taking the address of a function so you can use it as a dynamic callback.
[4] Complex scanning of chunks of memory such as converting bytes off a network socket into data structures or parsing files.

// Def
parse (v): <Computers> to analyze (a string of characters) in order to associate groups of characters with the syntactic units of the underlying grammar.

// using pointers vs arrays
For nearly everything else you see people use pointers, they should be using arrays. In the early days of C programming people used pointers to speed up their programs because the compilers were really bad at optimizing array usage. These days the syntax to access an array vs. a pointer are translated into the same machine code and optimized the same, so it's not as necessary. Instead, you go with arrays every time you can, and then only use pointers as a performance optimization if you absolutely have to.

// The Pointer Lexicon
// def:
Lexicon (n):[1] the vocabulary of a particular language, field, social class, person, etc.

I'm now going to give you a little lexicon to use for reading and writing pointers. Whenever you run into a complex pointer statement, just refer to this and break it down bit by bit (or just don't use that code since it's probably not good code):

	type *ptr
		"a pointer of type named ptr"
	*ptr
		"the value of whatever ptr is pointed at"
	*(ptr + i)
		"the value of (whatever ptr is pointed at plus i)"
	&thing
		"the address of thing"
	type *ptr = &thing
		"a pointer of type named ptr set to the address of thing"
	ptr++
		"increment where ptr points"

// note: Pointers Are Not Arrays
No matter what, you should never think that pointers and arrays are the same thing. They are not the same thing, even though C lets you work with them in many of the same ways. For example, if you do sizeof(cur_age) in the code above, you would get the size of the pointer, not the size of what it points at. If you want the size of the full array, you have to use the array's name, age as I did on line 12.

//-------------------------------------------------
// topic:	Exercise 16: Structs And Pointers To Them
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In this exercise you'll learn how to make a struct, point a pointer at them, and use them to make sense of internal memory structures. I'll also apply the knowledge of pointers from the last exercise and get you constructing these structures from raw memory using malloc.

As usual, here's the program we'll talk about, so type it in and make it work:

	#include <stdio.h>
	#include <assert.h>
	#include <stdlib.h>
	#include <string.h>

	struct Person {
	    char *name;
	    int age;
	    int height;
	    int weight;
	};

	struct Person *Person_create(char *name, int age, int height, int weight)
	{
	    struct Person *who = malloc(sizeof(struct Person));
	    assert(who != NULL);

	    who->name = strdup(name);
	    who->age = age;
	    who->height = height;
	    who->weight = weight;

	    return who;
	}

	void Person_destroy(struct Person *who)
	{
	    assert(who != NULL);

	    free(who->name);
	    free(who);
	}

	void Person_print(struct Person *who)
	{
	    printf("Name: %s\n", who->name);
	    printf("\tAge: %d\n", who->age);
	    printf("\tHeight: %d\n", who->height);
	    printf("\tWeight: %d\n", who->weight);
	}

	int main(int argc, char *argv[])
	{
	    // make two people structures
	    struct Person *joe = Person_create(
		    "Joe Alex", 32, 64, 140);

	    struct Person *frank = Person_create(
		    "Frank Blank", 20, 72, 180);

	    // print them out and where they are in memory
	    printf("Joe is at memory location %p:\n", joe);
	    Person_print(joe);

	    printf("Frank is at memory location %p:\n", frank);
	    Person_print(frank);

	    // make everyone age 20 years and print them again
	    joe->age += 20;
	    joe->height -= 2;
	    joe->weight += 40;
	    Person_print(joe);

	    frank->age += 20;
	    frank->weight += 20;
	    Person_print(frank);

	    // destroy them both so we clean up
	    Person_destroy(joe);
	    Person_destroy(frank);

	    return 0;
	}

// compile and output result
	$ make ex16
	cc -Wall -g    ex16.c   -o ex16

	$ ./ex16
	Joe is at memory location 0xeba010:
	Name: Joe Alex
	    Age: 32
	    Height: 64
	    Weight: 140
	Frank is at memory location 0xeba050:
	Name: Frank Blank
	   Age: 20
	   Height: 72
	   Weight: 180
	Name: Joe Alex
	   Age: 52
	   Height: 62
	   Weight: 180
	Name: Frank Blank
	   Age: 40
	   Height: 72
	   Weight: 200

// explaining above code:

[1] includes
I include some new header files here to gain access to some new functions. What does each give you?

[2] struct Person
This is where I'm creating a structure that has 4 elements to describe a person. The final result is a new compound type that lets me reference these elements all as one, or each piece by name. It's similar to a row of a database table or a class in an OOP language.

[3] function Person_create
I need a way to create these structures so I've made a function to do that. Here's the important things this function is doing:

	[i] I use malloc for "memory allocate" to ask the OS to give me a piece of raw memory.
	[ii] I pass to malloc the sizeof(struct Person) which calculates the total size of the struct, given all the fields 
	inside it.
	[iii] I use assert to make sure that I have a valid piece of memory back from malloc. There's a special constant called 
	NULL that you use to mean "unset or invalid pointer". This assert is basically checking that malloc didn't return a NULL 
	invalid pointer.
	[iv] I initialize each field of struct Person using the x->y syntax, to say what part of the struct I want to set.
	[v] I use the strdup function to duplicate the string for the name, just to make sure that this structure actually owns 	it. The strdup actually is like malloc and it also copies the original string into the memory it creates.

[4] function Person_destroy
If I have a create, then I always need a destroy function, and this is what destroys Person structs. I again use assert to make sure I'm not getting bad input. Then I use the function free to return the memory I got with malloc and strdup. If you don't do this you get a "memory leak".

[5] function Person_print
I then need a way to print out people, which is all this function does. It uses the same x->y syntax to get the field from the struct to print it.

[6] function main
In the main function I use all the previous functions and the struct Person to do the following:

	[i] Create two people, joe and frank.
	[ii] Print them out, but notice I'm using the %p format so you can see where the program has actually put your struct in 
	memory.
	[iii] Age both of them by 20 years, with changes to their body too.
	[iv] Print each one after aging them.
	[v] Finally destroy the structures so we can clean up correctly.

// note:
Look up every function and header file you don't know about. Remember that you can usually do man 2 function or man 3 function and it'll tell you about it. You can also search online for the information.

// Explaining Structures
If you've done the work I asked you then structures should be making sense, but let me explain them explicitly just to make sure you've understood it.

A structure in C is a collection of other data types (variables) that are stored in one block of memory but let you access each variable independently by name. They are similar to a record in a database table, or a very simplistic class in an object oriented language. We can break one down this way:

[1] In the above code, you make a struct that has the fields you'd expect for a person: name, age, weight, height.
[2] Each of those fields has a type, like int.
[3] C then packs those together so they can all be contained in one single struct.
[4] The struct Person is now a compound data type, which means you can now refer to struct Person in the same kinds of expressions you would other data types.
[5] This lets you pass the whole cohesive grouping to other functions, as you did with Person_print.
[6] You can then access the individual parts of a struct by their names using x->y if you're dealing with a pointer.
[7] There's also a way to make a struct that doesn't need a pointer, and you use the x.y (period) syntax to work with it. You'll do this in the Extra Credit.

If you didn't have struct you'd need to figure out the size, packing, and location of pieces of memory with contents like this. In fact, in most early assembler code (and even some now) this is what you do. With C you can let C handle the memory structuring of these compound data types and then focus on what you do with them.

// independed project: Arrays with struct and using sizeof
	#include<stdio.h>

	struct person {
		char *name;
		int age;
		char gender;
	};

	int main ( int argc, char *argv[]){
	struct person list[4];
	list[0].name="Eric";
	list[1].name="Luis";
	list[2].name="Adriana";
	list[3].name="Cris";
	int i=0;
	for (; i < (sizeof (list)/ sizeof (struct person)); i++) // using dynamic wat to know the number of strucature arrays that used
		printf("list[%d].name=%s\n", i, list[i].name);
	
	// end of for-loop
	printf("\n");
	return 0;
	}

// compling and result
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ make -B q2
	cc -Wall -g    q2.c   -o q2
	alshamlan@alshamlan-VGN-CR520E:/tmp/interview$ ./q2 
	list[0].name=Eric
	list[1].name=Luis
	list[2].name=Adriana
	list[3].name=Cris

// note: 
I used -B flage in make command to force it to re-complie the code even if the file Makefile hasn't been updated!!

//-------------------------------------------------
// topic:	Exercise 17: Heap And Stack Memory Allocation
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In this exercise you're going to make a big leap in difficulty and create an entire small program to manage a database. This database isn't very efficient and doesn't store very much, but it does demonstrate most of what you've learned so far. It also introduces memory allocation more formally and gets you started working with files. We use some file I/O functions, but I won't be explaining them too well so you can try to figure them out first.

As usual, type this whole program in and get it working, then we'll discuss:

	#include <stdio.h>
	#include <assert.h>
	#include <stdlib.h>
	#include <errno.h>
	#include <string.h>

	#define MAX_DATA 512
	#define MAX_ROWS 100

	struct Address {
	    int id;
	    int set;
	    char name[MAX_DATA];
	    char email[MAX_DATA];
	};

	struct Database {
	    struct Address rows[MAX_ROWS];
	};

	struct Connection {
	    FILE *file;
	    struct Database *db;
	};

	void die(const char *message)
	{
	    if(errno) {
		perror(message);
	    } else {
		printf("ERROR: %s\n", message);
	    }

	    exit(1);
	}

	void Address_print(struct Address *addr)
	{
	    printf("%d %s %s\n",
		    addr->id, addr->name, addr->email);
	}

	void Database_load(struct Connection *conn)
	{
	    int rc = fread(conn->db, sizeof(struct Database), 1, conn->file);
	    if(rc != 1) die("Failed to load database.");
	}

	struct Connection *Database_open(const char *filename, char mode)
	{
	    struct Connection *conn = malloc(sizeof(struct Connection));
	    if(!conn) die("Memory error");

	    conn->db = malloc(sizeof(struct Database));
	    if(!conn->db) die("Memory error");

	    if(mode == 'c') {
		conn->file = fopen(filename, "w");
	    } else {
		conn->file = fopen(filename, "r+");

		if(conn->file) {
		    Database_load(conn);
		}
	    }

	    if(!conn->file) die("Failed to open the file");

	    return conn;
	}

	void Database_close(struct Connection *conn)
	{
	    if(conn) {
		if(conn->file) fclose(conn->file);
		if(conn->db) free(conn->db);
		free(conn);
	    }
	}

	void Database_write(struct Connection *conn)
	{
	    rewind(conn->file);

	    int rc = fwrite(conn->db, sizeof(struct Database), 1, conn->file);
	    if(rc != 1) die("Failed to write database.");

	    rc = fflush(conn->file);
	    if(rc == -1) die("Cannot flush database.");
	}

	void Database_create(struct Connection *conn)
	{
	    int i = 0;

	    for(i = 0; i < MAX_ROWS; i++) {
		// make a prototype to initialize it
		struct Address addr = {.id = i, .set = 0};
		// then just assign it
		conn->db->rows[i] = addr;
	    }
	}

	void Database_set(struct Connection *conn, int id, const char *name, const char *email)
	{
	    struct Address *addr = &conn->db->rows[id];
	    if(addr->set) die("Already set, delete it first");

	    addr->set = 1;
	    // WARNING: bug, read the "How To Break It" and fix this
	    char *res = strncpy(addr->name, name, MAX_DATA);
	    // demonstrate the strncpy bug
	    if(!res) die("Name copy failed");

	    res = strncpy(addr->email, email, MAX_DATA);
	    if(!res) die("Email copy failed");
	}

	void Database_get(struct Connection *conn, int id)
	{
	    struct Address *addr = &conn->db->rows[id];

	    if(addr->set) {
		Address_print(addr);
	    } else {
		die("ID is not set");
	    }
	}

	void Database_delete(struct Connection *conn, int id)
	{
	    struct Address addr = {.id = id, .set = 0};
	    conn->db->rows[id] = addr;
	}

	void Database_list(struct Connection *conn)
	{
	    int i = 0;
	    struct Database *db = conn->db;

	    for(i = 0; i < MAX_ROWS; i++) {
		struct Address *cur = &db->rows[i];

		if(cur->set) {
		    Address_print(cur);
		}
	    }
	}

	int main(int argc, char *argv[])
	{
	    if(argc < 3) die("USAGE: ex17 <dbfile> <action> [action params]");

	    char *filename = argv[1];
	    char action = argv[2][0];
	    struct Connection *conn = Database_open(filename, action);
	    int id = 0;

	    if(argc > 3) id = atoi(argv[3]);
	    if(id >= MAX_ROWS) die("There's not that many records.");

	    switch(action) {
		case 'c':
		    Database_create(conn);
		    Database_write(conn);
		    break;

		case 'g':
		    if(argc != 4) die("Need an id to get");

		    Database_get(conn, id);
		    break;

		case 's':
		    if(argc != 6) die("Need id, name, email to set");

		    Database_set(conn, id, argv[4], argv[5]);
		    Database_write(conn);
		    break;

		case 'd':
		    if(argc != 4) die("Need id to delete");

		    Database_delete(conn, id);
		    Database_write(conn);
		    break;

		case 'l':
		    Database_list(conn);
		    break;
		default:
		    die("Invalid action, only: c=create, g=get, s=set, d=del, l=list");
	    }

	    Database_close(conn);

	    return 0;
	}

In this program I am using a set of structures to create a simple database for an address book. In it I'm using some things you've never seen, so you should go through it line-by-line, explain what each line does, and look up any functions you do not recognize. There are few key things I'm doing that you should pay attention to as well:

#define for constants
I use another part of the "C Pre-Processor" to create constant settings of MAX_DATA and MAX_ROWS. I'll cover more of what the CPP does, but this is a way to create a constant that will work reliably. There's other ways but they don't apply in certain situations.

Fixed Sized Structs
The Address struct then uses these constants to create a piece of data that is fixed in size making it less efficient, but easier to store and read. The Database struct is then also fixed size because it is a fixed length array of Address structs. That lets you write the whole thing to disk in one move later on.

die function to abort with an error
In a small program like this you can make a single function that kills the program with an error if there's anything wrong. I call this die, and it's used after any failed function calls or bad inputs to exit with an error using exit.

errno and perror() for error reporting
When you have an error return from a function, it will usually set an "external" variable called errno to say exactly what error happened. These are just numbers, so you can use perror to "print the error message".

FILE functions
I'm using all new functions like fopen, fread, fclose, and rewind to work with files. Each of these functions works on a FILE struct that's just like your structs, but it's defined by the C standard library.

nested struct pointers
There's use of nested structures and getting the address of array elements that you should study. Specifically code like &conn->db->rows[i] which reads "get the i element of rows, which is in db, which is in conn, then get the address of (&) it".

copying struct prototypes
best shown in Database_delete, you can see I'm using a temporary local Address, initializing its id and set fields, and then simply copying it into the rows array by assigning it to the element I want. This trick makes sure that all fields but set and id are initialized to 0s and is actually easier to write. Incidentally, you shouldn't be using memcpy to do these kinds of struct copying operations. Modern C allows you to simply assign one struct to another and it'll handle the copying for you.

processing complex arguments
I'm doing some more complex argument parsing, but this isn't really the best way to do it. We'll get into better option parsing later in the book.

converting strings to ints
I use the atoi function to take the string for the id on the command line and convert it to the int id variable. Read up on this function and similar ones.

allocating large data on the "heap"
The whole point of this program is that I'm using malloc to ask the OS for a large amount of memory to work with when I create the Database. I cover this in more detail below.

NULL is 0 so boolean works
In many of the checks I'm testing that a pointer is not NULL by simply doing if(!ptr) die("fail!") this is valid because NULL will evaluate to false. You could be explicit and say if(ptr == NULL) die("fail!") as well. On some rare systems NULL will be stored in the computer (represented) as something not 0, but the C standard says you should still be able to write code as if it has a 0 value. From now on when I say "NULL is 0" I mean its value for anyone who is overly pedantic.

// What You Should See
You should spend as much time as you can testing that it works, and running it with Valgrind to confirm you've got all the memory usage right. Here's a session of me testing it normally and then using Valgrind to check the operations:

	$ make ex17
	cc -Wall -g    ex17.c   -o ex17
	$ ./ex17 db.dat c
	$ ./ex17 db.dat s 1 zed zed@zedshaw.com
	$ ./ex17 db.dat s 2 frank frank@zedshaw.com
	$ ./ex17 db.dat s 3 joe joe@zedshaw.com
	$
	$ ./ex17 db.dat l
	1 zed zed@zedshaw.com
	2 frank frank@zedshaw.com
	3 joe joe@zedshaw.com
	$ ./ex17 db.dat d 3
	$ ./ex17 db.dat l
	1 zed zed@zedshaw.com
	2 frank frank@zedshaw.com
	$ ./ex17 db.dat g 2
	2 frank frank@zedshaw.com
	$
	$ valgrind --leak-check=yes ./ex17 db.dat g 2
	# cut valgrind output...
	$

The actual output of Valgrind is taken out since you should be able to detect it.

// note
Valgrind will report that you're leaking small blocks of memory, but sometimes it's just over-reporting from OSX's internal APIs. If you see it showing leaks that aren't inside your code then just ignore them.

// Heap vs. Stack Allocation
You kids these days have it great. You play with your Ruby or Python and just make objects and variables without any care for where they live. You don't care if it's on the "stack", and the heap? Fuggedaboutit (stands for "forget about it"). You don't even know, and you know what, chances are your language of choice doesn't even put the variables on stack at all. It's all heap, and you don't even know if it is.

C is different because it's using the real CPU's actual machinery to do its work, and that involves a chunk of ram called the stack and another called the heap. What's the difference? It all depends on where you get the storage.

The heap is easier to explain as it's just all the remaining memory in your computer, and you access it with the function malloc to get more. Each time you call malloc, the OS uses internal functions to register that piece of memory to you, and then returns a pointer to it. When you're done with it, you use free to return it to the OS so that it can be used by other programs. Failing to do this will cause your program to "leak" memory, but Valgrind will help you track these leaks down.

The stack is a special region of memory that stores temporary variables each function creates as locals to that function. How it works is each argument to a function is "pushed" onto the stack, and then used inside the function. It is really a stack data structure, so the last thing in is the first thing out, FIFO. This also happens with all local variables like char action and int id in main. The advantage of using a stack for this is simply that, when the function exits, the C compiler "pops" these variables off the stack to clean up. This is simple and prevents memory leaks if the variable is on the stack.

The easiest way to keep this straight is with this mantra: If you didn't get it from malloc or a function that got it from malloc, then it's on the stack.

There's three primary problems with stacks and heaps to watch for:
[1] If you get a block of memory from malloc, and have that pointer on the stack, then when the function exits, the pointer will get popped off and lost.

[2]If you put too much data on the stack (like large structs and arrays) then you can cause a "stack overflow" and the program will abort. In this case, use the heap with malloc.

[3]If you take a pointer to something on the stack, and then pass that or return it from your function, then the function receiving it will "segmentation fault" (segfault) because the actual data will get popped off and disappear. You'll be pointing at dead space.

This is why in the program I've created a Database_open that allocates memory or dies, and then a Database_close that frees everything. If you create a "create" function, that makes the whole thing or nothing, and then a "destroy" function that cleans up everything safely, then it's easier to keep it all straight.

Finally, when a program exits the OS will clean up all the resources for you, but sometimes not immediately. A common idiom (and one I use in this exercise) is to just abort and let the OS clean up on error.

// How To Break It
This program has a lot of places you can break it, so try some of these but also come up with your own:

The classic way is to remove some of the safety checks such that you can pass in arbitrary data. For example, if you remove the check on line 160 that prevents you from passing in any record number.

You can also try corrupting the data file. Open it in any editor and change random bytes then close it.

You could also find ways to pass bad arguments to the program when it's run, such as getting the file and action backwards will make it create a file named after the action, then do an action based on the first character.

There is a bug in this program because of strncpy being poorly designed. Go read about strncpy then try to find out what happens when the name or address you give is greater than 512 bytes. Fix this by simply forcing the last character to '\0' so that it's always set no matter what (which is what strncpy should do).

In the extra credit I have you augment the program to create arbitrary size databases. Try to see what the biggest database is before you cause the program to die for lack of memory from malloc.

// Extra Credit
The die function needs to be augmented to let you pass the conn variable so it can close it and clean up.

Change the code to accept parameters for MAX_DATA and MAX_ROWS, store them in the Database struct, and write that to the file, thus creating a database that can be arbitrarily sized.

Add more operations you can do on the database, like find.

Read about how C does it's struct packing, and then try to see why your file is the size it is. See if you can calculate a new size after adding more fields.

Add some more fields to the Address and make them searchable.

Write a shell script that will do your testing automatically for you by running commands in the right order. Hint: Use set -e at the top of a bash to make it abort the whole script if any command has an error.

Try reworking the program to use a single global for the database connection. How does this new version of the program compare to the other one?

Go research "stack data structure" and write one in your favorite language, then try to do it in C.


//-------------------------------------------------
// topic:	Exercise 18: Pointers To Functions
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
Functions in C are actually just pointers to a spot in the program where some code exists. Just like you've been creating pointers to structs, strings, and arrays, you can point a pointer at a function too. The main use for this is to pass "callbacks" to other functions, or to simulate classes and objects. In this exercise we'll do some callbacks, and in the next one we'll make a simple object system.

The format of a function pointer goes like this:

	int (*POINTER_NAME)(int a, int b)

A way to remember how to write one is to do this:
[1] Write a normal function declaration: int callme(int a, int b)
[2] Wrap function name with pointer syntax: int (*callme)(int a, int b)
[3] Change the name to the pointer name: int (*compare_cb)(int a, int b)

The key thing to remember is, when you're done with this, the variable name for the pointer is called compare_cb and then you use it just like it's a function. This is similar to how pointers to arrays can be used just like the arrays they point to. Pointers to functions can be used like the functions they point to but with a different name.

	int (*tester)(int a, int b) = sorted_order;
	printf("TEST: %d is same as %d\n", tester(2, 3), sorted_order(2, 3));

This will work even if the function pointer returns a pointer to something:
[1] Write it: char *make_coolness(int awesome_levels)
[2] Wrap it: char *(*make_coolness)(int awesome_levels)
[3] Rename it: char *(*coolness_cb)(int awesome_levels)

The next problem to solve with using function pointers is that it's hard to give them as parameters to a function, like when you want to pass the function callback to another function. The solution to this is to use typedef which is a C keyword for making new names for other more complex types. The only thing you need to do is put typedef before the same function pointer syntax, and then after that you can use the name like it's a type. I demonstrate this in the following exercise code:

	#include <stdio.h>
	#include <stdlib.h>
	#include <errno.h>
	#include <string.h>

	/** Our old friend die from ex17. */
	void die(const char *message)
	{
	    if(errno) {
		perror(message);
	    } else {
		printf("ERROR: %s\n", message);
	    }

	    exit(1);
	}

	// a typedef creates a fake type, in this
	// case for a function pointer
	typedef int (*compare_cb)(int a, int b);

	/**
	 * A classic bubble sort function that uses the 
	 * compare_cb to do the sorting. 
	 */
	int *bubble_sort(int *numbers, int count, compare_cb cmp)
	{
	    int temp = 0;
	    int i = 0;
	    int j = 0;
	    int *target = malloc(count * sizeof(int));

	    if(!target) die("Memory error.");

	    memcpy(target, numbers, count * sizeof(int));

	    for(i = 0; i < count; i++) {
		for(j = 0; j < count - 1; j++) {
		    if(cmp(target[j], target[j+1]) > 0) {
		        temp = target[j+1];
		        target[j+1] = target[j];
		        target[j] = temp;
		    }
		}
	    }

	    return target;
	}

	int sorted_order(int a, int b)
	{
	    return a - b;
	}

	int reverse_order(int a, int b)
	{
	    return b - a;
	}

	int strange_order(int a, int b)
	{
	    if(a == 0 || b == 0) {
		return 0;
	    } else {
		return a % b;
	    }
	}

	/** 
	 * Used to test that we are sorting things correctly
	 * by doing the sort and printing it out.
	 */
	void test_sorting(int *numbers, int count, compare_cb cmp)
	{
	    int i = 0;
	    int *sorted = bubble_sort(numbers, count, cmp);

	    if(!sorted) die("Failed to sort as requested.");

	    for(i = 0; i < count; i++) {
		printf("%d ", sorted[i]);
	    }
	    printf("\n");

	    free(sorted);
	}


	int main(int argc, char *argv[])
	{
	    if(argc < 2) die("USAGE: ex18 4 3 1 5 6");

	    int count = argc - 1;
	    int i = 0;
	    char **inputs = argv + 1;

	    int *numbers = malloc(count * sizeof(int));
	    if(!numbers) die("Memory error.");

	    for(i = 0; i < count; i++) {
		numbers[i] = atoi(inputs[i]);
	    }

	    test_sorting(numbers, count, sorted_order);
	    test_sorting(numbers, count, reverse_order);
	    test_sorting(numbers, count, strange_order);

	    free(numbers);

	    return 0;
	}

In this program you're creating a dynamic sorting algorithm that can sort an array of integers using a comparison callback. Here's the breakdown of this program so you can clearly understand it:

ex18.c:1-6
The usual includes needed for all the functions we call.

ex18.c:7-17
This is the die function from the previous exercise which I'll use to do error checking.

ex18.c:21
This is where the typedef is used, and later I use compare_cb like it's a type similar to int or char in bubble_sort and test_sorting.

ex18.c:27-49
A bubble sort implementation, which is a very inefficient way to sort some integers. This function contains:

ex18.c:27
Here's where I use the typedef for compare_cb as the last parameter cmp. This is now a function that will return a comparison between two integers for sorting.

ex18.c:29-34
The usual creation of variables on the stack, followed by a new array of integers on the heap using malloc. Make sure you understand what count * sizeof(int) is doing.

ex18.c:38
The outer-loop of the bubble sort.

ex18.c:39
The inner-loop of the bubble sort

ex18.c:40
Now I call the cmp callback just like it's a normal function, but instead of being the name of something we defined, it's just a pointer to it. This lets the caller pass in anything they want as long as it matches the "signature" of the compare_cb typedef.

ex18.c:41-43
The actual swapping operation a bubble sort needs to do what it does.

ex18.c:48
Finally return the newly created and sorted result array target.

ex18.c:51-68
Three different versions of the compare_cb function type, which needs to have the same definition as the typedef we created. The C compiler will complain to you if you get this wrong and say the types don't match.

ex18.c:74-87
This is a tester for the bubble_sort function. You can see now how I'm also using compare_cb to then pass to bubble_sort demonstrating how these can be passed around like any other pointers.

ex18.c:90-103
A simple main function that sets up an array based on integers you pass on the command line, then calls the test_sorting function.

ex18.c:105-107
Finally, you get to see how the compare_cb function pointer typedef is used. I simply call test_sorting but give it the name of sorted_order, reverse_order, and strange_order as the function to use. The C compiler then finds the address of those functions, and makes it a pointer for test_sorting to use. If you look at test_sorting you'll see it then passes each of these to bubble_sort but it actually has no idea what they do, only that they match the compare_cb prototype and should work.

ex18.c:109
Last thing we do is free up the array of numbers we made.

// What You Should See
Running this program is simple, but try different combinations of numbers, and try even non-numbers to see what it does.
	$ make ex18
	cc -Wall -g    ex18.c   -o ex18
	$ ./ex18 4 1 7 3 2 0 8
	0 1 2 3 4 7 8 
	8 7 4 3 2 1 0 
	3 4 2 7 1 0 8 
	$

// How To Break It
I'm going to have you do something kind of weird to break this. These function pointers are pointers like every other pointer, so they point at blocks of memory. C has this ability to take one pointer and convert it to another so you can process the data in different ways. It's usually not necessary, but to show you how to hack your computer, I want you to add this at the end of test_sorting:

	unsigned char *data = (unsigned char *)cmp;

	for(i = 0; i < 25; i++) {
	    printf("%02x:", data[i]);
	}

	printf("\n");

This loop is sort of like converting your function to a string and then printing out it's contents. This won't break your program unless the CPU and OS you're on has a problem with you doing this. What you'll see is a string of hexadecimal numbers after it prints the sorted array:
	55:48:89:e5:89:7d:fc:89:75:f8:8b:55:fc:8b:45:f8:29:d0:c9:c3:55:48:89:e5:89:

That should be the raw assembler byte code of the function itself, and you should see they start the same, but then have different endings. It's also possible that this loop isn't getting all of the function or is getting too much and stomping on another piece of the program. Without more analysis you wouldn't know.

// Extra Credit
Get a hex editor and open up ex18, then find this sequence of hex digits that start a function to see if you can find the function in the raw program.

Find other random things in your hex editor and change them. Rerun your program and see what happens. Changing strings you find are the easiest things to change.

Pass in the wrong function for the compare_cb and see what the C compiler complains about.

Pass in NULL and watch your program seriously bite it. Then run Valgrind and see what that reports.

Write another sorting algorithm, then change test_sorting so that it takes both an arbitrary sort function and the sort function's callback comparison. Use it to test both of your algorithms.


//-------------------------------------------------
// topic:	Exercise 19: A Simple Object System
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
I learned C before I learned Object Oriented Programming, so it helped me to build an OOP system in C to understand the basics of what OOP meant. You are probably the kind of person who learned an OOP language before you learned C, so this kind of bridge might help you as well. In this exercise, you will build a simple object system, but also learn more about the C Pre-Processor or CPP.

This exercise will build a simple game where you kill a Minotaur in a small little castle. Nothing fancy, just four rooms and a bad guy. This project will also be a multi-file project, and look more like a real C software project than your previous ones. This is why I'm introducing the CPP here because you need it to start using multiple files in your own software.

// How The CPP Works
The C Pre-Processor is a template processing system. It's a highly targeted one that helps make C easier to work with, but it does this by having a syntax aware templating mechanism. Traditionally people just used the CPP to store constants and make "macros" to simplify repetitive coding. In modern C you'll actually use the CPP as a code generator to create templated pieces of code.

How the CPP works is you give it one file, usually a .c file, and it processes various bits of text starting with the # (octothorpe) character. When it encounters one of these it performs a specific replacement on the text of the input file. It's main advantage though is it can include other files, and then augment its list of macros based on that file's contents.

A quick way to see what the CPP does is take the last exercise and run this:

	cpp ex18.c | less

It will be a huge amount of output, but scroll through it and you'll see the contents of the other files you included with #include. Scroll down to the original code and you can see how the cpp is altering the source based on various #define macros in the header files.

The C compiler is so tightly integrated with cpp that it just runs this for you and understands how it works intimately. In modern C, the cpp system is so integral to C's function that you might as well just consider it to be part of the language.

In the remaining sections, we'll be using more of the CPP syntax and explaining it as we go.

// The Prototype Object System
The OOP system we'll create is a simple "prototype" style object system more like JavaScript. Instead of classes, you start with prototypes that have fields set, and then use those as the basis of creating other object instances. This "classless" design is much easier to implement and work with than a traditional class based one.

// The Object Header File
I want to put the data types and function declarations into a separate header file named object.h. This is standard C practice and it lets you ship binary libraries but still let the programmer compile against it. In this file I have several advanced CPP techniques I'm going to quickly describe and then have you see in action later:

	#ifndef _object_h
	#define _object_h

	typedef enum {
	    NORTH, SOUTH, EAST, WEST
	} Direction;

	typedef struct {
	    char *description;
	    int (*init)(void *self);
	    void (*describe)(void *self);
	    void (*destroy)(void *self);
	    void *(*move)(void *self, Direction direction);
	    int (*attack)(void *self, int damage);
	} Object;

	int Object_init(void *self);
	void Object_destroy(void *self);
	void Object_describe(void *self);
	void *Object_move(void *self, Direction direction);
	int Object_attack(void *self, int damage);
	void *Object_new(size_t size, Object proto, char *description);

	#define NEW(T, N) Object_new(sizeof(T), T##Proto, N)
	#define _(N) proto.N

	#endif

Taking a look at this file, you can see we have a few new pieces of syntax you haven't encountered before:

#ifndef
You've seen a #define for making simple constants, but the CPP can also do logic and remove sections of code. This #ifndef is "if not defined" and checks if there's already a #define _object_h and if there is it skips all of this code. I do this so that we can include this file any time we want and not worry about it defining things multiple times.

#define
With the above #ifndef shielding this file from we then add the _object_h define so that any attempts to include it later cause the above to skip.

#define NEW(T,N)
This makes a macro, and it works like a template function that spits out the code on the right, whenever you write use the macro on the left. This one is simply making a short version of the normal way we'll call Object_new and avoids potential errors with calling it wrong. The way the macro works is the T and N parameters to NEW are "injected" into the line of code on the right. The syntax T##Proto says to "concat Proto at the end of T", so if you had NEW(Room, "Hello.") then it'd make RoomProto there.

#define _(N)
This macro is a bit of "syntactic sugar" for the object system and basically helps you write obj->proto.blah as simply obj->_(blah). It's not necessary, but it's a fun little trick that I'll use later.

// The Object Source File
The object.h file is declaring functions and data types that are defined (created) in the object.c, so that's next:

	#include <stdio.h>
	#include <string.h>
	#include <stdlib.h>
	#include "object.h"
	#include <assert.h>

	void Object_destroy(void *self)
	{
	    Object *obj = self;

	    if(obj) {
		if(obj->description) free(obj->description);
		free(obj);
	    }
	}

	void Object_describe(void *self)
	{
	    Object *obj = self;
	    printf("%s.\n", obj->description);
	}

	int Object_init(void *self)
	{
	    // do nothing really
	    return 1;
	}

	void *Object_move(void *self, Direction direction)
	{
	    printf("You can't go that direction.\n");
	    return NULL;
	}

	int Object_attack(void *self, int damage)
	{
	    printf("You can't attack that.\n");
	    return 0;
	}

	void *Object_new(size_t size, Object proto, char *description)
	{
	    // setup the default functions in case they aren't set
	    if(!proto.init) proto.init = Object_init;
	    if(!proto.describe) proto.describe = Object_describe;
	    if(!proto.destroy) proto.destroy = Object_destroy;
	    if(!proto.attack) proto.attack = Object_attack;
	    if(!proto.move) proto.move = Object_move;

	    // this seems weird, but we can make a struct of one size,
	    // then point a different pointer at it to "cast" it
	    Object *el = calloc(1, size);
	    *el = proto;

	    // copy the description over
	    el->description = strdup(description);

	    // initialize it with whatever init we were given
	    if(!el->init(el)) {
		// looks like it didn't initialize properly
		el->destroy(el);
		return NULL;
	    } else {
		// all done, we made an object of any type
		return el;
	    }
	}

There's really nothing new in this file, except one tiny little trick. The function Object_new uses an aspect of how structs work by putting the base prototype at the beginning of the struct. When you look at the ex19.h header later, you'll see how I make the first field in the struct an Object. Since C puts the fields in a struct in order, and since a pointer just points at a chunk of memory, I can "cast" a pointer to anything I want. In this case, even though I'm taking a potentially larger block of memory from calloc, I'm using a Object pointer to work with it.

I explain this a bit better when we write the ex19.h file since it's easier to understand when you see it being used.

That creates your base object system, but you'll need a way to compile it and link it into your ex19.c file to create a complete program. The object.c file on its own doesn't have a main so it isn't enough to make a full program. Here's a Makefile that will do this based on the one you've been using:

	CFLAGS=-Wall -g

	all: ex19

	ex19: object.o

	clean:
	  rm -f ex19

This Makefile is doing nothing more than saying that ex19 depends on object.o. Remember how make knows how to build different kinds of files by their extensions? Doing this tells make the following:
[1] When I say run make the default all should just build ex19.
[2] When you build ex19, you need to also build object.o and include it in the build.
[3] make can't see anything in the file for object.o, but it does see an object.c file, and it knows how to turn a .c into a .o, so it does that.
[4] Once it has object.o built it then runs the correct compile command to build ex19 from ex19.c and object.o.

// The Game Implementation
Once you have those files you just need to implement the actual game using the object system, and first step is putting all the data types and function declarations in a ex19.h file:

	#ifndef _ex19_h
	#define _ex19_h

	#include "object.h"

	struct Monster {
	    Object proto;
	    int hit_points;
	};

	typedef struct Monster Monster;

	int Monster_attack(void *self, int damage);
	int Monster_init(void *self);

	struct Room {
	    Object proto;

	    Monster *bad_guy;

	    struct Room *north;
	    struct Room *south;
	    struct Room *east;
	    struct Room *west;
	};

	typedef struct Room Room;

	void *Room_move(void *self, Direction direction);
	int Room_attack(void *self, int damage);
	int Room_init(void *self);


	struct Map {
	    Object proto;
	    Room *start;
	    Room *location;
	};

	typedef struct Map Map;

	void *Map_move(void *self, Direction direction);
	int Map_attack(void *self, int damage);
	int Map_init(void *self);

	#endif

That sets up three new Objects you'll be using: Monster, Room, and Map.

Taking a look at object.c:52 you can see where I use a pointer Object *el = calloc(1, size). Go back and look at the NEW macro in object.h and you can see that it is getting the sizeof another struct, say Room, and I allocate that much. However, because I've pointed a Object pointer at this block of memory, and because I put an Object proto field at the front of Room, I'm able to treat a Room like it's an Object.

The way to break this down is like so:
[1] I call NEW(Room, "Hello.") which the CPP expands as a macro into Object_new(sizeof(Room), RoomProto, "Hello.").

[2] This runs, and inside Object_new I allocate a piece of memory that's Room in size, but point a Object *el pointer at it.

[3] Since C puts the Room.proto field first, that means the el pointer is really only pointing at enough of the block of memory to see a full Object struct. It has no idea that it's even called proto.

[4] It then uses this Object *el pointer to set the contents of the piece of memory correctly with *el = proto;. Remember that you can copy structs, and that *el means "the value of whatever el points at", so this means "assign the proto struct to whatever el points at".

[5] Now that this mystery struct is filled in with the right data from proto, the function can then call init or destroy on the Object, but the cool part is whoever called this function can change these out for whatever ones they want.

And with that, we have a way to get this one function to construct new types, and give them new functions to change their behavior. This may seem like "hackery" but it's stock C and totally valid. In fact there's quite a few standard system functions that work this same way, and we'll be using some of them for converting addresses in network code.

With the function definitions and data structures written out I can now actually implement the game with four rooms and a minotaur to beat up:

	#include <stdio.h>
	#include <errno.h>
	#include <stdlib.h>
	#include <string.h>
	#include <time.h>
	#include "ex19.h"


	int Monster_attack(void *self, int damage)
	{
	    Monster *monster = self;

	    printf("You attack %s!\n", monster->_(description));

	    monster->hit_points -= damage;

	    if(monster->hit_points > 0) {
		printf("It is still alive.\n");
		return 0;
	    } else {
		printf("It is dead!\n");
		return 1;
	    }
	}

	int Monster_init(void *self)
	{
	    Monster *monster = self;
	    monster->hit_points = 10;
	    return 1;
	}

	Object MonsterProto = {
	    .init = Monster_init,
	    .attack = Monster_attack
	};


	void *Room_move(void *self, Direction direction)
	{
	    Room *room = self;
	    Room *next = NULL;

	    if(direction == NORTH && room->north) {
		printf("You go north, into:\n");
		next = room->north;
	    } else if(direction == SOUTH && room->south) {
		printf("You go south, into:\n");
		next = room->south;
	    } else if(direction == EAST && room->east) {
		printf("You go east, into:\n");
		next = room->east;
	    } else if(direction == WEST && room->west) {
		printf("You go west, into:\n");
		next = room->west;
	    } else {
		printf("You can't go that direction.");
		next = NULL;
	    }

	    if(next) {
		next->_(describe)(next);
	    }

	    return next;
	}


	int Room_attack(void *self, int damage)
	{
	    Room *room = self;
	    Monster *monster = room->bad_guy;

	    if(monster) {
		monster->_(attack)(monster, damage);
		return 1;
	    } else {
		printf("You flail in the air at nothing. Idiot.\n");
		return 0;
	    }
	}


	Object RoomProto = {
	    .move = Room_move,
	    .attack = Room_attack
	};


	void *Map_move(void *self, Direction direction)
	{
	    Map *map = self;
	    Room *location = map->location;
	    Room *next = NULL;

	    next = location->_(move)(location, direction);

	    if(next) {
		map->location = next;
	    }

	    return next;
	}

	int Map_attack(void *self, int damage)
	{
	    Map* map = self;
	    Room *location = map->location;

	    return location->_(attack)(location, damage);
	}


	int Map_init(void *self)
	{
	    Map *map = self;

	    // make some rooms for a small map
	    Room *hall = NEW(Room, "The great Hall");
	    Room *throne = NEW(Room, "The throne room");
	    Room *arena = NEW(Room, "The arena, with the minotaur");
	    Room *kitchen = NEW(Room, "Kitchen, you have the knife now");

	    // put the bad guy in the arena
	    arena->bad_guy = NEW(Monster, "The evil minotaur");

	    // setup the map rooms
	    hall->north = throne;

	    throne->west = arena;
	    throne->east = kitchen;
	    throne->south = hall;

	    arena->east = throne;
	    kitchen->west = throne;

	    // start the map and the character off in the hall
	    map->start = hall;
	    map->location = hall;

	    return 1;
	}

	Object MapProto = {
	    .init = Map_init,
	    .move = Map_move,
	    .attack = Map_attack
	};

	int process_input(Map *game)
	{
	    printf("\n> ");

	    char ch = getchar();
	    getchar(); // eat ENTER

	    int damage = rand() % 4;

	    switch(ch) {
		case -1:
		    printf("Giving up? You suck.\n");
		    return 0;
		    break;

		case 'n':
		    game->_(move)(game, NORTH);
		    break;

		case 's':
		    game->_(move)(game, SOUTH);
		    break;

		case 'e':
		    game->_(move)(game, EAST);
		    break;

		case 'w':
		    game->_(move)(game, WEST);
		    break;

		case 'a':

		    game->_(attack)(game, damage);
		    break;
		case 'l':
		    printf("You can go:\n");
		    if(game->location->north) printf("NORTH\n");
		    if(game->location->south) printf("SOUTH\n");
		    if(game->location->east) printf("EAST\n");
		    if(game->location->west) printf("WEST\n");
		    break;

		default:
		    printf("What?: %d\n", ch);
	    }

	    return 1;
	}

	int main(int argc, char *argv[])
	{
	    // simple way to setup the randomness
	    srand(time(NULL));

	    // make our map to work with
	    Map *game = NEW(Map, "The Hall of the Minotaur.");

	    printf("You enter the ");
	    game->location->_(describe)(game->location);

	    while(process_input(game)) {
	    }

	    return 0;
	}

Honestly there isn't much in this that you haven't seen, and only you might need to understand how I'm using the macros I made from the headers files. Here's the important key things to study and understand:
[1] Implementing a prototype involves creating its version of the functions, and then creating a single struct ending in "Proto". Look at MonsterProto, RoomProto and MapProto.

[2] Because of how Object_new is implemented, if you don't set a function in your prototype, then it will get the default implementation created in object.c.

[3] In Map_init I create the little world, but more importantly I use the NEW macro from object.h to build all of the objects. To get this concept in your head, try replacing the NEW usage with direct Object_new calls to see how it's being translated.

[4] Working with these objects involves calling functions on them, and the _(N) macro does this for me. If you look at the code monster->_(attack)(monster, damage) you see that I'm using the macro, which gets replaced with monster->proto.attack(monster, damage). Study this transformation again by rewriting these calls back to their original. Also, if you get stuck then run cpp manually to see what it's going to do.

[5] I'm using two new functions srand and rand, which setup a simple random number generator good enough for the game. I also use time to initialize the random number generator. Research those.

[6] I use a new function getchar that gets a single character from the stdin. Research it.

// What You Should See
	// note: make command didn't work for me, so I did the following
	[1] cc -Wall -g   -c -o object.o object.c
	[2] cc -Wall -g    ex19.c object.o   -o ex19

Here's me playing my own game:

	$ make ex19
	cc -Wall -g   -c -o object.o object.c
	cc -Wall -g    ex19.c object.o   -o ex19
	$ ./ex19
	You enter the The great Hall.

	> l
	You can go:
	NORTH

	> n
	You go north, into:
	The throne room.

	> l
	You can go:
	SOUTH
	EAST
	WEST

	> e
	You go east, into:
	Kitchen, you have the knife now.

	> w
	You go west, into:
	The throne room.

	> s
	You go south, into:
	The great Hall.

	> n
	You go north, into:
	The throne room.

	> w
	You go west, into:
	The arena, with the minotaur.

	> a
	You attack The evil minotaur!
	It is still alive.

	> a
	You attack The evil minotaur!
	It is dead!

	> ^D
	Giving up? You suck.
	$

// Auditing The Game
As an exercise for you I have left out all of the assert checks I normally put into a piece of software. You've seen me use assert to make sure a program is running correctly, but now I want you to go back and do the following:

[1] Look at each function you've defined, one file at a time.

[2] At the top of each function, add asserts that make sure the input parameters are correct. For example, in Object_new you want a assert(description != NULL).

[3] Go through each line of the function, and find any functions being called. Read the documentation (man page) for that function, and confirm what it returns for an error. Add another assert to check that the error didn't happen. For example, in Object_new you need one after the call to calloc that does assert(el != NULL).

[4] If a function is expected to return a value, either make sure it returns an error value (like NULL), or have an assert to make sure that the returned variable isn't invalid. For example, in Object_new, you need to have assert(el != NULL) again before the last return since that part can never be NULL.

[5] For every if-statement you write, make sure there's an else clause unless that if is an error check that causes an exit.

[6] For every switch-statement you write, make sure that there's a default case that handles anything you didn't anticipate.

[7] Take your time going through every line of the function and find any errors you make. Remember that the point of this exercise is to stop being a "coder" and switch your brain into being a "hacker". Try to see how you could break it, then write code to prevent it or abort early if you can.

// Extra Credit
[1] Update the Makefile so that when you do make clean it will also remove the object.o file.
[2] Write a test script that works the game in different ways and augment the Makefile so you can run make test and it'll thrash the game with your script.
[3] Add more rooms and monsters to the game.
[4] Put the game mechanics into a third file, compile it to .o, and then use that to write another little game. If you're doing it right you should only have a new Map and a main function in the new game.



//-------------------------------------------------
// topic:	Exercise 20: Zed's Awesome Debug Macros
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
There is a constant problem in C that you have been dancing around but which I am going to solve in this exercise using a set of macros I developed. You can thank me later when you realize how insanely awesome these macros are. Right now you won't realize how awesome they are, so you'll just have to use them and then you can walk up to me one day and say, "Zed, those Debug Macros were the bomb. I owe you my first born child because you saved me a decade of heartache and prevented me from killing myself more than once. Thank you good sir, here's a million dollars and the original Snakehead Telecaster prototype signed by Leo Fender."

Yes, they are that awesome.

// The C Error Handling Problem
In almost every programming language handling errors is a difficult activity. There's entire programming languages that try as hard as they can to avoid even the concept of an error. Other languages invent complex control structures like exceptions to pass error conditions around. The problem exists mostly because programmers assume errors don't happen and this optimism infects the type of languages they use and create.

C tackles the problem by returning error codes and setting a global errno value that you check. This makes for complex code that simply exists to check if something you did had an error. As you write more and more C code you'll write code with the pattern:
[1] Call a function.
[2] If the return value is an error (must look that up each time too).
[3] Then cleanup all the resource created so far.
[4] and print out an error message that hopefully helps.

This means for every function call (and yes, every function) you are potentially writing 3-4 more lines just to make sure it worked. That doesn't include the problem of cleaning up all of the junk you've built to that point. If you have 10 different structures, 3 files, and a database connection, when you get an error then you would have 14 more lines.

In the past this wasn't a problem because C programs did what you've been doing when there's an error: die. No point in bothering with cleanup when the OS will do it for you. Today though many C programs need to run for weeks, months, or years and handle errors from many different sources gracefully. You can't just have your webserver die at the slightest touch, and you definitely can't have a library you've written nuke a the program its used in. That's just rude.

Other languages solve this problem with exceptions, but those have problems in C (and in other languages too). In C you only have one return value, but exceptions are an entire stack based return system with arbitrary values. Trying to marshal exceptions up the stack in C is difficult, and no other libraries will understand it.

// The Debug Macros
The solution I've been using for years is a small set of "debug macros" that implement a basic debugging and error handling system for C. This system is easy to understand, works with every library, and makes C code more solid and clearer.

It does this by adopting the convention that whenever there's an error, your function will jump to an "error:" part of the function that knows how to cleanup everything and return an error code. You use a macro called check to check return codes, print an error message, and then jump to the cleanup section. You combine that with a set of logging functions for printing out useful debug messages.

I'll now show you the entire contents of the most awesome set of brilliance you've ever seen:

	#ifndef __dbg_h__
	#define __dbg_h__

	#include <stdio.h>
	#include <errno.h>
	#include <string.h>

	#ifdef NDEBUG
	#define debug(M, ...)
	#else
	#define debug(M, ...) fprintf(stderr, "DEBUG %s:%d: " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)
	#endif

	#define clean_errno() (errno == 0 ? "None" : strerror(errno))

	#define log_err(M, ...) fprintf(stderr, "[ERROR] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

	#define log_warn(M, ...) fprintf(stderr, "[WARN] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)

	#define log_info(M, ...) fprintf(stderr, "[INFO] (%s:%d) " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)

	#define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

	#define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

	#define check_mem(A) check((A), "Out of memory.")

	#define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__); errno=0; goto error; }

	#endif

Yes, that's it, and here's what every line does:

dbg.h:1-2
The usual defense against accidentally including the file twice, which you saw in the last exercise.

dbg.h:4-6
Includes for the functions that these macros need.

dbg.h:8
The start of a #ifdef which lets you recompile your program so that all the debug log messages are removed.

dbg.h:9
If you compile with NDEBUG defined, then "no debug" messages will remain. You can see in this case the #define debug() is just replaced with nothing (the right side is empty).

dbg.h:10
The matching #else for the above #ifdef.

dbg.h:11
The alternative #define debug that translates any use of debug("format", arg1, arg2) into an fprintf call to stderr. Many C programmers don't know, but you can create macros that actually work like printf and take variable arguments. Some C compilers (actually cpp) don't support this, but the ones that matter do. The magic here is the use of ##__VA_ARGS__ which says "put whatever they had for extra arguments (...) here". Also notice the use of __FILE__ and __LINE__ to get the current file:line for the debug message. Very helpful.

dbg.h:12
The end of the #ifdef.

dbg.h:14
The clean_errno macro that's used in the others to get a safe readable version of errno. That strange syntax in the middle is a "ternary operator" and you'll learn what it does later.

dbg.h:16-20
The log_err, log_warn, and log_info, macros for logging messages meant for the end user. Works like debug but can't be compiled out.

dbg.h:22
The best macro ever, check will make sure the condition A is true, and if not logs the error M (with variable arguments for log_err), then jumps to the function's error: for cleanup.

dbg.h:24
The 2nd best macro ever, sentinel is placed in any part of a function that shouldn't run, and if it does prints an error message then jumps to the error: label. You put this in if-statements and switch-statements to catch conditions that shouldn't happen, like the default:.

dbg.h:26
A short-hand macro check_mem that makes sure a pointer is valid, and if it isn't reports it as an error with "Out of memory."

dbg.h:28
An alternative macro check_debug that still checks and handles an error, but if the error is common then you don't want to bother reporting it. In this one it will use debug instead of log_err to report the message, so when you define NDEBUG the check still happens, the error jump goes off, but the message isn't printed.

// Using dbg.h
Here's an example of using all of dbg.h in a small program. This doesn't actually do anything but demonstrate how to use each macro, but we'll be using these macros in all of the programs we write from now on, so be sure to understand how to use them.

	#include "dbg.h"
	#include <stdlib.h>
	#include <stdio.h>


	void test_debug()
	{
	    // notice you don't need the \n
	    debug("I have Brown Hair.");

	    // passing in arguments like printf
	    debug("I am %d years old.", 37);
	}

	void test_log_err()
	{
	    log_err("I believe everything is broken.");
	    log_err("There are %d problems in %s.", 0, "space");
	}

	void test_log_warn()
	{
	    log_warn("You can safely ignore this.");
	    log_warn("Maybe consider looking at: %s.", "/etc/passwd");
	}

	void test_log_info()
	{
	    log_info("Well I did something mundane.");
	    log_info("It happened %f times today.", 1.3f);
	}

	int test_check(char *file_name)
	{
	    FILE *input = NULL;
	    char *block = NULL;

	    block = malloc(100);
	    check_mem(block); // should work

	    input = fopen(file_name,"r");
	    check(input, "Failed to open %s.", file_name);

	    free(block);
	    fclose(input);
	    return 0;

	error:
	    if(block) free(block);
	    if(input) fclose(input);
	    return -1;
	}

	int test_sentinel(int code)
	{
	    char *temp = malloc(100);
	    check_mem(temp);

	    switch(code) {
		case 1:
		    log_info("It worked.");
		    break;
		default:
		    sentinel("I shouldn't run.");
	    }

	    free(temp);
	    return 0;

	error:
	    if(temp) free(temp);
	    return -1;
	}

	int test_check_mem()
	{
	    char *test = NULL;
	    check_mem(test);

	    free(test);
	    return 1;

	error:
	    return -1;
	}

	int test_check_debug()
	{
	    int i = 0;
	    check_debug(i != 0, "Oops, I was 0.");

	    return 0;
	error:
	    return -1;
	}

	int main(int argc, char *argv[])
	{
	    check(argc == 2, "Need an argument.");

	    test_debug();
	    test_log_err();
	    test_log_warn();
	    test_log_info();

	    check(test_check("ex20.c") == 0, "failed with ex20.c");
	    check(test_check(argv[1]) == -1, "failed with argv");
	    check(test_sentinel(1) == 0, "test_sentinel failed.");
	    check(test_sentinel(100) == -1, "test_sentinel failed.");
	    check(test_check_mem() == -1, "test_check_mem failed.");
	    check(test_check_debug() == -1, "test_check_debug failed.");

	    return 0;

	error:
	    return 1;
	}

Pay attention to how check is used, and how when it is false it will jump to the error: label to do a cleanup. The way to read those lines is, "check that A is true and if not say M and jump out."

// What You Should See
When you run this, give it some bogus first parameter and you should see this:

	$ make ex20
	cc -Wall -g -DNDEBUG    ex20.c   -o ex20
	$ ./ex20 test
	[ERROR] (ex20.c:16: errno: None) I believe everything is broken.
	[ERROR] (ex20.c:17: errno: None) There are 0 problems in space.
	[WARN] (ex20.c:22: errno: None) You can safely ignore this.
	[WARN] (ex20.c:23: errno: None) Maybe consider looking at: /etc/passwd.
	[INFO] (ex20.c:28) Well I did something mundane.
	[INFO] (ex20.c:29) It happened 1.300000 times today.
	[ERROR] (ex20.c:38: errno: No such file or directory) Failed to open test.
	[INFO] (ex20.c:57) It worked.
	[ERROR] (ex20.c:60: errno: None) I shouldn't run.
	[ERROR] (ex20.c:74: errno: None) Out of memory.

See how it reports the exact line number where the check failed? That's going to save you hours of debugging later. See also how it prints the error message for you when errno is set? Again, that will save you hours of debugging.

// How The CPP Expands Macros
It's now time for you to get a small introduction to the CPP so that you know how these macros actually work. To do this, I'm going to break down the most complex macro from dbg.h and have you run cpp so you can see what it's actually doing.

Imagine I have a function called dosomething() that return the typical 0 for success and -1 for an error. Every time I call dosomething I have to check for this error code, so I'd write code like this:

	int rc = dosomething();

	if(rc != 0) {
	    fprintf(stderr, "There was an error: %s\n", strerror());
	    goto error;
	}

What I want to use the CPP for is to encapsulate this if-statement I have to use all the time into a more readable and memorable line of code. I want what you've been doing in dbg.h with the check macro:

	int rc = dosomething();
	check(rc == 0, "There was an error.");

This is much clearer and explains exactly what's going on: check that the function worked, and if not report an error. To do this, we need some special CPP "tricks" that make the CPP useful as a code generation tool. Take a look at the check and log_err macros again:

	#define log_err(M, ...) fprintf(stderr, "[ERROR] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)
	#define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; }

The first macro, log_err is simpler and simply replace itself with a call to fprintf to stderr. The only tricky part of this macro is the use of ... in the definition log_err(M, ...). What this does is let you pass variable arguments to the macro, so you can pass in the arguments that should go to fprintf. How do they get injected into the fprintf call? Look at the end to the ##__VA_ARGS__ and that's telling the CPP to take the args entered where the ... is, and inject them at that part of the fprintf call. You can then do things like this:

	log_err("Age: %d, name: %s", age, name);

The arguments age, name are the ... part of the definition, and those get injected into the fprintf output to become:

	fprintf(stderr, "[ERROR] (%s:%d: errno: %s) Age %d: name %d\n",
	    __FILE__, __LINE__, clean_errno(), age, name);

See the age, name at the end? That's how ... and ##__VA_ARGS__ work together, and it will work in macros that call other variable argument macros. Look at the check macro now and see it calls log_err, but check is also using the ... and ##__VA_ARGS__ to do the call. That's how you can pass full printf style format strings to check, which go to log_err, and then make both work like printf.

Next thing to study is how check crafts the if-statement for the error checking. If we strip out the log_err usage we see this:

	if(!(A)) { errno=0; goto error; }

Which means, if A is false, then clear errno and goto the error label. That has check macro being replaced with the if-statement so if we manually expanded out the macro check(rc == 0, "There was an error.") we'd get:

	if(!(rc == 0)) {
	    log_err("There was an error.");
	    errno=0;
	    goto error;
	}

What you should be getting from this trip through these two macros is that the CPP replaces macros with the expanded version of their definition, but that it will do this recursively, expanding all the macros in macros. The CPP then is just a recursive templating system, as I mentioned before. Its power comes from its ability to generate whole blocks of parameterized code thus becoming a handy code generation tool.

That leaves one question: Why not just use a function like die? The reason is you want file:line numbers and the goto operation for an error handling exit. If you did this inside a function, you wouldn't get a line number for where the error actually happened, and the goto would be much more complicated.

Another reason is you still have to write the raw if-statement, which looks like all the other if-statements in your code, so it's not as clear that this one is an error check. By wrapping the if-statement in a macro called check you make it clear that this is just error checking, and not part of the main flow.

Finally, CPP has the ability to conditionally compile portions of code, so you can have code that's only present when you build a developer or debug version of the program. You can see this already in the dbg.h file where the debug macro has a body only if it's asked for by the compiler. Without this ability, you'd need a wasted if-statement that checks for "debug mode", and then still wastes CPU doing that check for no value.

// Extra Credit
[1] Put #define NDEBUG at the top of the file and check that all the debug messages go away.
[2] Undo that line, and add -DNDEBUG to CFLAGS at the top of the Makefile then recompile to see the same thing.
[3] Modify the logging so that it include the function name as well as the file:line.


//-------------------------------------------------
// topic:	Exercise 21: Advanced Data Types And Flow Control
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
This exercise will be a complete compendium of the available C data types and flow control structures you can use. It will work as a reference to complete your knowledge, and won't have any code for you to enter. I'll have you memorize some of the information by creating flash cards so you can get the important concepts solid in your mind.

For this exercise to be useful, you should spend at least a week hammering the content and filling out all the element I have missing here. You'll be writing out what each one means, and then writing a program to confirm what you've researched.

// Available Data Types
int
Stores a regular integer, defaulting to 32 bits in size.

double
Holds a large floating point number.

float
Holds a smaller floating point number.

char
Holds a single 1 byte character.

void
Indicates "no type" and used to say a function returns nothing, or a pointer has no type as in void *thing.

enum
Enumerated types, work as integers, convert to integers, but give you symbolic names for sets. Some compilers will warn you when you don't cover all elements of an enum in switch-statements.

// Type Modifiers
unsigned
Changes the type so that it does not have negative numbers, giving you a larger upper bound but nothing lower than 0.

signed
Gives you negative and positive numbers, but halves your upper bound in exchange for the same lower bound negative.

long
Uses a larger storage for the type so that it can hold bigger numbers, usually doubling the current size.

short
Uses smaller storage for the type so it stores less, but takes half the space.

// Type Qualifiers
const
Indicates the variable won't change after being initialized.

volatile
Indicates that all bets are off, and the compiler should leave this alone and try not to do any fancy optimizations to it. You usually only need this if you're doing really weird stuff to your variables.

register
Forces the compiler to keep this variable in a register, and the compiler can just ignore you. These days compilers are better at figuring out where to put variables, so only use this if you actually can measure it improving the speed.

// Type Conversion
C uses a sort of "stepped type promotion" mechanism, where it looks at two operands on either side of an expression, and promotes the smaller side to match the larger side before doing the operation. If one side of an expression is on this list, then the other side is converted to that type before the operation is done, and this goes in this order:
[1] long double
[2] double
[3] float
[4] int (but only char and short int);
[5] long

If you find yourself trying to figure out how your conversions are working in an expression, then don't leave it to the compiler. Use explicit casting operations to make it exactly what you want. For example, if you have:

	long + char - int * double

Rather than trying to figure out if it will be converted to double correctly, just use casts:

	(double)long - (double)char - (double)int * double

Putting the type you want in parenthesis before the variable name is how you force it into the type you really need. The important thing though is always promote up, not down. Don't cast long into char unless you know what you're doing.

// Type Sizes
The stdint.h defines both a set of typdefs for exact sized integer types, as well as a set of macros for the sizes of all the types. This is easier to work with than the older limits.h since it is consistent. The types defined are:

int8_t
8 bit signed integer.

uint8_t
8 bit unsigned integer.

int16_t
16 bit signed integer.

uint16_t
16 bit unsigned integer.

int32_t
32 bit signed integer.

uint32_t
32 bit unsigned integer.

int64_t
64 bit signed integer.

uint64_t
64 bit unsigned integer.

The pattern here is of the form (u)int(BITS)_t where a u is put in front to indicate "unsigned", then BITS is a number for the number of bits. This pattern is then repeated for macros that return the maximum values of these types:

INT(N)_MAX
Maximum positive number of the signed integer of bits (N), such as INT16_MAX.

INT(N)_MIN
Minimum negative number of signed integer of bits (N).

UINT(N)_MAX
Maximum positive number of unsigned integer of bits (N). Since it's unsigned the minimum is 0 and can't have a negative value.

// Warning
Pay attention! Do not go looking for a literal INT(N)_MAX definition in any header file. I'm using the (N) as a placeholder for any number of bits your platform currently supports. This (N) could be any number, 8, 16, 32, 64, even maybe 128. I use this notation in this exercise so that I don't have to literally write out every possible combination.

There are also macros in stdint.h for sizes of the size_t type, integers large enough to hold pointers, and other handy size defining macros. Compilers have to at least have these, and then they can allow other larger types.

Here is a full list should be in stdint.h:

int_least(N)_t
holds at least (N) bits.

uint_least(N)_t
holds at least (N) bits unsigned.

INT_LEAST(N)_MAX
max value of the matching least (N) type.

INT_LEAST(N)_MIN
min value of the matching least (N) type.

UINT_LEAST(N)_MAX
unsigned maximum of the matching (N) type.

int_fast(N)_t
similar to int_least*N*_t but asking for the "fastest" with at least that precision.

uint_fast(N)_t
unsigned fastest least integer.

INT_FAST(N)_MAX
max value of the matching fastest (N) type.

INT_FAST(N)_MIN
min value of the matching fastest (N) type.

UINT_FAST(N)_MAX
unsigned max value of the matching fastest (N) type.

intptr_t
a signed integer large enough to hold a pointer.

uintptr_t
an unsigned integer large enough to hold a pointer.

INTPTR_MAX
max value of a intptr_t.

INTPTR_MIN
min value of a intptr_t.

UINTPTR_MAX
unsigned max value of a uintptr_t.

intmax_t
biggest number possible on that system.

uintmax_t
biggest unsigned number possible.

INTMAX_MAX
largest value for the biggest signed number.

INTMAX_MIN
smallest value for the biggest signed number.

UINTMAX_MAX
largest value for the biggest unsigned number.

PTRDIFF_MIN
minimum value of ptrdiff_t.

PTRDIFF_MAX
maximum value of ptrdiff_t.

SIZE_MAX
maximum of a size_t.

// Available Operators
This is a comprehensive list of all the operators you have in the C language. In this list, I'm indicating the following:

(binary)
The operator has a left and right: X + Y.

(unary)
The operator is on its own: -X.

(prefix)
The operator comes before the variable: ++X.

(postfix)
Usually the same as the (prefix) version, but placing it after gives it a different meaning: X++.

(ternary)
There's only one of these, so it's actually called the ternary but it means "three operands": X ? Y : Z.

// Math Operators
These are your basic math operations, plus I put () in with these since it calls a function and is close to a "math" operation.

()
Function call.

* (binary)
multiply.

/
divide.

+ (binary)
addition.

+ (unary)
positive number.

++ (postfix)
read, then increment.

++ (prefix)
increment, then read.

-- (postfix)
read, then decrement.

-- (prefix)
decrement, then read.

- (binary)
subtract.

- (unary)
negative number.

// Data Operators
These are used to access data in different ways and forms.

->
struct pointer access.
.
struct value access.

[]
Array index.

sizeof
size of a type or variable.

& (unary)
Address of.

* (unary)
Value of.

// Logic Operators
These handle testing equality and inequality of variables.

!=
does not equal.

<
less than.

<=
less than or equal.

==
equal (not assignment).

>
greater than.

>=
greater than or equal.

// Bit Operators
These are more advanced and for shifting and modifying the raw bits in integers.

& (binary)
Bitwise and.

<<
Shift left.

>>
Shift right.

^
bitwise xor (exclusive or).

|
bitwise or.

~
compliment (flips all the bits); in other words, inverse

// Boolean Operators
Used in truth testing. Study the ternary operator carefully, it is very handy.

!
not.

&&
and.

||
or.

?:
Ternary truth test, read X ? Y : Z as "if X then Y else Z".

// Assignment Operators
Compound assignment operators that assign a value, and/or perform an operation at the same time. Most of the above operations can also be combined into a compound assignment operator.

=
assign.

%=
modulus assign.

&=
bitwise and assign.

*=
multiply assign.

+=
plus assign.

-=
minus assign.

/=
divide assign.

<<=
shift left, assign.

>>=
shift right, assign.

^=
bitwise xor, assign.

|=
bitwise or, assign.

// Available Control Structures
There's a few control structures you haven't encountered yet:

do-while
do { ... } while(X); First does the code in the block, then tests the X expression before exiting.

break
Put this in a loop, and it breaks out ending it early.

continue
Stops the body of a loop and jumps to the test so it can continue.

goto
Jumps to a spot in the code where you've placed a label:, and you've been using this in the dbg.h macros to go to the error: label.

// Extra Credit
[1] Read stdint.h or a description of it and write out all the possible available size identifiers.
[2] Go through each item here and write out what it does in code. Research it so you know you got it right by looking it up online.
[3] Get this information solid as well by making flash cards and spending 15 minutes a day memorizing it.
[4] Create a program that prints out examples of each type and confirm that your research is right.

//-------------------------------------------------
// topic:	Exercise 22: The Stack, Scope, And Globals
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
The concept of "scope" seems to confuse quite a few people when they first start programming. Originally, it came from the use of the system stack (which we lightly covered earlier) and how it was used to store temporary variables. In this exercise, we'll learn about scope by learning about how a stack data structure works, and then feeding that concept back in to how modern C does scoping.

The real purpose of this exercise though is to learn where the hell things live in C. When someone doesn't grasp the concept of scope, it's almost always a failure in understanding where variables are created, exist, and die. Once you know where things are, the concept of scope becomes easier.

This exercise will require three files:

ex22.h
A header file that sets up some external variables and some functions.

ex22.c
Not your main like normal, but instead a source file that will become a object file ex22.o which will have some functions and variables in it defined from ex22.h.

ex22_main.c
The actual main that will include the other two and demonstrate what they contain as well as other scope concepts.

// ex22.h and ex22.c
Your first step is to create your own header file named ex22.h which defines the functions and "extern" variables you need:

	#ifndef _ex22_h
	#define _ex22_h

	// makes THE_SIZE in ex22.c available to other .c files
	extern int THE_SIZE;

	// gets and sets an internal static variable in ex22.c
	int get_age();
	void set_age(int age);

	// updates a static variable that's inside update_ratio
	double update_ratio(double ratio);

	void print_size();

	#endif

The important thing to see is the use of extern int THE_SIZE, which I'll explain after you also create the matching ex22.c:

	#include <stdio.h>
	#include "ex22.h"
	#include "dbg.h"

	int THE_SIZE = 1000;

	static int THE_AGE = 37;

	int get_age()
	{
	    return THE_AGE;
	}

	void set_age(int age)
	{
	    THE_AGE = age;
	}


	double update_ratio(double new_ratio)
	{
	    static double ratio = 1.0;

	    double old_ratio = ratio;
	    ratio = new_ratio;

	    return old_ratio;
	}

	void print_size()
	{
	    log_info("I think size is: %d", THE_SIZE);
	}

These two files introduce some new kinds of storage for variables:

extern
This keyword is a way to tell the compiler "the variable exists, but it's in another 'external' location". Typically this means that one .c file is going to use a variable that's been defined in another .c file. In this case, we're saying ex22.c has a variable THE_SIZE that will be accessed from ex22_main.c.

static (file)
This keyword is kind of the inverse of extern and says that the variable is only used in this .c file, and should not be available to other parts of the program. Keep in mind that static at the file level (as with THE_AGE here) is different than in other places.

static (function)
If you declare a variable in a function static, then that variable acts like a static defined in the file, but it's only accessible from that function. It's a way of creating constant state for a function, but in reality it's rarely used in modern C programming because they are hard to use with threads.

In these two files then, you have the following variables and functions that you should understand:
[1] THE_SIZE
This is the variable you declared extern that you'll play with from ex22_main.c.

[2] get_age and set_age
These are taking the static variable THE_AGE, but exposing it to other parts of the program through functions. You couldn't access THE_AGE directly, but these functions can.

[3] update_ratio
This takes a new ratio value, and returns the old one. It uses a function level static variable ratio to keep track of what the ratio currently is.

[4] print_size
Prints out what ex22.c thinks THE_SIZE is currently.

// ex22_main.c
Once you have that file written, you can then make the main function which uses all of these and demonstrates some more scope conventions:

	#include "ex22.h"
	#include "dbg.h"

	const char *MY_NAME = "Zed A. Shaw";

	void scope_demo(int count)
	{
	    log_info("count is: %d", count);

	    if(count > 10) {
		int count = 100;  // BAD! BUGS!

		log_info("count in this scope is %d", count);
	    }

	    log_info("count is at exit: %d", count);

	    count = 3000;

	    log_info("count after assign: %d", count);
	}

	int main(int argc, char *argv[])
	{
	    // test out THE_AGE accessors
	    log_info("My name: %s, age: %d", MY_NAME, get_age());

	    set_age(100);

	    log_info("My age is now: %d", get_age());

	    // test out THE_SIZE extern
	    log_info("THE_SIZE is: %d", THE_SIZE);
	    print_size();

	    THE_SIZE = 9;

	    log_info("THE SIZE is now: %d", THE_SIZE);
	    print_size();

	    // test the ratio function static
	    log_info("Ratio at first: %f", update_ratio(2.0));
	    log_info("Ratio again: %f", update_ratio(10.0));
	    log_info("Ratio once more: %f", update_ratio(300.0));

	    // test the scope demo
	    int count = 4;
	    scope_demo(count);
	    scope_demo(count * 20);

	    log_info("count after calling scope_demo: %d", count);

	    return 0;
	}

I'll break this file down line-by-line, and as I do you should find each variable I mention and where it lives.

ex22_main.c:4
Making a const which stands for constant and is an alternative to using a define to create a constant variable.

ex22_main.c:6
A simple function that demonstrates more scope issues in a function.

ex22_main.c:8
Prints out the value of count as it is at the top of the function.

ex22_main.c:10
An if-statement that starts a new scope block, and then has another count variable in it. This version of count is actually a whole new variable. It's kind of like the if-statement started a new "mini function".

ex22_main.c:11
The count that is local to this block is actually different from the one in the function's parameter list. What what happens as we continue.

ex22_main.c:13
Prints it out so you can see it's actually 100 here, not what was passed to scope_demo.

ex22_main.c:16
Now for the freaky part. You have count in two places: the parameters to this function, and in the if-statement. The if-statement created a new block, so the count on line 11 does not impact the parameter with the same name. This line prints it out and you'll see that it prints the value of the parameter, not 100.

ex22_main.c:18-20
Then I set the parameter count to 3000 and print that out, which will demonstrate that you can change function parameters and they don't impact the caller's version of the variable.

// note
Make sure you trace through this function, but don't think that you understand scope quite yet. Just start to realize that if you make a variable inside a block (as in if-statements or while-loops), then those variables are new variables that exist only in that block. This is crucial to understand, and is also a source of many bugs. We'll address why you shouldn't do this shortly.

The rest of the ex22_main.c then demonstrates all of these by manipulating and printing them out:

ex22_main.c:26
Prints out the current values of MY_NAME and gets THE_AGE from ex22.c using the accessor function get_age.

ex22_main.c:27-30
Uses set_age in ex22.c to change THE_AGE and then print it out.

ex22_main.c:33-39
Then I do the same thing to THE_SIZE from ex22.c, but this time I'm accessing it directly, and also demonstrating that it's actually changing in that file by printing it here and with print_size.

ex22_main.c:42-44
Show how the static variable ratio inside update_ratio is maintained between function calls.

ex22_main.c:46-51
Finally running scope_demo a few times so you can see the scope in action. Big thing to notice is that the local count variable remains unchanged. You must get that passing in a variable like this will not let you change it in the function. To do that you need our old friend the pointer. If you were to pass a pointer to this count, then the called function has the address of it and can change it.

That explains what's going on in all of these files, but you should trace through them and make sure you know where everything is as you study it.

// What You Should See
This time, instead of using your Makefile I want you to build these two files manually so you can see how they are actually put together by the compiler. Here's what you should do and what you should see for output.

	$ cc -Wall -g -DNDEBUG   -c -o ex22.o ex22.c
	$ cc -Wall -g -DNDEBUG    ex22_main.c ex22.o   -o ex22_main
	$ ./ex22_main
	[INFO] (ex22_main.c:26) My name: Zed A. Shaw, age: 37
	[INFO] (ex22_main.c:30) My age is now: 100
	[INFO] (ex22_main.c:33) THE_SIZE is: 1000
	[INFO] (ex22.c:32) I think size is: 1000
	[INFO] (ex22_main.c:38) THE SIZE is now: 9
	[INFO] (ex22.c:32) I think size is: 9
	[INFO] (ex22_main.c:42) Ratio at first: 1.000000
	[INFO] (ex22_main.c:43) Ratio again: 2.000000
	[INFO] (ex22_main.c:44) Ratio once more: 10.000000
	[INFO] (ex22_main.c:8) count is: 4
	[INFO] (ex22_main.c:16) count is at exit: 4
	[INFO] (ex22_main.c:20) count after assign: 3000
	[INFO] (ex22_main.c:8) count is: 80
	[INFO] (ex22_main.c:13) count in this scope is 100
	[INFO] (ex22_main.c:16) count is at exit: 80
	[INFO] (ex22_main.c:20) count after assign: 3000
	[INFO] (ex22_main.c:51) count after calling scope_demo: 4

Make sure you trace how each variable is changing and match it to the line that gets output. I'm using log_info from the dbg.h macros so you can get the exact line number where each variable is printed and find it in the files for tracing.

// Scope, Stack, And Bugs
If you've done this right you should now see many of the different ways you can place variables in your C code. You can use extern or access functions like get_age to create globals. You can make new variables inside any blocks, and they'll retain their own values until that block exits, leaving the outer variables alone. You also can pass a value to a function, and change the parameter but not change the caller's version of it.

The most important thing to realize though is that all of this causes bugs. C's ability to place things in many places in your machine and then let you access it in those places means you get confused easily about where something lives. If you don't where it lives then there's a chance you'll not manage it properly.

With that in mind, here's some rules to follow when writing C code so you avoid bugs related to the stack:
[1] Do not "shadow" a variable like I've done here with count in scope_demo. It leaves you open to subtle and hidden bugs where you think you're changing a value and you actually aren't.

[2] Avoid too many globals, especially if across multiple files. If you have to then use accessor functions like I've done with get_age. This doesn't apply to constants, since those are read-only. I'm talking about variables like THE_SIZE. If you want people to modify or set this, then make accessor functions.

[3] When in doubt, put it on the heap. Don't rely on the semantics of the stack or specialized locations and instead just create things with malloc.

[4] Don't use function static variables like I did in update_ratio. They're rarely useful and end up being a huge pain when you need to make your code concurrent in threads. They are also hard as hell to find compared to a well done global variable.

[5] Avoid reusing function parameters as it's confusing whether you're just reusing it or if you think you're changing the caller's version of it.

As with all things, these rules can be broken when it's practical. In fact, I guarantee you'll run into code that breaks all of these rules and is perfectly fine. The constraints of different platforms makes it necessary sometimes.

// How To Break It
For this exercise, breaking the program involves trying to access or change things you can't:
[1] Try to directly access variables in ex22.c from ex22_main.c that you think you can't. For example, you can't get at ratio inside update_ratio? What if you had a pointer to it?
[2] Ditch the extern declaration in ex22.h to see what you get for errors or warnings.
[3] Add static or const specifiers to different variables and then try to change them.

// Extra Credit
[1] Research the concept of "pass by value" vs. "pass by reference". Write an example of both.
[2] Use pointers to gain access to things you shouldn't have access to.
[3] Use valgrind to see what this kind of access looks like when you do it wrong.
[4] Write a recursive function that causes a stack overflow. Don't know what a recursive function is? Try calling scope_demo at the bottom of scope_demo itself so that it loops.
[5] Rewrite the Makefile so that it can build this.


//-------------------------------------------------
// topic:	Exercise 23: Meet Duff's Device
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
This exercise is a brain teaser where I introduce you to one of the most famous hacks in C called "Duff's Device", named after Tom Duff the "inventor". This little slice of awesome (evil?) has nearly everything you've been learning wrapped in one tiny little package. Figuring out how it works is also a good fun puzzle.

// Note
Part of the fun of C is that you can come up with crazy hacks like this, but this is also what makes C annoying to use. It's good to learn about these tricks because it gives you a deeper understanding of the language and your computer. But, you should never use this. Always strive for easy to read code.

Duff's device was "discovered" (created?) by Tom Duff and is a trick with the C compiler that actually shouldn't work. I won't tell you what it does yet since this is meant to be a puzzle for you to ponder and try to solve. You are to get this code running and then try to figure out what it does, and why it does it this way.

	#include <stdio.h>
	#include <string.h>
	#include "dbg.h"


	int normal_copy(char *from, char *to, int count)
	{
	    int i = 0;

	    for(i = 0; i < count; i++) {
		to[i] = from[i];
	    }

	    return i;
	}

	int duffs_device(char *from, char *to, int count)
	{
	    {
		int n = (count + 7) / 8;

		switch(count % 8) {
		    case 0: do { *to++ = *from++;
		                case 7: *to++ = *from++;
		                case 6: *to++ = *from++;
		                case 5: *to++ = *from++;
		                case 4: *to++ = *from++;
		                case 3: *to++ = *from++;
		                case 2: *to++ = *from++;
		                case 1: *to++ = *from++;
		            } while(--n > 0);
		}
	    }

	    return count;
	}

	int zeds_device(char *from, char *to, int count)
	{
	    {
		int n = (count + 7) / 8;

		switch(count % 8) {
		    case 0:
		    again: *to++ = *from++;

		    case 7: *to++ = *from++;
		    case 6: *to++ = *from++;
		    case 5: *to++ = *from++;
		    case 4: *to++ = *from++;
		    case 3: *to++ = *from++;
		    case 2: *to++ = *from++;
		    case 1: *to++ = *from++;
		            if(--n > 0) goto again;
		}
	    }

	    return count;
	}

	int valid_copy(char *data, int count, char expects)
	{
	    int i = 0;
	    for(i = 0; i < count; i++) {
		if(data[i] != expects) {
		    log_err("[%d] %c != %c", i, data[i], expects);
		    return 0;
		}
	    }

	    return 1;
	}


	int main(int argc, char *argv[])
	{
	    char from[1000] = {'a'};
	    char to[1000] = {'c'};
	    int rc = 0;

	    // setup the from to have some stuff
	    memset(from, 'x', 1000);
	    // set it to a failure mode
	    memset(to, 'y', 1000);
	    check(valid_copy(to, 1000, 'y'), "Not initialized right.");

	    // use normal copy to 
	    rc = normal_copy(from, to, 1000);
	    check(rc == 1000, "Normal copy failed: %d", rc);
	    check(valid_copy(to, 1000, 'x'), "Normal copy failed.");

	    // reset
	    memset(to, 'y', 1000);

	    // duffs version
	    rc = duffs_device(from, to, 1000);
	    check(rc == 1000, "Duff's device failed: %d", rc);
	    check(valid_copy(to, 1000, 'x'), "Duff's device failed copy.");

	    // reset
	    memset(to, 'y', 1000);

	    // my version
	    rc = zeds_device(from, to, 1000);
	    check(rc == 1000, "Zed's device failed: %d", rc);
	    check(valid_copy(to, 1000, 'x'), "Zed's device failed copy.");

	    return 0;
	error:
	    return 1;
	}

In this code I have three versions of a copy function:

normal_copy
Which is just a plain for-loop that copies characters from one array to another.

duffs_device
This is the brain teaser called "Duff's Device", named after Tom Duff, the person to blame for this delicious evil.

zeds_device
A version of "Duff's Device" that just uses a goto so you can get a clue about what's happening with the weird do-while placement in duffs_device.

Study these three functions before continuing. Try to explain what's going on to yourself before continuing.

// What You Should See
There's no output from this program, it just runs and exits. You should run it under valgrind and make sure there are no errors.

// Solving The Puzzle
The first thing to understand is that C is rather loose regarding some of its syntax. This is why you can put half of a do-while in one part of a switch-statement, then the other half somewhere else and it will still work. If you look at my version with the goto again it's actually much clear what's going on, but make sure you understand how that part works.

The second thing is how the default fallthrough semantics of switch-statements means you can jump to a particular case, and then it will just keep running until the end of the switch.

The final clue is the count % 8 and the calculation of n at the top.

Now, to solve how these functions work, do the following:
[1] Print this code out so you can write on some paper.
[2] On a piece of paper, write each of the variables in a table as they are when they get initialized right before the switch-statement.
[3] Follow the logic to the switch, then do the jump to the right case.
[4] Update the variables, including the to, from, and the arrays they point at.
[5] When you get to the while part or my goto alternative, check your variables and then follow the logic either back to the top of the do-while or to where the again label is located.
[6] Follow through this manual tracing, updating the variables, until you are sure you see how this flows.

// Why Bother?
When you've figured out how it actually works, the final question is: Why would you ever want to do this? The purpose of this trick is to manually do "loop unrolling". Large long loops can be slow, so one way to speed them up is to find some fixed chunk of the loop, and then just duplicate the code in the loop out that many times sequentially. For example, if you know a loop runs a minimum of 20 times, then you can put the contents of the loop 20 times in the source code.

Duff's device is basically doing this automatically by chunking up the loop into 8 iteration chunks. It's clever and actually works, but these days a good compiler will do this for you. You shouldn't need this except in the rare case where you have proven it would improve your speed.

//Extra Credit
[1] Never use this again.
[2] Go look at the Wikipedia entry for "Duff's Device" and see if you can spot the error. Compare it to the version I have here and read the article carefully to try to understand why the Wikipedia code won't work for you but worked for Tom Duff.
[3] Create a set of macros that lets you create any length device like this. For example, what if you wanted to have 32 case statements and didn't want to write out all of them? Can you do a macro that lays down 8 at a time?
[4] Change the main to conduct some speed tests to see which one is really the fastest.
[5] Read about memcpy, memmove, memset, and also compare their speed.
[5] Never use this again!


//-------------------------------------------------
// topic:	Exercise 24: Input, Output, Files
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
You've been using printf to print things, and that's great and all, but you need more. In this exercise program you're using the functions fscanf and fgets to build information about a person in a structure. After this simple introduction to reading input, you'll get a full list of the functions that C has for I/O. Some of these you've already seen and used, so this will be another memorization exercise.

	#include <stdio.h>
	#include "dbg.h"

	#define MAX_DATA 100

	typedef enum EyeColor {
	    BLUE_EYES, GREEN_EYES, BROWN_EYES,
	    BLACK_EYES, OTHER_EYES
	} EyeColor;

	const char *EYE_COLOR_NAMES[] = {
	    "Blue", "Green", "Brown", "Black", "Other"
	};

	typedef struct Person {
	    int age;
	    char first_name[MAX_DATA];
	    char last_name[MAX_DATA];
	    EyeColor eyes;
	    float income;
	} Person;


	int main(int argc, char *argv[])
	{
	    Person you = {.age = 0};
	    int i = 0;
	    char *in = NULL;

	    printf("What's your First Name? ");
	    in = fgets(you.first_name, MAX_DATA-1, stdin);
	    check(in != NULL, "Failed to read first name.");

	    printf("What's your Last Name? ");
	    in = fgets(you.last_name, MAX_DATA-1, stdin);
	    check(in != NULL, "Failed to read last name.");

	    printf("How old are you? ");
	    int rc = fscanf(stdin, "%d", &you.age);
	    check(rc > 0, "You have to enter a number.");

	    printf("What color are your eyes:\n");
	    for(i = 0; i <= OTHER_EYES; i++) {
		printf("%d) %s\n", i+1, EYE_COLOR_NAMES[i]);
	    }
	    printf("> ");

	    int eyes = -1;
	    rc = fscanf(stdin, "%d", &eyes);
	    check(rc > 0, "You have to enter a number.");

	    you.eyes = eyes - 1;
	    check(you.eyes <= OTHER_EYES && you.eyes >= 0, "Do it right, that's not an option.");

	    printf("How much do you make an hour? ");
	    rc = fscanf(stdin, "%f", &you.income);
	    check(rc > 0, "Enter a floating point number.");

	    printf("----- RESULTS -----\n");

	    printf("First Name: %s", you.first_name);
	    printf("Last Name: %s", you.last_name);
	    printf("Age: %d\n", you.age);
	    printf("Eyes: %s\n", EYE_COLOR_NAMES[you.eyes]);
	    printf("Income: %f\n", you.income);

	    return 0;
	error:

	    return -1;
	}

This program is deceptively simple, and introduces a function called fscanf which is the "file scanf". The scanf family of functions are the inverse of the printf versions. Where printf printed out data based on a format, scanf reads (or scans) input based on a format.

There's nothing original in the beginning of the file, so here's what the main is doing:

ex24.c:24-28
Set up some variables we'll need.

ex24.c:30-32
Get your first name using the fgets function, which reads a string from the input (in this case stdin) but makes sure it doesn't overflow the given buffer.

ex24.c:34-36
Same thing for you.last_name, again using fgets.

ex24.c:38-39
Uses fscanf to read an integer from stdin and put it into you.age. You can see that the same format string is used as printf to print an integer. You should also see that you have to give the address of you.age so that fscanf has a pointer to it and can modify it. This is a good example of using a pointer to a piece of data as an "out parameter".

ex24.c:41-45
Print out all the options available for eye color, with a matching number that works with the EyeColor enum above.

ex24.c:47-50
Using fscanf again, get a number for the you.eyes, but make sure the input is valid. This is important because someone can enter a value outside the EYE_COLOR_NAMES array and cause a segfault.

ex24.c:52-53
Get how much you make as a float for the you.income.

ex24.c:55-61
Print everything out so you can see if you have it right. Notice that EYE_COLOR_NAMES is used to print out what the EyeColor enum is actually called.

// What You Should See
When you run this program you should see your inputs being properly converted. Make sure you try to give it bogus input too so you can see how it protects against the input.

	$ make ex24
	cc -Wall -g -DNDEBUG    ex24.c   -o ex24
	$ ./ex24
	What's your First Name? Zed
	What's your Last Name? Shaw
	How old are you? 37
	What color are your eyes:
	1) Blue
	2) Green
	3) Brown
	4) Black
	5) Other
	> 1
	How much do you make an hour? 1.2345
	----- RESULTS -----
	First Name: Zed
	Last Name: Shaw
	Age: 37
	Eyes: Blue
	Income: 1.234500

// How To Break It
This is all fine and good, but the real important part of this exercise is how scanf actually sucks. It's fine for simple conversion of numbers, but fails for strings because it's difficult to tell scanf how big a buffer is before you read. There's also a problem with a function like gets (not fgets, the non-f version) which we avoided. That function has no idea how big the input buffer is at all and will just trash your program.

To demonstrate the problems with fscanf and strings, change the lines that use fgets so they are fscanf(stdin, "%50s", you.first_name) and then try to use it again. Notice it seems to read too much and then eat your enter key? This doesn't do what you think it does, and really rather than deal with weird scanf issues, just use fgets.

Next, change the fgets to use gets, then bust out your valgrind and do this: valgrind ./ex24 < /dev/urandom to feed random garbage into your program. This is called "fuzzing" your program, and it is a good way to find input bugs. In this case, you're feeding garbage from the /dev/urandom file, and then watching it crash. On some platforms you may have to do this a few times, or even adjust the MAX_DATA define so it's small enough.

The gets function is so bad that some platforms actually warn you when the program runs that you're using gets. You should never use this function, ever.

Finally, take the input for you.eyes and remove the check that the number given is within the right range. Then feed it bad numbers like -1 or 1000. Do this under Valgrind too so you can see what happens.

// The I/O Functions
This is a short list of various I/O functions that you should look up and create index cards that have the function name, what it does, and all the variants similar to it.

[1] fscanf
[2] fgets
[3] fopen
[4] freopen
[5] fdopen
[6] fclose
[7] fcloseall
[8] fgetpos
[9] fseek
[10] ftell
[11] rewind
[12] fprintf
[13] fwrite
[14] fread

Go through these and memorize the different variants and what they do. For example, for the card on fscanf you'll have scanf, sscanf, vscanf, etc. and then what each of those do on the back.

Finally, to get the information you need for these cards, use man to read the help for it. For example, the page for fscanf comes from man fscanf.

// Extra Credit
[1] Rewrite this to not use fscanf at all. You'll need to use functions like atoi to convert the input strings to numbers.
[2] Change this to use plain scanf instead of fscanf to see what the difference is.
[3] Fix it so that the input names get stripped of the trailing newline characters and any whitespace.
[4] Use scanf to write a function that reads a character at a time and files in the names but doesn't go past the end. Make this function generic so it can take a size for the string, and make sure you end the string with '\0' no matter what.

//-------------------------------------------------
// topic:	Exercise 25: Variable Argument Functions
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In C you can create your own versions of functions like printf and scanf by creating a "variable argument function". These functions use the header stdarg.h and with them you can create nicer interfaces to your library. They are handy for certain types of "builder" functions, formatting functions, and anything that takes variable arguments.

Understanding "vararg functions" is not essential to creating C programs. I think I've used it maybe a 20 times in my code in the years I've been programming. However, knowing how a vararg function works will help you debug the ones you use and gives you more understanding of the computer.

	/** WARNING: This code is fresh and potentially isn't correct yet. */

	#include <stdlib.h>
	#include <stdio.h>
	#include <stdarg.h>
	#include "dbg.h"

	#define MAX_DATA 100

	int read_string(char **out_string, int max_buffer)
	{
	    *out_string = calloc(1, max_buffer + 1);
	    check_mem(*out_string);

	    char *result = fgets(*out_string, max_buffer, stdin);
	    check(result != NULL, "Input error.");

	    return 0;

	error:
	    if(*out_string) free(*out_string);
	    *out_string = NULL;
	    return -1;
	}

	int read_int(int *out_int)
	{
	    char *input = NULL;
	    int rc = read_string(&input, MAX_DATA);
	    check(rc == 0, "Failed to read number.");

	    *out_int = atoi(input);

	    free(input);
	    return 0;

	error:
	    if(input) free(input);
	    return -1;
	}

	int read_scan(const char *fmt, ...)
	{
	    int i = 0;
	    int rc = 0;
	    int *out_int = NULL;
	    char *out_char = NULL;
	    char **out_string = NULL;
	    int max_buffer = 0;

	    va_list argp;
	    va_start(argp, fmt);

	    for(i = 0; fmt[i] != '\0'; i++) {
		if(fmt[i] == '%') {
		    i++;
		    switch(fmt[i]) {
		        case '\0':
		            sentinel("Invalid format, you ended with %%.");
		            break;

		        case 'd':
		            out_int = va_arg(argp, int *);
		            rc = read_int(out_int);
		            check(rc == 0, "Failed to read int.");
		            break;

		        case 'c':
		            out_char = va_arg(argp, char *);
		            *out_char = fgetc(stdin);
		            break;

		        case 's':
		            max_buffer = va_arg(argp, int);
		            out_string = va_arg(argp, char **);
		            rc = read_string(out_string, max_buffer);
		            check(rc == 0, "Failed to read string.");
		            break;

		        default:
		            sentinel("Invalid format.");
		    }
		} else {
		    fgetc(stdin);
		}

		check(!feof(stdin) && !ferror(stdin), "Input error.");
	    }

	    va_end(argp);
	    return 0;

	error:
	    va_end(argp);
	    return -1;
	}



	int main(int argc, char *argv[])
	{
	    char *first_name = NULL;
	    char initial = ' ';
	    char *last_name = NULL;
	    int age = 0;

	    printf("What's your first name? ");
	    int rc = read_scan("%s", MAX_DATA, &first_name);
	    check(rc == 0, "Failed first name.");

	    printf("What's your initial? ");
	    rc = read_scan("%c\n", &initial);
	    check(rc == 0, "Failed initial.");

	    printf("What's your last name? ");
	    rc = read_scan("%s", MAX_DATA, &last_name);
	    check(rc == 0, "Failed last name.");

	    printf("How old are you? ");
	    rc = read_scan("%d", &age);

	    printf("---- RESULTS ----\n");
	    printf("First Name: %s", first_name);
	    printf("Initial: '%c'\n", initial);
	    printf("Last Name: %s", last_name);
	    printf("Age: %d\n", age);

	    free(first_name);
	    free(last_name);
	    return 0;
	error:
	    return -1;
	}

This program is similar to the previous exercise, except I have written my own scanf style function that handles strings the way I want. The main function should be clear to you, as well as the two functions read_string and read_int since they do nothing new.

The varargs function is called read_scan and it does the same thing that scanf is doing using the va_list data structure and it's supporting macros and functions. Here's how it works:
[1] I set as the last parameter of the function the keyword ... which indicates to C that this function will take any number of arguments after the fmt argument. I could put many other arguments before this, but I can't put anymore after this.
[2] After setting up some variables, I create a va_list variable and initialize it with va_start. This configures the gear in stdarg.h that handles variable arguments.
[3] I then use a for-loop to loop through the format string fmt and process the same kind of formats that scanf has, but much simpler. I just have integers, characters, and strings.
[4] When I hit a format, I use the switch-statement to figure out what to do.
[5] Now, to get a variable from the va_list argp I use the macro va_arg(argp, TYPE) where TYPE is the exact type of what I will assign this function parameter to. The downside to this design is you're flying blind, so if you don't have enough parameters then oh well, you'll most likely crash.
[6] The interesting difference from scanf is I'm assuming that people want read_scan to create the strings it reads when it hits a 's' format sequence. When you give this sequence, the function takes two parameters off the va_list argp stack: the max function size to read, and the output character string pointer. Using that information it just runs read_string to do the real work.
[7] This makes read_scan more consistent than scanf since you always give an address-of & on variables to have them set appropriately.
[8] Finally, if it encounters a character that's not in the format, it just reads one char to skip it. It doesn't care what that char is, just that it should skip it.

// What You Should See
When you run this one it's similar to the last one:
	$ make ex25
	cc -Wall -g -DNDEBUG    ex25.c   -o ex25
	$ ./ex25
	What's your first name? Zed
	What's your initial? A
	What's your last name? Shaw
	How old are you? 37
	---- RESULTS ----
	First Name: Zed
	Initial: 'A'
	Last Name: Shaw
	Age: 37

// How To Break It
This program should be more robust against buffer overflows, but it doesn't handle the formatted input as well as scanf. To try breaking this, change the code that you forget to pass in the initial size for '%s' formats. Try also giving it more data than MAX_DATA, and then see how not using calloc in read_string changes how it works. Finally, there's a problem that fgets eats the newlines, so try to fix that using fgetc but leave out the \0 that ends the string.

// Extra Credit
[1] Make double and triple sure that you know what each of the out_ variables are doing. Most important is out_string and how it's a pointer to a pointer, so getting when you're setting the pointer vs. the contents is important. Break down each of the
[2] Write a similar function to printf that uses the varargs system and rewrite main to use it.
[3] As usual, read the man page on all of this so you know what it does on your platform. Some platforms will use macros and others use functions, and some have these do nothing. It all depends on the compiler and the platform you use.

//-------------------------------------------------
// topic:	Exercise 26: Write A First Real Program
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
You are at the half-way mark in the book, so you need to take a mid-term. In this mid-term you're going to recreate a piece of software I wrote specifically for this book called devpkg. You'll then extend it in a few key ways and improve the code, most importantly by writing some unit tests for it.
// Note
I wrote this exercise before writing some of the exercises you might need to complete this. If you are attempting this one now, please keep in mind that the software may have bugs, that you might have problems because of my mistakes, and that you might not know everything you need to finish it. If so, tell me at help@learncodethehardway.org and then wait until I finish the other exercises.

// What Is devpkg?
Devpkg is a simple C program that installs other software. I made it specifically for this book as a way to teach you how a real software project is structured, and also how to reuse other people's libraries. It uses a portability library called The Apache Portable Runtime (APR) that has many handy C functions which work on tons of platforms, including Windows. Other than that, it just grabs code from the internet (or local files) and does the usual ./configure ; make ; make install every programmer does.

Your goal in this exercise is to build devpkg from source, finish each Challenge I give, and use the source to understand what devpkg does and why.

// What We Want To Make
We want a tool that has three commands:

devpkg -S
Sets up a new install on a computer.

devpkg -I
Installs a piece of software from a URL.

devpkg -L
Lists all the software that's been installed.

devpkg -F
Fetches some source code for manual building.

devpkg -B
Builds fetches source code and installs it, even if already installed.

We want devpkg to be able to take almost any URL, figure out what kind of project it is, download it, install it, and register that it downloaded that software. We'd also like it to process a simple dependency list so it can install all the software that a project might need as well.

// The Design
To accomplish this goal devpkg will have a very simple design:

Use external commands
You'll do most of the work through external commands like curl, git, and tar. This reduces the amount of code devpkg needs to get things done.

Simple File Database
You could easily make it more complex, but to start you'll just make a single simple file database at /usr/local/.devpkg/db to keep track of what's installed.

/usr/local Always
Again you could make this more advanced, but for starters just assume it's always /usr/local which is a standard install path for most software on Unix.

configure, make, make install
It's assumed that most software can install with just a configure; make; make install and maybe configure is optional. If the software can't at a minimum do that, then there's some options to modify the commands, but otherwise devpkg won't bother.

The User Can Be root
We'll assume the user can become root using sudo, but that they don't want to become root until the end.

This will keep our program small at first and work well enough to get it going, at which point you'll be able to modify it further for this exercise.

// The Apache Portable Runtime
One more thing you'll do is leverage the The Apache Portable Runtime (APR) libraries to get a good set of portable routines for doing this kind of work. The APR isn't necessary, and you could probably write this program without them, but it'd take more code than necessary. I'm also forcing you to use APR now so you get used to linking and using other libraries. Finally, the APR also works on Windows so your skills with it are transferable to many other platforms.

You should go get both the apr-1.4.5 and the apr-util-1.3 libraries, as well as browse through the documentation available at the main APR site at apr.apache.org

Here's a shell script that will install all the stuff you need. You should write this into a file by hand, and then run it until it can install APR without any errors.

	set -e

	# go somewhere safe
	cd /tmp

	# get the source to base APR 1.4.6
	curl -L -O http://archive.apache.org/dist/apr/apr-1.4.6.tar.gz

	# extract it and go into the source
	tar -xzvf apr-1.4.6.tar.gz
	cd apr-1.4.6

	# configure, make, make install
	./configure
	make
	sudo make install

	# reset and cleanup
	cd /tmp
	rm -rf apr-1.4.6 apr-1.4.6.tar.gz

	# do the same with apr-util
	curl -L -O http://archive.apache.org/dist/apr/apr-util-1.4.1.tar.gz

	# extract
	tar -xzvf apr-util-1.4.1.tar.gz
	cd apr-util-1.4.1

	# configure, make, make install
	./configure --with-apr=/usr/local/apr
	# you need that extra parameter to configure because
	# apr-util can't really find it because...who knows.

	make
	sudo make install

	#cleanup
	cd /tmp
	rm -rf apr-util-1.4.1* apr-1.4.6*

I'm having you write this script out because this is basically what we want devpkg to do, but with extra options and checks. In fact, you could just do it all in shell with less code, but then that wouldn't be a very good program for a C book would it?

Simply run this script and fix it until it works, then you'll have the libraries you need to complete the rest of this project.

// Project Layout
You need to setup some simple project files to get started. Here's how I usually craft a new project:
	mkdir devpkg
	cd devpkg
	touch README Makefile

// Other Dependencies
You should have already installed APR and APR-util, so now you need a few more files as basic dependencies:
[1] dbg.h from Exercise 20.
[2] bstrlib.h and bstrlib.c from http://bstring.sourceforge.net/. Download the .zip file, extract it, and copy just those two files out.
[3] Type make bstrlib.o and if it doesn't work, read the "Fixing bstring" instructions below.

// Note
In some platforms the bstring.c file will have an error like:
	bstrlib.c:2762: error: expected declaration specifiers or '...' before numeric constant

This is from a bad define the authors added which doesn't work always. You just need to change the line 2759 that reads #ifdef __GNUC__ and make it:

	#if defined(__GNUC__) && !defined(__APPLE__)

Then it should work on Apple Mac OSX.

When that's all done, you should have a Makefile, README, dbg.h, bstrlib.h, and bstrlib.c ready to go.

// The Makefile
A good place to start is the Makefile since this lays out how things are built and what source files you'll be creating.

	PREFIX?=/usr/local
	CFLAGS=-g -Wall -I${PREFIX}/apr/include/apr-1  -I${PREFIX}/apr/include/apr-util-1
	LDFLAGS=-L${PREFIX}/apr/lib -lapr-1 -pthread -laprutil-1

	all: devpkg

	devpkg: bstrlib.o db.o shell.o commands.o

	install: all
	     install -d $(DESTDIR)/$(PREFIX)/bin/
	     install devpkg $(DESTDIR)/$(PREFIX)/bin/

	clean:
	     rm -f *.o
	     rm -f devpkg
	     rm -rf *.dSYM

There's nothing in this that you haven't seen before, except maybe the strange ?= syntax, which says "set PREFIX equal to this unless PREFIX is already set".

// Note
If you are on more recent versions of Ubuntu and you get errors about apr_off_t or off64_t then add -D_LARGEFILE64_SOURCE=1 to CFLAGS.

Another thing is you need to add /usr/local/apr/lib to a file in /etc/ld.conf.so.d/ then run ldconfig so that it picks up the libraries correctly.

// The Source Files
From the make file, we see that there's four dependencies for devpkg which are:

bstrlib.o
Comes from bstrlib.c and header file bstlib.h which you already have.

db.o
From db.c and header file db.h, and it will contain code for our little "database" routines.

shell.o
From shell.c and header shell.h, with a couple functions that make running other commands like curl easier.

commands.o
From command.c and header command.h, and contains all the commands that devpkg needs to be useful.

devpkg
It's not explicitly mentioned, but instead is the target (on the left) in this part of the Makefile. It comes from devpkg.c which contains the main function for the whole program.

Your job is to now create each of these files and type in their code and get them correct.

// Note
You may read this description and think, "Man! How is it that Zed is so smart he just sat down and typed these files out like this!? I could never do that." I didn't magically craft devpkg in this form with my awesome code powers. Instead, what I did is this:
[1] I wrote a quick little README to get an idea of how I wanted it to work.
[2] I created a simple bash script (like the one you did) to figure out all the pieces that you need.
[3] I made one .c file and hacked on it for a few days working through the idea and figuring it out.
[4] I got it mostly working and debugged, then I started breaking up the one big file into these four files.
[5] After getting these files laid down, I renamed and refined the functions and data structures so they'd be more logical and "pretty".
[6] Finally, after I had it working the exact same but with the new structure, I added a few features like the -F and -B options.

You're reading this in the order I want to teach it to you, but don't think this is how I always build software. Sometimes I already know the subject and I use more planning. Sometimes I just hack up an idea and see how well it'd work. Sometimes I write one, then throw it away and plan out a better one. It all depends on what my experience tells me is best, or where my inspiration takes me.

If you run into an "expert" who tries to tell you there's only one way to solve a programming problem, then they're lying to you. Either they actually use multiple tactics, or they're not very good.

// The DB Functions
There must be a way to record URLs that have been installed, list these URLs, and check if something has already been installed so we can skip it. I'll use a simple flat file database and the bstrlib.h library to do it.

First, create the db.h header file so you know what you'll be implementing.
	#ifndef _db_h
	#define _db_h

	#define DB_FILE "/usr/local/.devpkg/db"
	#define DB_DIR "/usr/local/.devpkg"


	int DB_init();
	int DB_list();
	int DB_update(const char *url);
	int DB_find(const char *url);

	#endif

Then implement those functions in db.c, as you build this, use make like you've been to get it to compile cleanly.

	#include <unistd.h>
	#include <apr_errno.h>
	#include <apr_file_io.h>

	#include "db.h"
	#include "bstrlib.h"
	#include "dbg.h"

	static FILE *DB_open(const char *path, const char *mode)
	{
	    return fopen(path, mode);
	}


	static void DB_close(FILE *db)
	{
	    fclose(db);
	}


	static bstring DB_load()
	{
	    FILE *db = NULL;
	    bstring data = NULL;

	    db = DB_open(DB_FILE, "r");
	    check(db, "Failed to open database: %s", DB_FILE);

	    data = bread((bNread)fread, db);
	    check(data, "Failed to read from db file: %s", DB_FILE);

	    DB_close(db);
	    return data;

	error:
	    if(db) DB_close(db);
	    if(data) bdestroy(data);
	    return NULL;
	}


	int DB_update(const char *url)
	{
	    if(DB_find(url)) {
		log_info("Already recorded as installed: %s", url);
	    }

	    FILE *db = DB_open(DB_FILE, "a+");
	    check(db, "Failed to open DB file: %s", DB_FILE);

	    bstring line = bfromcstr(url);
	    bconchar(line, '\n');
	    int rc = fwrite(line->data, blength(line), 1, db);
	    check(rc == 1, "Failed to append to the db.");

	    return 0;
	error:
	    if(db) DB_close(db);
	    return -1;
	}


	int DB_find(const char *url)
	{
	    bstring data = NULL;
	    bstring line = bfromcstr(url);
	    int res = -1;

	    data = DB_load();
	    check(data, "Failed to load: %s", DB_FILE);

	    if(binstr(data, 0, line) == BSTR_ERR) {
		res = 0;
	    } else {
		res = 1;
	    }

	error: // fallthrough
	    if(data) bdestroy(data);
	    if(line) bdestroy(line);

	    return res;
	}


	int DB_init()
	{
	    apr_pool_t *p = NULL;
	    apr_pool_initialize();
	    apr_pool_create(&p, NULL);

	    if(access(DB_DIR, W_OK | X_OK) == -1) {
		apr_status_t rc = apr_dir_make_recursive(DB_DIR,
		        APR_UREAD | APR_UWRITE | APR_UEXECUTE |
		        APR_GREAD | APR_GWRITE | APR_GEXECUTE, p);
		check(rc == APR_SUCCESS, "Failed to make database dir: %s", DB_DIR);
	    }

	    if(access(DB_FILE, W_OK) == -1) {
		FILE *db = DB_open(DB_FILE, "w");
		check(db, "Cannot open database: %s", DB_FILE);
		DB_close(db);
	    }

	    apr_pool_destroy(p);
	    return 0;

	error:
	    apr_pool_destroy(p);
	    return -1;
	}


	int DB_list()
	{
	    bstring data = DB_load();
	    check(data, "Failed to read load: %s", DB_FILE);

	    printf("%s", bdata(data));
	    bdestroy(data);
	    return 0;

	error:
	    return -1;
	}

// Challenge 1: Code Review
Before continuing, read every line of these files carefully and confirm that you have them entered in exactly. Read them line-by-line backwards to practice that. Also trace each function call and make sure you are using check to validate the return codes. Finally, look up every function that you don't recognize either on the APR web site documentation, or in the bstrlib.h and bstrlib.c source.

// The Shell Functions
A key design decision for devpkg is to do most of the work using external tools like curl, tar, and git. We could find libraries to do all of this internally, but it's pointless if we just need the base features of these programs. There is no shame in running another command in Unix.

To do this I'm going to use the apr_thread_proc.h functions to run programs, but I also want to make a simple kind of "template" system. I'll use a struct Shell that holds all the information needed to run a program, but has "holes" in the arguments list where I can replace them with values.

Look at the shell.h file to see the structure and the commands I'll use. You can see I'm using extern to indicate that other .c files can access variables I'm defining in shell.c.

	#ifndef _shell_h
	#define _shell_h

	#define MAX_COMMAND_ARGS 100

	#include <apr_thread_proc.h>

	typedef struct Shell {
	    const char *dir;
	    const char *exe;

	    apr_procattr_t *attr;
	    apr_proc_t proc;
	    apr_exit_why_e exit_why;
	    int exit_code;

	    const char *args[MAX_COMMAND_ARGS];
	} Shell;

	int Shell_run(apr_pool_t *p, Shell *cmd);
	int Shell_exec(Shell cmd, ...);

	extern Shell CLEANUP_SH;
	extern Shell GIT_SH;
	extern Shell TAR_SH;
	extern Shell CURL_SH;
	extern Shell CONFIGURE_SH;
	extern Shell MAKE_SH;
	extern Shell INSTALL_SH;

	#endif

Make sure you've created shell.h exactly, and that you've got the same names and number of extern Shell variables. Those are used by the Shell_run and Shell_exec functions to run commands. I define these two functions, and create the real variables in shell.c.

	#include "shell.h"
	#include "dbg.h"
	#include <stdarg.h>

	int Shell_exec(Shell template, ...)
	{
	    apr_pool_t *p = NULL;
	    int rc = -1;
	    apr_status_t rv = APR_SUCCESS;
	    va_list argp;
	    const char *key = NULL;
	    const char *arg = NULL;
	    int i = 0;

	    rv = apr_pool_create(&p, NULL);
	    check(rv == APR_SUCCESS, "Failed to create pool.");

	    va_start(argp, template);

	    for(key = va_arg(argp, const char *);
		key != NULL;
		key = va_arg(argp, const char *))
	    {
		arg = va_arg(argp, const char *);

		for(i = 0; template.args[i] != NULL; i++) {
		    if(strcmp(template.args[i], key) == 0) {
		        template.args[i] = arg;
		        break; // found it
		    }
		}
	    }

	    rc = Shell_run(p, &template);
	    apr_pool_destroy(p);
	    va_end(argp);
	    return rc;

	error:
	    if(p) {
		apr_pool_destroy(p);
	    }
	    return rc;
	}

	int Shell_run(apr_pool_t *p, Shell *cmd)
	{
	    apr_procattr_t *attr;
	    apr_status_t rv;
	    apr_proc_t newproc;

	    rv = apr_procattr_create(&attr, p);
	    check(rv == APR_SUCCESS, "Failed to create proc attr.");

	    rv = apr_procattr_io_set(attr, APR_NO_PIPE, APR_NO_PIPE,
		    APR_NO_PIPE);
	    check(rv == APR_SUCCESS, "Failed to set IO of command.");

	    rv = apr_procattr_dir_set(attr, cmd->dir);
	    check(rv == APR_SUCCESS, "Failed to set root to %s", cmd->dir);

	    rv = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH);
	    check(rv == APR_SUCCESS, "Failed to set cmd type.");

	    rv = apr_proc_create(&newproc, cmd->exe, cmd->args, NULL, attr, p);
	    check(rv == APR_SUCCESS, "Failed to run command.");

	    rv = apr_proc_wait(&newproc, &cmd->exit_code, &cmd->exit_why, APR_WAIT);
	    check(rv == APR_CHILD_DONE, "Failed to wait.");

	    check(cmd->exit_code == 0, "%s exited badly.", cmd->exe);
	    check(cmd->exit_why == APR_PROC_EXIT, "%s was killed or crashed", cmd->exe);

	    return 0;

	error:
	    return -1;
	}

	Shell CLEANUP_SH = {
	    .exe = "rm",
	    .dir = "/tmp",
	    .args = {"rm", "-rf", "/tmp/pkg-build", "/tmp/pkg-src.tar.gz",
		"/tmp/pkg-src.tar.bz2", "/tmp/DEPENDS", NULL}
	};

	Shell GIT_SH = {
	    .dir = "/tmp",
	    .exe = "git",
	    .args = {"git", "clone", "URL", "pkg-build", NULL}
	};

	Shell TAR_SH = {
	    .dir = "/tmp/pkg-build",
	    .exe = "tar",
	    .args = {"tar", "-xzf", "FILE", "--strip-components", "1", NULL}
	};

	Shell CURL_SH = {
	    .dir = "/tmp",
	    .exe = "curl",
	    .args = {"curl", "-L", "-o", "TARGET", "URL", NULL}
	};

	Shell CONFIGURE_SH = {
	    .exe = "./configure",
	    .dir = "/tmp/pkg-build",
	    .args = {"configure", "OPTS", NULL},
	};

	Shell MAKE_SH = {
	    .exe = "make",
	    .dir = "/tmp/pkg-build",
	    .args = {"make", "OPTS", NULL}
	};

	Shell INSTALL_SH = {
	    .exe = "sudo",
	    .dir = "/tmp/pkg-build",
	    .args = {"sudo", "make", "TARGET", NULL}
	};

Read the shell.c from the bottom to the top (which is a common C source layout) and you see I've created the actual Shell variables that you indicated were extern in shell.h. They live here, but are available to the rest of the program. This is how you make global variables that live in one .o file but are used everywhere. You shouldn't make many of these, but they are handy for things like this.

Continuing up the file we get to the Shell_run function, which is a "base" function that just runs a command based on what's in a Shell struct. It uses many of the functions defined in apr_thread_proc.h so go look up each one to see how it works. This seems like a lot of work compared to just using the system function call, but this also gives you more control over the other program's execution. For example, in our Shell struct we have a .dir attribute which forces the program to be in a specific directory before running.

Finally, I have the Shell_exec function, which is a "variable arguments" function. You've seen this before, but make sure you grasp the stdarg.h functions and how to write one of these. In the challenge for this section you are going to analyze this function.

// Challenge 2: Analyze Shell_exec
Challenge for these files (in addition to a full code review just like you did in Challenge 1) is to fully analyze Shell_exec and break down exactly how it works. You should be able to understand each line, how the two for-loops work, and how arguments are being replaced.

Once you have it analyzed, add a field to struct Shell that gives the number of variable args that must be replaced. Update all the commands to have the right count of args, and then have an error check that confirms these args have been replaced and error exit.

// The Command Functions
Now you get to make the actual commands that do the work. These commands will use functions from APR, db.h and shell.h to do the real work of downloading and building software you want it to build. This is the most complex set of files, so do them carefully. As before, you start by making the commands.h file, then implementing its functions in the commands.c file.

	#ifndef _commands_h
	#define _commands_h

	#include <apr_pools.h>

	#define DEPENDS_PATH "/tmp/DEPENDS"
	#define TAR_GZ_SRC "/tmp/pkg-src.tar.gz"
	#define TAR_BZ2_SRC "/tmp/pkg-src.tar.bz2"
	#define BUILD_DIR "/tmp/pkg-build"
	#define GIT_PAT "*.git"
	#define DEPEND_PAT "*DEPENDS"
	#define TAR_GZ_PAT "*.tar.gz"
	#define TAR_BZ2_PAT "*.tar.bz2"
	#define CONFIG_SCRIPT "/tmp/pkg-build/configure"

	enum CommandType {
	    COMMAND_NONE, COMMAND_INSTALL, COMMAND_LIST, COMMAND_FETCH,
	    COMMAND_INIT, COMMAND_BUILD
	};


	int Command_fetch(apr_pool_t *p, const char *url, int fetch_only);

	int Command_install(apr_pool_t *p, const char *url, const char *configure_opts,
		const char *make_opts, const char *install_opts);

	int Command_depends(apr_pool_t *p, const char *path);

	int Command_build(apr_pool_t *p, const char *url, const char *configure_opts,
		const char *make_opts, const char *install_opts);

	#endif

There's not much in commands.h that you haven't seen already. You should see that there's some defines for strings that are used everywhere. The real interesting code is in commands.c.

	#include <apr_uri.h>
	#include <apr_fnmatch.h>
	#include <unistd.h>

	#include "commands.h"
	#include "dbg.h"
	#include "bstrlib.h"
	#include "db.h"
	#include "shell.h"


	int Command_depends(apr_pool_t *p, const char *path)
	{
	    FILE *in = NULL;
	    bstring line = NULL;

	    in = fopen(path, "r");
	    check(in != NULL, "Failed to open downloaded depends: %s", path);

	    for(line = bgets((bNgetc)fgetc, in, '\n'); line != NULL;
		    line = bgets((bNgetc)fgetc, in, '\n'))
	    {
		btrimws(line);
		log_info("Processing depends: %s", bdata(line));
		int rc = Command_install(p, bdata(line), NULL, NULL, NULL);
		check(rc == 0, "Failed to install: %s", bdata(line));
		bdestroy(line);
	    }

	    fclose(in);
	    return 0;

	error:
	    if(line) bdestroy(line);
	    if(in) fclose(in);
	    return -1;
	}

	int Command_fetch(apr_pool_t *p, const char *url, int fetch_only)
	{
	    apr_uri_t info = {.port = 0};
	    int rc = 0;
	    const char *depends_file = NULL;
	    apr_status_t rv = apr_uri_parse(p, url, &info);

	    check(rv == APR_SUCCESS, "Failed to parse URL: %s", url);

	    if(apr_fnmatch(GIT_PAT, info.path, 0) == APR_SUCCESS) {
		rc = Shell_exec(GIT_SH, "URL", url, NULL);
		check(rc == 0, "git failed.");
	    } else if(apr_fnmatch(DEPEND_PAT, info.path, 0) == APR_SUCCESS) {
		check(!fetch_only, "No point in fetching a DEPENDS file.");

		if(info.scheme) {
		    depends_file = DEPENDS_PATH;
		    rc = Shell_exec(CURL_SH, "URL", url, "TARGET", depends_file, NULL);
		    check(rc == 0, "Curl failed.");
		} else {
		    depends_file = info.path;
		}

		// recursively process the devpkg list
		log_info("Building according to DEPENDS: %s", url);
		rv = Command_depends(p, depends_file);
		check(rv == 0, "Failed to process the DEPENDS: %s", url);

		// this indicates that nothing needs to be done
		return 0;

	    } else if(apr_fnmatch(TAR_GZ_PAT, info.path, 0) == APR_SUCCESS) {
		if(info.scheme) {
		    rc = Shell_exec(CURL_SH,
		            "URL", url,
		            "TARGET", TAR_GZ_SRC, NULL);
		    check(rc == 0, "Failed to curl source: %s", url);
		}

		rv = apr_dir_make_recursive(BUILD_DIR,
		        APR_UREAD | APR_UWRITE | APR_UEXECUTE, p);
		check(rv == APR_SUCCESS, "Failed to make directory %s", BUILD_DIR);

		rc = Shell_exec(TAR_SH, "FILE", TAR_GZ_SRC, NULL);
		check(rc == 0, "Failed to untar %s", TAR_GZ_SRC);
	    } else if(apr_fnmatch(TAR_BZ2_PAT, info.path, 0) == APR_SUCCESS) {
		if(info.scheme) {
		    rc = Shell_exec(CURL_SH, "URL", url, "TARGET", TAR_BZ2_SRC, NULL);
		    check(rc == 0, "Curl failed.");
		}

		apr_status_t rc = apr_dir_make_recursive(BUILD_DIR,
		        APR_UREAD | APR_UWRITE | APR_UEXECUTE, p);

		check(rc == 0, "Failed to make directory %s", BUILD_DIR);
		rc = Shell_exec(TAR_SH, "FILE", TAR_BZ2_SRC, NULL);
		check(rc == 0, "Failed to untar %s", TAR_BZ2_SRC);
	    } else {
		sentinel("Don't now how to handle %s", url);
	    }

	    // indicates that an install needs to actually run
	    return 1;
	error:
	    return -1;
	}

	int Command_build(apr_pool_t *p, const char *url, const char *configure_opts,
		const char *make_opts, const char *install_opts)
	{
	    int rc = 0;

	    check(access(BUILD_DIR, X_OK | R_OK | W_OK) == 0,
		    "Build directory doesn't exist: %s", BUILD_DIR);

	    // actually do an install
	    if(access(CONFIG_SCRIPT, X_OK) == 0) {
		log_info("Has a configure script, running it.");
		rc = Shell_exec(CONFIGURE_SH, "OPTS", configure_opts, NULL);
		check(rc == 0, "Failed to configure.");
	    }

	    rc = Shell_exec(MAKE_SH, "OPTS", make_opts, NULL);
	    check(rc == 0, "Failed to build.");

	    rc = Shell_exec(INSTALL_SH,
		    "TARGET", install_opts ? install_opts : "install",
		    NULL);
	    check(rc == 0, "Failed to install.");

	    rc = Shell_exec(CLEANUP_SH, NULL);
	    check(rc == 0, "Failed to cleanup after build.");

	    rc = DB_update(url);
	    check(rc == 0, "Failed to add this package to the database.");

	    return 0;

	error:
	    return -1;
	}

	int Command_install(apr_pool_t *p, const char *url, const char *configure_opts,
		const char *make_opts, const char *install_opts)
	{
	    int rc = 0;
	    check(Shell_exec(CLEANUP_SH, NULL) == 0, "Failed to cleanup before building.");

	    rc = DB_find(url);
	    check(rc != -1, "Error checking the install database.");

	    if(rc == 1) {
		log_info("Package %s already installed.", url);
		return 0;
	    }

	    rc = Command_fetch(p, url, 0);

	    if(rc == 1) {
		rc = Command_build(p, url, configure_opts, make_opts, install_opts);
		check(rc == 0, "Failed to build: %s", url);
	    } else if(rc == 0) {
		// no install needed
		log_info("Depends successfully installed: %s", url);
	    } else {
		// had an error
		sentinel("Install failed: %s", url);
	    }

	    Shell_exec(CLEANUP_SH, NULL);
	    return 0;

	error:
	    Shell_exec(CLEANUP_SH, NULL);
	    return -1;
	}

After you have this entered in and compiling, you can analyze it. If you've don the challenges until now, you should see how the shell.c functions are being used to run shells and how the arguments are being replaced. If not then go back and make sure you truly understand how Shell_exec actually works.

// Challenge 3: Critique My Design
As before, do a complete review of this code and make sure it's exactly the same. Then go through each function and make sure you know how it works and what it's doing. You also should trace how each function calls the other functions you've written in this file and other files. Finally, confirm that you understand all the functions you're calling from APR here.

Once you have the file correct and analyzed, go back through and assume I'm an idiot. Then, criticize the design I have to see how you can improve it if you can. Don't actually change the code, just create a little notes.txt file and write down your thoughts and what you might change.

// The devpkg Main Function
	#include <stdio.h>
	#include <apr_general.h>
	#include <apr_getopt.h>
	#include <apr_strings.h>
	#include <apr_lib.h>

	#include "dbg.h"
	#include "db.h"
	#include "commands.h"

	int main(int argc, const char const *argv[])
	{
	    apr_pool_t *p = NULL;
	    apr_pool_initialize();
	    apr_pool_create(&p, NULL);

	    apr_getopt_t *opt;
	    apr_status_t rv;

	    char ch = '\0';
	    const char *optarg = NULL;
	    const char *config_opts = NULL;
	    const char *install_opts = NULL;
	    const char *make_opts = NULL;
	    const char *url = NULL;
	    enum CommandType request = COMMAND_NONE;


	    rv = apr_getopt_init(&opt, p, argc, argv);

	    while(apr_getopt(opt, "I:Lc:m:i:d:SF:B:", &ch, &optarg) == APR_SUCCESS) {
		switch (ch) {
		    case 'I':
		        request = COMMAND_INSTALL;
		        url = optarg;
		        break;

		    case 'L':
		        request = COMMAND_LIST;
		        break;

		    case 'c':
		        config_opts = optarg;
		        break;

		    case 'm':
		        make_opts = optarg;
		        break;

		    case 'i':
		        install_opts = optarg;
		        break;

		    case 'S':
		        request = COMMAND_INIT;
		        break;

		    case 'F':
		        request = COMMAND_FETCH;
		        url = optarg;
		        break;

		    case 'B':
		        request = COMMAND_BUILD;
		        url = optarg;
		        break;
		}
	    }

	    switch(request) {
		case COMMAND_INSTALL:
		    check(url, "You must at least give a URL.");
		    Command_install(p, url, config_opts, make_opts, install_opts);
		    break;

		case COMMAND_LIST:
		    DB_list();
		    break;

		case COMMAND_FETCH:
		    check(url != NULL, "You must give a URL.");
		    Command_fetch(p, url, 1);
		    log_info("Downloaded to %s and in /tmp/", BUILD_DIR);
		    break;

		case COMMAND_BUILD:
		    check(url, "You must at least give a URL.");
		    Command_build(p, url, config_opts, make_opts, install_opts);
		    break;

		case COMMAND_INIT:
		    rv = DB_init();
		    check(rv == 0, "Failed to make the database.");
		    break;

		default:
		    sentinel("Invalid command given.");
	    }


	    return 0;

	error:
	    return 1;
	}

// Challenge 4: The README And Test Files
The challenge for this file is to understand how the arguments are being processed, what the arguments are, and then create the README file with instructions on how to use it. As you write the README, also write a simple test.sh that runs ./devpkg to check that each command is actually working against real live code. Use the set -e at the top of your script so that it aborts on the first error.

Finally, run the program under valgrind and make sure it's all working before moving on to the mid-term exam.

// The Mid-Term Exam
Your final challenge is the mid-term exam and it involves three things:
[1] Compare your code to my code available online and starting with 100%, remove 1% for each line you got wrong.
[2] Take your notes.txt on how you would improve the code and functionality of devpkg and implement your improvements.
[3] Write an alternative version of devpkg using your other favorite language or the one you think can do this the best. Compare the two, then improve your C version of devpkg based on what you've learned.

To compare your code with mine, do the following:
	cd ..  # get one directory above your current one
	git clone git://gitorious.org/devpkg/devpkg.git devpkgzed
	diff -r devpkg devpkgzed

This will clone my version of devpkg into a directory devpkgzed and then use the tool diff to compare what you've done to what I did. The files you're working with in this book come directly from this project, so if you get different lines then that's an error.

Keep in mind that there's no real pass or fail on this exercise, just a way for you to challenge yourself to be as exact and meticulous as possible.

//-------------------------------------------------
// topic:	Exercise 27: Creative And Defensive Programming
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
You have now learned most of the basics of C programming and are ready to start becoming a serious programmer. This is where you go from beginner to expert, both with C and hopefully with core computer science concepts. I will be teaching you a few of the core data structures and algorithms that every programmer should know, and then a few very interesting ones I've used in real software for years.

Before I can do that I have to teach you some basic skills and ideas that will help you make better software. Exercises 27 through 31 will teach you advanced concepts and feature more talking than code, but after those you'll apply what you learn to making a core library of useful data structures.

The first step in getting better at writing C code (and really any language) is to learn a new mindset called "defensive programming". Defensive programming assumes that you are going to make many mistakes and then attempts to prevent them at every possible step. In this exercise I'm going to teach you how to think about programming defensively.

// The Creative Programmer Mindset
It's not possible to tell you how to be creative in a short exercise like this, but I will tell you that creativity involves taking risks and being open minded. Fear will quickly kill creativity, so the mindset I adopt, and many programmers adopt on, accident is designed to make me unafraid of taking chances and looking like an idiot:
[1] I can't make a mistake.
[2] It doesn't matter what people think.
[3] Whatever my brain comes up with is going to be a great idea.

I only adopt this mindset temporarily, and even have little tricks to turn it on. By doing this I can come up with ideas, find creative solutions, open my thoughts to odd connections, and just generally invent weirdness without fear. In this mindset I will typically write a horrible first version of something just to get the idea out.

However, when I've finished my creative prototype I will throw it out and get serious about making it solid. Where other people make a mistake is carrying the creative mindset into their implementation phase. This then leads to a very different destructive mindset that is the dark side of the creative mindset:
[1] It is possible to write perfect software.
[2] My brain tells me the truth, and it can't find any errors, therefore I have written perfect software.
[3] My code is who I am and people who criticize its perfection are criticizing me.

These are lies. You will frequently run into programmers who feel intense pride about what they've created, which is natural, but this pride gets in the way of their ability to objectively improve their craft. Because of pride and attachment to what they've written, they can continue to believe that what they write is perfect. As long as they ignore other people's criticism of their code they can protect their fragile ego and never improve.

The trick to being creative and making solid software is to also be able to adopt a defensive programming mindset.

// The Defensive Programmer Mindset
After you have a working creative prototype and you're feeling good about the idea, it's time to switch to being a defensive programmer. The defensive programmer basically hates your code and believes these things:
[1] Software has errors.
[2] You are not your software, yet you are are responsible for the errors.
[3] You can never remove the errors, only reduce their probability.

This mindset lets you be honest about your work and critically analyze it for improvements. Notice that it doesn't say you are full of errors? It says your code is full of errors. This is a significant thing to understand because it gives you the power of objectivity for the next implementation.

Just like the creative mindset, the defensive programming mindset has a dark side as well. The defensive programmer is a paranoid who is afraid of everything, and this fear prevents them from possibly being wrong or making mistakes. That's great when you are trying to be ruthlessly consistent and correct, but it is murder on creative energy and concentration.

// The Eight Defensive Programmer Strategies
Once you've adopted this mindset, you can then rewrite your prototype and follow a set of eight strategies I use to make my code as solid as I can. While I work on the "real" version I ruthlessly follow these strategies and try to remove as many errors as I can, thinking like someone who wants to break the software.

[1] Never Trust Input: Never trust the data you are given and always validate it.
[2] Prevent Errors: If an error is possible, no matter how probable, try to prevent it.
[3] Fail Early And Openly: Fail early, cleanly, and openly, stating what happened, where and how to fix it.
[4] Document Assumptions: Clearly state the pre-conditions, post-conditions, and invariants.
[5] Prevention Over Documentation: Do not do with documentation, that which can be done with code or avoided completely.
[6] Automate Everything: Automate everything, especially testing.
[7] Simplify And Clarify: Always simplify the code to the smallest, cleanest form that works without sacrificing safety.
[8] Question Authority: Do not blindly follow or reject rules.

These aren't the only ones, but they're the core things I feel programmers have to focus on when trying to make good solid code. Notice that I don't really say exactly how to do these. I'll go into each of these in more detail, and some of the exercises actually cover them extensively.

// Applying The Eight Strategies
These ideas are all great pop-psychology platitudes, but how do you actually apply them to working code? I'm now going to give you a set of things to always do in this book's code that demonstrate each one with a concrete example. The ideas aren't limited to these examples, and you should use these as a guide to making your own code tougher.

// Never Trust Input
Let's look at an example of bad design and "better" design. I won't say good design because this could be done even better. Take a look at two functions that both copy a string and a simple main to test out the better one.
	#undef NDEBUG
	#include "dbg.h"
	#include <stdio.h>
	#include <assert.h>

	/*
	 * Naive copy that assumes all inputs are always valid
	 * taken from K&R C and cleaned up a bit.
	 */
	void copy(char to[], char from[])
	{
	    int i = 0;

	    // while loop will not end if from isn't '\0' terminated
	    while((to[i] = from[i]) != '\0') {
		++i;
	    }
	}

	/*
	 * A safer version that checks for many common errors using the
	 * length of each string to control the loops and termination.
	 */
	int safercopy(int from_len, char *from, int to_len, char *to)
	{
	    assert(from != NULL && to != NULL && "from and to can't be NULL");
	    int i = 0;
	    int max = from_len > to_len - 1 ? to_len - 1 : from_len;

	    // to_len must have at least 1 byte
	    if(from_len < 0 || to_len <= 0) return -1;

	    for(i = 0; i < max; i++) {
		to[i] = from[i];
	    }

	    to[to_len - 1] = '\0';

	    return i;
	}


	int main(int argc, char *argv[])
	{
	    // careful to understand why we can get these sizes
	    char from[] = "0123456789";
	    int from_len = sizeof(from);

	    // notice that it's 7 chars + \0
	    char to[] = "0123456";
	    int to_len = sizeof(to);

	    debug("Copying '%s':%d to '%s':%d", from, from_len, to, to_len);

	    int rc = safercopy(from_len, from, to_len, to);
	    check(rc > 0, "Failed to safercopy.");
	    check(to[to_len - 1] == '\0', "String not terminated.");

	    debug("Result is: '%s':%d", to, to_len);

	    // now try to break it
	    rc = safercopy(from_len * -1, from, to_len, to);
	    check(rc == -1, "safercopy should fail #1");
	    check(to[to_len - 1] == '\0', "String not terminated.");

	    rc = safercopy(from_len, from, 0, to);
	    check(rc == -1, "safercopy should fail #2");
	    check(to[to_len - 1] == '\0', "String not terminated.");

	    return 0;

	error:
	    return 1;
	}

The copy function is typical C code and it's the source of a huge number of buffer overflows. It is flawed because it assumes that it will always receive a validly terminated C string (with '\0') and just uses a while-loop to process it. Problem is, ensuring that is incredibly difficult, and if not handled right it causes the while-loop to loop infinitely. A cornerstone of writing solid code is never writing loops that can possibly loop forever.

The safercopy function tries to solve this by requiring the caller to give the lengths of the two strings it must deal with. By doing this it can make certain checks about these strings that the copy function can't. It can check the lengths are right, that the to string has enough space, and it will always terminate. It's impossible for this function to run on forever like the copy function.

This is the idea behind never trusting the inputs you receive. If you assume that your function is going to get a string that's not terminated (which is common) then you design your function to not rely on that to function properly. If you need the arguments to never be NULL then you should check for that too. If the sizes should be within sane levels, then check that. You simply assume that whoever is calling you got it wrong and try to make it difficult for them to give you bad state.

This then extends out to software you write that gets input from the external universe. The famous last words of the programmer are, "Nobody's going to do that." I've seen them say that and then the next day someone does exactly that, crashing or hacking their application. If you say nobody is going to do that, just throw in the code to make sure they simply can't hack your application. You'll be glad you did.

There is a diminishing returns on this, but here's a list of things I try to do with all of my functions I write in C:
[1] For each parameter identify what its preconditions are, and whether the precondition should cause a failure or return an error. If you are writing a library, favor errors over failures.

[2] Add assert calls at the beginning that checks for each failure precondition using assert(test && "message"); This little hack does the test, and when it fails the OS will typically print the assert line for you, which then includes that message. Very helpful when you're trying to figure out why that assert is there.

[3] For the other preconditions, return the error code or use my check macro to do that and give an error message. I didn't use check in this example since it would confuse the comparison.

[4] Document why these preconditions exist so that when a programmer hits the error they can figure out if they are really necessary or not.

[5] If you are modifying the inputs, make sure that they are correctly formed when the function exits, or abort if they aren't.

[6] Always check the error codes of functions you use. For example, people frequently forget to check the return codes from fopen or fread which causes them to use the resources they give despite the error. This causes your program to crash or gives an avenue for an attack.

[7] You also need to be returning consistent error codes so that you can do this for all of your functions too. Once you get in this habit you will then understand why my check macros work the way they do.

Just doing these simple things will improve your resource handling and prevent quite a few errors.

// Prevent Errors
In the previous example you may hear people say, "Well it's not very likely someone will use copy wrong." Despite the mountain of attacks made against this very kind of function they still believe that the probability of this error is very low. Probability is a funny thing because people are incredibly bad at guessing the probability of any event. People are however much better at determining if something is possible. They may say the error in copy is not probably, but they can't deny that it's possible.

The key reason is that for something to be probable, it first has to be possible. Determining the possibility is easy, since we can all imagine something happening. What's not so easy is determining its possibility after that. Is the chance that someone might use copy wrong 20%, 10%, or 1%? Who knows, and to determine that you'd need to gather evidence, look at rates of failure in many software packages, and probably survey real programmers and how they use the function.

This means, if you're going to prevent errors then you need to try to prevent what is possible, but focus your energies on what's most probable first. It may not be feasible to handle all the possible ways your software can be broken, but you have to attempt it. But, at the same time, if you don't constrain your efforts to the most probably events with the least effort then you'll be wasting time on irrelevant attacks.

Here's a process for determining what to prevent in your software:
[1] List all the possible errors that can happen, no matter how probable. Within reason of course. No point listing aliens sucking your memories out to steal your passwords.

[2] Give each one a probability that's a percentage of operations that can be vulnerable. If you are handling requests from the internet, then it's the percentage of requests that can cause the error. If it's function calls, then it's what percentage of function calls can cause it.

[3] Give each one an effort in number of hours or amount of code to prevent it. You could also just give an easy or hard metric. Any metric that prevents you from working on the impossible when there's easier things to fix still on the list.

[4] Rank them by effort (lowest to highest), and probability (highest to lowest). This is now your task list.

[5] Prevent all the errors you can in this list, aiming for removing the possibility, then reducing the probability if you can't make it impossible.

[6] If there are errors you can't fix, then document them so someone else can fix it.

This little process will give you a nice list of things to do, but more importantly keep you from working on useless things when there's other more important things to work on. You can also be more or less formal with this process. If you're doing a full security audit this will be better done with a whole team and a nice spreadsheet. If you're just writing a function then simply reviewing the code and scratching out these into some comments is good enough. What's important is you stop assuming that errors don't happen, and you work on removing them when you can without wasting effort.

// Fail Early And Openly
If you encounter an error in C you have two choices:
[1] Return an error code.
[2] Abort the process.

This is just how it is, so what you need to do is make sure the failures happen quickly, are clearly documented, give an error message, and are easy for the programmer to avoid. This is why the check macros I've given you work the way they do. For every error you find it prints a message, the file and line number where it happened, and force a return code. If you just use my macros you'll end up doing the right thing anyway.

I tend to prefer returning error code to aborting the program. If it's catastrophic then I will, but very few errors are truly catastrophic. A good example of when I'll abort a program is if I'm given an invalid pointer, as I did in safercopy. Instead of having the programmer experience a segmentation fault explosion "somewhere", I catch it right away and abort. However, if it's common to pass in a NULL then I'll probably change that to a check instead so that the caller can adapt and keep running.

In libraries however, I try my hardest to never abort. The software using my library can decide if it should abort, and typically I'll only abort if the library is very badly used.

Finally, a big part of being "open" about errors is not using the same message or error code for more than one possible error. You typically see this with errors on external resources. A library will receive an error on a socket, and then simply report "bad socket". What they should do is return exactly what the error was on the socket so it can be debugged properly and fixed. When designing your error reporting, make sure you give a different error message for the different possible errors.

// Document Assumptions
If you're following along and doing this advice then what you'll be doing is building a "contract" of how your functions expect the world to be. You've created preconditions for each argument, you've handled possible errors, and you're failing elegantly. The next step is to complete the contract and add "invariants" and "postconditions".

An invariant is some condition that must be held true in some state while the function runs. This isn't very common in simple functions, but when you're dealing with complex structures it becomes more necessary. A good example of an invariant is that a structure is always initialized properly while it's being used. Another would be that a sorted data structure is always sorted during processing.

A postcondition is a guarantee on the exit value or result of a function running. This can blend together with invariants, but this is something as simple as "function always returns 0 or -1 on error". Usually these are documented, but if your function returns an allocated resource, you can add a postcondition that checks to make sure it's returning something and not NULL. Or, you can use NULL to indicate an error, so in that case your postcondition is now checking the resource is deallocated on any errors.

In C programming invariants and postconditions are usually more documentation than actual code and assertions. The best way to handle them is add assert calls for the ones you can, then document the rest. If you do that then when people hit an error they can see what assumptions you made when writing the function.

// Prevention Over Documentation
A common problem when programmers write code is they will document a common bug rather than simply fix it. My favorite is when the Ruby on Rails system simply assumed that all months had 30 days. Calendars are hard, so rather than fix it they threw a tiny little comment somewhere that said this was on purpose, and then they refused to fix it for years. Every time someone would complain they would then bluster and yell, "But it's documented!"

Documentation doesn't matter if you can actually fix the problem, and if the function has a fatal flaw then simply don't include it until you can fix it. In the case of Ruby on Rails, not having date functions would have been better than including purposefully broken ones that nobody could use.

As you go through your defensive programming cleanups, try to fix everything you can. If you find yourself documenting more and more problems you can't fix, then consider redesigning the feature or simply removing it. If you really have to keep this horribly broken feature, then I suggest you write it, document it and find a new job before you are blamed for it.

// Automate Everything
You are a programmer, and that means your job is putting other people out of jobs with automation. The pinnacle of this is putting yourself out of a job with your own automation. Obviously you won't completely remove what you do, but if are spending your whole day rerunning manual tests in your terminal, then your job is not programming. You are doing QA, and you should automate yourself out of this QA job you probably don't really want anyway.

The easiest way to do this is to write automated tests, or unit tests. In this book I'm going to get into how to do this easily, and I'll avoid most of the dogma of when you should write tests. I'll focus on how to write them, what to test, and how to be efficient at the testing.

Common things programmers fail to automate but they should:
[1] Testing and validation.
[2] Build processes.
[3] Deployment of software.
[4] System administration.
[5] Error reporting.

Try to devote some of your time to automating this and you'll have more time to work on the fun stuff. Or, if this is fun to you, then maybe you should work on software that makes automating these things easier.

// Simplify And Clarify
The concept of "simplicity" is a slippery one to many people, especially smart people. They generally confuse "comprehension" with "simplicity". If they understand it well, clearly it's simple. The actual test of simplicity is by comparison with something else that could be simpler. But, you'll see people who write code go running to the most complex obtuse structures possible because they think the simpler version of the same thing is "dirty". A love affair with complexity is a programming sickness.

You can fight this disease by first telling yourself, "Simple and clear is not dirty, no matter what everyone else is doing." If everyone else is writing insane visitor patterns involving 19 classes over 12 interfaces and you can do it with two string operations, then you win. They are wrong, no matter how "elegant" they think their complex monstrosity is.

The simplest test of which function to use is:
[1] Make sure both functions have no errors. It doesn't matter how fast or simple a function is if it has errors.
[2] If you can't fix one, then pick the other.
[3] Do they produce the same result? If not then pick the one that has the result you need.
[4] If they produce the same result, then pick the one that either has fewer features, fewer branches, or you just think is simpler.
[5] Make sure you're not just picking the one that is most impressive. Simple and dirty beats complex and clean any day.

You'll notice that I mostly give up at the end and tell you to use your judgment. Simplicity is ironically a very complex thing, so using your tastes as a guide is the best way to go. Just make sure you adjust your view of what's "good" as you grow and gain more experience.

// Question Authority
The final strategy is the most important because it breaks you out of the defensive programming mindset and lets you transition into the creative mindset. Defensive programming is authoritarian and it can be cruel. The job of this mindset is to make you follow rules because without them you'll miss something or get distracted.

This authoritarian attitude has the disadvantage of disabling independent creative thought. Rules are necessary for getting things done, but being a slave to them will kill your creativity.

This final strategy means you should question the rules you follow periodically and assume that they could be wrong, just like the software you are reviewing. What I will typically do is, after a session of defensive programming, I'll go take a non-programming break and let the rules go. Then I'll be ready to do some creative work or do more defensive coding if need to.

// Order Is Not Important
The final thing I'll say on this philosophy is that I'm not telling you to do this in a strict order of "CREATE! DEFEND! CREATE! DEFEND!" At first you may want to do that, but I will actually do either in varying amounts depend on what I want to do, and I may even meld them together with no defined boundary.

I also don't think one mindset is better than another, or that there are strict separation between them. You need both creativity and strictness to do programming well, so work on both if you want to improve.

// Extra Credit
[1] The code in the book up to this point (and for the rest of it) potentially violates these rules. Go back through and apply what you've learned to one exercise to see if you can improve it or find bugs.
[2] Find an open source project and give some of the files a similar code review. Submit a patch that fixes a bug if you find it.

//-------------------------------------------------
// topic:	Exercise 28: Intermediate Makefiles
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------
In the next three Exercises you'll create a skeleton project directory to use in building your C programs later. This skeleton directory will be used in the rest of the book, and in this exercise I'll cover just the Makefile so you can understand it.

The purpose of this structure is to make it easy to build medium sized programs without having to resort to configure tools. If done right you can get very far with just GNU make and some small shell scripts.

// The Basic Project Structure
The first thing to do is make a c-skeleton directory and then put a set of basic files and directories in it that many projects have. Here's my starter:

	$ mkdir c-skeleton
	$ cd c-skeleton/
	$ touch LICENSE README.md Makefile
	$ mkdir bin src tests
	$ cp dbg.h src/   # this is from Ex20
	$ ls -l
	total 8
	-rw-r--r--  1 zedshaw  staff     0 Mar 31 16:38 LICENSE
	-rw-r--r--  1 zedshaw  staff  1168 Apr  1 17:00 Makefile
	-rw-r--r--  1 zedshaw  staff     0 Mar 31 16:38 README.md
	drwxr-xr-x  2 zedshaw  staff    68 Mar 31 16:38 bin
	drwxr-xr-x  2 zedshaw  staff    68 Apr  1 10:07 build
	drwxr-xr-x  3 zedshaw  staff   102 Apr  3 16:28 src
	drwxr-xr-x  2 zedshaw  staff    68 Mar 31 16:38 tests
	$ ls -l src
	total 8
	-rw-r--r--  1 zedshaw  staff  982 Apr  3 16:28 dbg.h
	$

At the end you see me do an ls -l so you can see the final results.

Here's what each of these does:

LICENSE
If you release the source of your projects you'll want to include a license. If you don't though, the code is copyright by you and nobody has rights to it by default.

README.md
Basic instructions for using your project go here. It ends in .md so that it will be interpreted as markdown.

Makefile
The main build file for the project.

bin/
Where programs that users can run go. This is usually empty and the Makefile will create it if it's not there.

build/
Where libraries and other build artifacts go. Also empty and the Makefile will create it if it's not there.

src/
Where the source code goes, usually .c and .h files.

tests/
Where automated tests go.

src/dbg.h
I copied the dbg.h from Exercise 20 into src/ for later.

I'll now break down each of the components of this skeleton project so you can understand how it works.

// Makefile
The first thing I'll cover is the Makefile because from that you can understand how everything else works. The Makefile in this exercise is much more detailed than ones you've used so far, so I'm going to break it down after you type it in:

	CFLAGS=-g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG $(OPTFLAGS)
	LIBS=-ldl $(OPTLIBS)
	PREFIX?=/usr/local

	SOURCES=$(wildcard src/**/*.c src/*.c)
	OBJECTS=$(patsubst %.c,%.o,$(SOURCES))

	TEST_SRC=$(wildcard tests/*_tests.c)
	TESTS=$(patsubst %.c,%,$(TEST_SRC))

	TARGET=build/libYOUR_LIBRARY.a
	SO_TARGET=$(patsubst %.a,%.so,$(TARGET))

	# The Target Build
	all: $(TARGET) $(SO_TARGET) tests

	dev: CFLAGS=-g -Wall -Isrc -Wall -Wextra $(OPTFLAGS)
	dev: all

	$(TARGET): CFLAGS += -fPIC
	$(TARGET): build $(OBJECTS)
	       ar rcs $@ $(OBJECTS)
	       ranlib $@

	$(SO_TARGET): $(TARGET) $(OBJECTS)
	       $(CC) -shared -o $@ $(OBJECTS)

	build:
	       @mkdir -p build
	       @mkdir -p bin

	# The Unit Tests
	.PHONY: tests
	tests: CFLAGS += $(TARGET)
	tests: $(TESTS)
	       sh ./tests/runtests.sh

	valgrind:
	       VALGRIND="valgrind --log-file=/tmp/valgrind-%p.log" $(MAKE)

	# The Cleaner
	clean:
	       rm -rf build $(OBJECTS) $(TESTS)
	       rm -f tests/tests.log
	       find . -name "*.gc*" -exec rm {} \;
	       rm -rf `find . -name "*.dSYM" -print`

	# The Install
	install: all
	       install -d $(DESTDIR)/$(PREFIX)/lib/
	       install $(TARGET) $(DESTDIR)/$(PREFIX)/lib/

	# The Checker
	BADFUNCS='[^_.>a-zA-Z0-9](str(n?cpy|n?cat|xfrm|n?dup|str|pbrk|tok|_)|stpn?cpy|a?sn?printf|byte_)'
	check:
	       @echo Files with potentially dangerous functions.
	       @egrep $(BADFUNCS) $(SOURCES) || true

*/ just to fix the color coded text!!

Remember that you need to indent the Makefile consistently with tab characters. Your editor should know that and do the right thing, but if it doesn't then get a different text editor. No programmer should use an editor that fails at something so simple.

// The Header
This makefile is designed to build a library we'll be working on later and to do so reliably on almost any platform by using special features of GNU make. I'll break down each part in sections, starting with the header.

Makefile:1
These are the usual CFLAGS that you set in all of your projects, but with a few others that may be needed to build libraries. You may need to adjust these for different platforms. Notice the OPTFLAGS variable at the end which lets people augment the build options as needed.

Makefile:2
Options used when linking a library, and allows someone else to augment the linking options using the OPTLIBS variable.

Makefile:3
Setting an optional variable called PREFIX that will only have this value if the person running the Makefile didn't already give a PREFIX setting. That's what the ?= does.

Makefile:5
This fancy line of awesome dynamically creates the SOURCES variable by doing a wildcard search for all *.c files in the src/ directory. You have to give both src/**/*.c and src/*.c so that GNU make will include the files in src and also the ones below it.    */ just to fix the color coded text!!

Makefile:6
Once you have the list of source files, you can then use the patsubst to take the SOURCES list of *.c files and make a new list of all the object files. You do this by telling patsubst to change all %.c extensions to %.o and then those are assigned to OBJECTS.

Makefile:8
Using the wildcard again to find all the test source files for the unit tests. These are separate from the library's source files.

Makefile:9
Then using the same patsubst trick to dynamically get all the TEST targets. In this case I'm stripping away the .c extension so that a full program will be made with the same name. Previously I had replaced the .c with {.o} so an object file is created.

Makefile:11
Finally, we say the ultimate target is build/libYOUR_LIBRARY.a, which you will change to be whatever library you are actually trying to build.

This completes the top of the Makefile, but I should explain what I mean by "lets people augment the build". When you run make you can do this:

	# WARNING! Just a demonstration, won't really work right now.
	# this installs the library into /tmp
	$ make PREFIX=/tmp install
	# this tells it to add pthreads
	$ make OPTFLAGS=-pthread

If you pass in options that match the same kind of variables you have in your Makefile, then those will show up in your build. You can then use this to change how the Makefile runs. The first one alters the PREFIX so that it installs into /tmp instead. The second one sets OPTFLAGS so that the -pthread option is present.

// The Target Build
Continuing with the breakdown of the Makefile I have actually building the object files and targets:

Makefile:14
Remember that the first target is what make will run by default when no target is given. In this case it's called all: and it gives $(TARGET) tests as the targets to build. Look up at the TARGET variable and you see that's the library, so all: will first build the library. The tests target is then further down in the Makefile and builds the unit tests.

Makefile:16
Another target for making "developer builds" that introduces a technique for changing options for just one target. If I do a "dev build" I want the CFLAGS to include options like -Wextra that are useful for finding bugs. If you place them on the target line as options like this, then give another line that says the original target (in this case all) then it will change the options you set. I use this for setting different flags on different platforms that need it.

Makefile:19
Builds the TARGET library, whatever that is, and also uses the same trick from line 15 of giving a target with just options changes to alter them for this run. In this case I'm adding -fPIC just for the library build using the += syntax to add it on.

Makefile:20
Now the real target where I say first make the build directory, then compile all the OBJECTS.

Makefile:21
Runs the ar command which actually makes the TARGET. The syntax $@ $(OBJECTS) is a way of saying, "put the target for this Makefile source here and all the OBJECTS after that". In this case the $@ maps back to the $(TARGET) on line 19, which maps to build/libYOUR_LIBRARY.a. It seems like a lot to keep track of this indirection, and it can be, but once you get it working this means you just change TARGET at the top and build a whole new library.

Makefile:22
Finally, to make the library you run ranlib on the TARGET and it's built.

Makefile:24-24
This just makes the build/ or bin/ directories if they don't exist. This is then referenced from line 19 when it gives the build target to make sure the build/ directory is made.

You now have all the stuff you need to build the software, so we'll create a way to build and run unit tests to do automated testing.

// The Unit Tests
C is different from other languages because it's easier to create one tiny little program for each thing you're testing. Some testing frameworks try to emulate the module concept other languages have and do dynamic loading, but this doesn't work well in C. It's also unnecessary because you can just make a single program that's run for each test instead.

I'll cover this part of the Makefile, and then later you'll see the contents of the tests/ directory that make it actually work.

Makefile:29
If you have a target that's not "real", but there is a directory or file with that name, then you need to tag the target with .PHONY: so make will ignore the file and always run.

Makefile:30
I use the same trick for modifying the CFLAGS variable to add the TARGET to the build so that each of the test programs will be linked with the TARGET library. In this case it will add build/libYOUR_LIBRARY.a to the linking.

Makefile:31
Then I have the actual tests: target which depends on all the programs listed in the TESTS variable we created in the header. This one line actually says, "Make, use what you know about building programs and the current CFLAGS settings to build each program in TESTS."

Makefile:32
Finally, when all of the TESTS are built, there's a simple shell script I'll create later that knows how to run them all and report their output. This line actually runs it so you can see the test results.

Makefile:34-35
In order to be able to dynamically rerun the tests with Valgrind there's a valgrind: target that sets the right variable and runs itself again. This puts the valgrind logs into /tmp/valgrind-*.log so you can go look and see what might be going on. The tests/runtests.sh then knows to run the test programs under Valgrind when it sees this VALGRIND variable.

For the unit testing to work you'll need to create a little shell script that knows how to run the programs. Go ahead and create this tests/runtests.sh script:

echo "Running unit tests:"

	for i in tests/*_tests
	do
	    if test -f $i
	    then
		if $VALGRIND ./$i 2>> tests/tests.log
		then
		    echo $i PASS
		else
		    echo "ERROR in test $i: here's tests/tests.log"
		    echo "------"
		    tail tests/tests.log
		    exit 1
		fi
	    fi
	done

	echo ""


*/ just to fix the color coded text!!
I'll be using this later when I cover how unit tests work.

// The Cleaner
I now have fully working unit tests, so next up is making things clean when I need to reset everything.

Makefile:38
The clean: target starts things off whenever we need to clean up the project.

Makefile:39-42
This cleans out most of the junk that various compilers and tools leave behind. It also gets rid of the build/ directory and uses a trick at the end to cleanly erase the weird *.dSYM directories Apple's XCode leaves behind for debugging purposes.

If you run into junk that you need to clean out, simply augment the list of things being deleted in this target.

// The Install
After that I'll need a way to install the project, and for a Makefile that's building a library I just need to put something in the common PREFIX directory, which is usually /usr/local/lib.

Makefile:45
This makes install: depend on the all: target so that when you run make install it will be sure to build everything.

Makefile:46
I then use the program install to create the target lib directory if it doesn't exist. In this case I'm trying to make the install as flexible as possible by using two variables that are conventions for installers. DESTDIR is handed to make by installers that do their builds in secure or odd locations to build packages. PREFIX is used when people want the project to be installed in someplace other than /usr/local.

Makefile:47
After that I'm just using install to actually install the library where it needs to go.

The purpose of the install program is to make sure things have the right permissions set. When you run make install you usually have to do it as the root user, so the typical build process is make && sudo make install.

// The Checker
The very last part of this Makefile is a bonus that I include in my C projects to help me dig out any attempts to use the "bad" functions in C. Namely the string functions and other "unprotected buffer" functions.

Makefile:50
Sets a variable which is a big regex looking for bad functions like strcpy.

Makefile:51
The check: target so you can run a check whenever you need.

Makefile:52
Just a way to print a message, but doing @echo tells make to not print the command, just its output.

Makefile:53
Run the egrep command on the source files looking for any bad patterns. The || true at the end is a way to prevent make from thinking that egrep not finding things is a failure.

When you run this it will have the odd effect that you'll get an error when there is nothing bad going on.

// What You Should See
I have two more exercises to go before I'm done building the project skeleton directory, but here's me testing out the features of the Makefile.

$ make clean
rm -rf build  
rm -f tests/tests.log 
find . -name "*.gc*" -exec rm {} \;
rm -rf `find . -name "*.dSYM" -print`
$ make check
Files with potentially dangerous functions.
^Cmake: *** [check] Interrupt: 2

	$ make
	ar rcs build/libYOUR_LIBRARY.a 
	ar: no archive members specified
	usage:  ar -d [-TLsv] archive file ...
	      ar -m [-TLsv] archive file ...
	      ar -m [-abiTLsv] position archive file ...
	      ar -p [-TLsv] archive [file ...]
	      ar -q [-cTLsv] archive file ...
	      ar -r [-cuTLsv] archive file ...
	      ar -r [-abciuTLsv] position archive file ...
	      ar -t [-TLsv] archive [file ...]
	      ar -x [-ouTLsv] archive [file ...]
	make: *** [build/libYOUR_LIBRARY.a] Error 1
	$ make valgrind
	VALGRIND="valgrind --log-file=/tmp/valgrind-%p.log" make
	ar rcs build/libYOUR_LIBRARY.a 
	ar: no archive members specified
	usage:  ar -d [-TLsv] archive file ...
	      ar -m [-TLsv] archive file ...
	      ar -m [-abiTLsv] position archive file ...
	      ar -p [-TLsv] archive [file ...]
	      ar -q [-cTLsv] archive file ...
	      ar -r [-cuTLsv] archive file ...
	      ar -r [-abciuTLsv] position archive file ...
	      ar -t [-TLsv] archive [file ...]
	      ar -x [-ouTLsv] archive [file ...]
	make[1]: *** [build/libYOUR_LIBRARY.a] Error 1
	make: *** [valgrind] Error 2
	$

When I run the clean: target that works, but because I don't have any source files in the src/ directory none of the other commands really work. I'll finish that up in the next exercises.

// Extra Credits
[1] Try to get the Makefile to actually work by putting a source and header file in src/ and making the library. You shouldn't need a main function in the source file.
[2] Research what functions the check: target is looking for in the BADFUNCS regular expression it's using.
[3] If you don't do automated unit testing, then go read about it so you're prepared later.

//-------------------------------------------------
// topic:	Exercise 29: Libraries And Linking
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 30: Automated Testing
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 31: Debugging Code
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 32: Double Linked Lists
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 33: Linked List Algorithms
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 34: Dynamic Array
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 35: Sorting And Searching
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 36: Safer Strings
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 37: Hashmaps
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

//-------------------------------------------------
// topic:	Exercise 38: Hashmap Algorithms
// source:	http://c.learncodethehardway.org/book
//-------------------------------------------------

